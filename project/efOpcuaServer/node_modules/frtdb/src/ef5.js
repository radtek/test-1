const fs = require('fs');
var iconv = require('iconv-lite');
var SMB2 = require("smb2");
var zlib = require('zlib'); //解压 压缩
var xml2js = require('xml2js');//解析xml

var DB;

class ef5{
    constructor(){
        this.tagTypeName = [];
		this.dwClientId;
		this.szTypeName = [];
		this.tagType = [];
		this.mapIdToNodeName = [];
		this.mapNameToTag = [];
		this.listTagInfo = [];
		this.mapIdToTagInfo = [];
		this.mapIdToRegTagPar = [];
		this.mapRegNoToRegTagPar = [];
		this.dwRegData = [];
		this.dwRegisterNo = [];
		this.dataCopy;
		this.emMode = 0;
        this.bUpdateSwitch = 0;
        this.notarizeAlm = 0;
		this.alm;
		this. nodeChange = {
			//获取实时数据
			NET_READ_DATA_REQ : 46,
			NET_READ_DATA_ANS : 47,
			NET_REGISTER_REQ : 41,
			NET_REGISTER_ANS : 42,
			//获取点编号
			NET_TAGPARID_REQ :44,
			NET_TAGPARID_ANS :45,
			//读取节点信息
			NET_READ_NODEXML_REQ :92,
			NET_READ_NODEXML_ANS :93,
			//插入历史
			NET_INSERT_HIS_DATA_REQ :88,
			NET_INSERT_HIS_DATA_ANS :89,
			//获取历史
			NET_READ_HIS_REQ:54,
			NET_READ_HIS_ANS:55,
			//获取历史扩展(统计)
			NET_READ_HIS_EX_REQ:62,
			NET_READ_HIS_EX_ANS:63,
			//注册订阅
			NET_REG_TAGPAR_REQ:49,
			NET_REG_TAGPAR_ANS:50,
			//注销订阅
			NET_UNREG_TAGPAR_REQ:53,
			//追忆历史
			NET_READ_RAWHIS_REQ:56,
			NET_READ_RAWHIS_ANS:57,
			//获取全部实时报警
			NET_ALL_ALMINFO_REQ:66,
			NET_ALL_ALMINFO_ANS:67,
			//获取点信息(点ID)
			NET_TAGINFO_REQ:60,
			NET_TAGINFO_ANS:61,
			//增加测点
			NET_ADD_TAG_REQ:90,
			NET_ADD_TAG_ANS:91,
			//开启报警订阅
			NET_SUBSCRIBE_ALMINFO_REQ:68,
			NET_SUBSCRIBE_ALMINFO_ANS:69,
			//关闭报警定订阅
			NET_UNSUBSCRIBE_ALMINFO_REQ:72,
			NET_UNSUBSCRIBE_ALMINFO_ANS:73,
			//报警确认
			NET_ACK_ALM_REQ:74,
			//增加报警标签
			NET_ADD_ALM_COMMENT_REQ:75,
			//查询历史报警
			NET_QUERY_HIS_ALM_REQ:76,
			NET_QUERY_HIS_ALM_ANS:77,
			//查询报警评论
			NET_QUERY_HIS_ALM_COMMENT_REQ:78,
			NET_QUERY_HIS_ALM_COMMENT_ANS:79,
			//查询统计
			NET_READ_STATISTICS_DATA_REQ:80,
			NET_READ_STATISTICS_DATA_ANS:81,
			//获取全部历史点参数编号
			NET_HISTAGPAR_REQ:64,
			NET_HISTAGPAR_ANS:65,
			//写实时
			NET_WRITE_DATA_REQ:48,
			//开启报警订阅
			NET_SUBSCRIBE_ALMINFO_REQ:68,
			NET_SUBSCRIBE_ALMINFO_ANS:69,
			//请求改变的报警信息
			NET_CHANGE_ALMINFO_REQ:70,
			NET_CHANGE_ALMINFO_ANS:71,
			//关闭报警定订阅
			NET_UNSUBSCRIBE_ALMINFO_REQ:72,
			NET_UNSUBSCRIBE_ALMINFO_ANS:73,
			//更新订阅数据
			NET_UPDATE_REG_TAGPAR_DATA_REQ:51,
			NET_UPDATE_REG_TAGPAR_DATA_ANS:52,
		}

        this.nodeSiteStata = {
			//独立站
			station_detach : 0,
			//主站
			station_master : 1,
			//从站
			station_slave : 2,
			//历史站
			station_his : 3,
			//热备主
			station_hotbackup_master : 4,
			//热备从
			station_hotbackup_slave : 5
        }
        
        this.emDBValType = {
			dbvt_none:0,
			dbvt_int:1,
			dbvt_real:2,
			dbvt_enum:3,
			dbvt_string:4
        }
        
		this.NET_PACK_HEAD_LEN = 16;
		this.PACK_TYPE_DATA = 0;//是数据
		this.PACK_TYPE_FILE = 1;
		this.PACK_TYPE_STAT = 2;//网络状态
        this.almChange = false;
        this.dbChange = false;
        this.arrData = [];
        this.getLayer = [];
        this.nodeInfo;
        this.callbackDataChange = [];
    }

    guid() {
        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
        var r = Math.random()*16|0, v = c == 'x' ? r : (r&0x3|0x8);
        return v.toString(16);
        });
    }  

    addPacketHeader(dataPackage){
        let bRet = 0;
        //let netDataPackageHead = Buffer.alloc(16);
        if(dataPackage != null){
			//填充客户端ID
			if (dataPackage.readInt16LE(24 + 16) != this.nodeChange.NET_REGISTER_REQ){
				dataPackage.writeUInt32LE(this.dwClientId, (52 + 16), true);
			}
			
			dataPackage.writeInt16LE(2, (18 + 16));
			dataPackage.writeInt32LE(-1, (14 + 16));
			this.dataCopy = dataPackage;

			dataPackage.writeUInt32LE(0x88888888, 0, true);
			dataPackage.writeUInt32LE(0x88888888, 4, true);
			dataPackage.writeInt32LE((76 + dataPackage.readInt32LE(26 + 16)), 8, true);
			dataPackage.writeInt32LE(0, 12);      
        }
        else{
            dataPackage.writeUInt32LE(0x88888888, 0, true);
			dataPackage.writeUInt32LE(0x88888888, 4, true);
			dataPackage.writeInt32LE(16, 8, true);
			dataPackage.writeInt32LE(2, 12);
        }
		return dataPackage;
    }

    readStringName(buffer,nOffset,strlen,encoding = 'ascii'){
        let nLen = 0;
        let arrContent = [];
        let c;
        while ((c = buffer.readInt16LE(nOffset)) != 0) {
            if(strlen == nLen){
                break;
            }
            arrContent[nLen++] = c;
            nOffset ++;
        }
        
        const buf = Buffer.from(arrContent);
        return buf;
    }
    
    readStringDescribe(buffer,nOffset,sLen,encoding = 'ascii'){
        let nLen = 0;
        let arrContent = [];
        let c;
        let number = 0;
        while (((c = buffer.readUInt8(nOffset)) != 0)||(nOffset <= buffer.length - 1)) {
            arrContent[nLen++] = c;
            nOffset ++;
            number++;
            if(number == (sLen*2)){
                break;
            }
        }
        
        const buf = Buffer.from(arrContent);
        return buf;
    }

    reviewReadString(buffer,nOffset,encoding = 'ascii'){
        let nLen = 0;
        let arrContent = [];
        let c;
        let number = 0;
		while ((c = buffer.readInt16LE(nOffset)) != 0){
			number++;
			arrContent[nLen++] = c;
			nOffset ++;
			if(review == false){
				arrContent[nLen++] = c;
				break;
			}
			if(buffer.length - 1 <= nOffset){
				review = false;
			}
		} 
        const buf = Buffer.from(arrContent);
        return buf;
    }
    
	readString(buffer,nOffset,encoding = 'ascii'){
        let nLen = 0;
        let arrContent = [];
        let c;
		while ((c = buffer.readInt16LE(nOffset)) != 0){
			arrContent[nLen++] = c;
			nOffset +=2;
			if(buffer.length- 1 <= nOffset){
				break;
			}
		}
        const buf = Buffer.from(arrContent);
        return buf;
    }
    
	readStringXml(buffer,nOffset,encoding = 'ascii'){
        let nLen = 0;
        let arrContent = [];
		let c;
		let xml = false;
		while (((c = buffer.readInt16LE(nOffset)) != 0)&&(xml == false)){
			arrContent[nLen++] = c;
			nOffset ++ ;

			if(buffer.length- 1 <= nOffset){
                xml = true;
                break;
            }
		}
        const buf = Buffer.from(arrContent);
        return buf;
    }
    
	almLogReadString(buffer,nOffset,len,encoding = 'ascii'){
        let nLen = 0;
        let arrContent = [];
        let c;
        let number = 0;
		while ((c = buffer.readInt16LE(nOffset)) != 0){
			number++;
			arrContent[nLen++] = c;
			nOffset ++;
			if(buffer.length - 1 <= nOffset){
				break;
				almLog = false;
			}
			else if(number == len){
				break;
				almLog = false;
				
			}
		}
        const buf = Buffer.from(arrContent);
        return buf;
    }
    
    almLogReadCommentString(buffer,nOffset,encoding = 'ascii'){
        let nLen = 0;
        let arrContent = [];
        let c;
        let number = 0;
		while ((c = buffer.readInt16LE(nOffset)) != 0){
			number++;
			arrContent[nLen++] = c;
			nOffset ++;
			if(buffer.length - 1 <= nOffset){
				break;
				almLog = false;
			}
			else if(number == 46){
				break;
				almLog = false;
				
			}
		}
        const buf = Buffer.from(arrContent);
        return buf;
    }
    
    almDecsReadString(buffer,nOffset,len,encoding = 'ascii'){
        let nLen = 0;
        let arrContent = [];
        let c;
        let number = 0;
        while (((c = buffer.readUInt8(nOffset)) != 0)||(nOffset <= buffer.length - 1)) {
			number++;
			arrContent[nLen++] = c;
			nOffset ++;
			if(number == (len * 2)){
				break;
				almLog = false;
				
			}
		}
        const buf = Buffer.from(arrContent);
        return buf;
    }
    //订阅实时
    callbackData(dataBuffer){
        let dbData = [];
        let lOffSet = 60 + 16; //
        //数据原始长度
        let dwSourceLen = dataBuffer.readUInt32LE(lOffSet);
        lOffSet += 4;
        //解药数据
        let buffer = zlib.unzipSync(dataBuffer.slice(lOffSet));

        //处理数据,数据个数
        let lCount = 0;
        let offSet = 0;
        lCount = buffer.readInt32LE(offSet);
        offSet += 4;
        //如果没有数据直接返回
        if (lCount <= 0){
            return ;
        }
        let arrData = {};
        for(let i = 0; i < lCount; i++){
            //let data = {};
            arrData.iTime = buffer.readInt32LE(offSet);
            offSet += 8;
            arrData.iMilli = buffer.readInt16LE(offSet);
            offSet += 2;
            arrData.iItemType = buffer.readInt16LE(offSet);
            offSet += 2;
            arrData.iParNo = buffer.readInt16LE(offSet);
            offSet += 2;
            arrData.iSaveToFile = buffer.readInt16LE(offSet) & 0xff;
            arrData.iReserve = buffer.readInt16LE(offSet) >> 8 & 0xff;
            offSet += 2;
            arrData.iTagId = buffer.readInt32LE(offSet);
            offSet += 4;
            arrData.iQuality = buffer.readInt32LE(offSet);
            offSet += 4;
            arrData.data = buffer.readDoubleLE(offSet);
            offSet += 8;
            for(let j = 0; j < DB.mapRegNoToRegTagPar.length; j++){
                if(arrData.iTagId == DB.mapRegNoToRegTagPar[j].regTagPar.tagId){
                    dbData.push({parNo:arrData.iParNo,tagId:arrData.iTagId,data:arrData.data});
                }
            }
        }
        this.callbackDataChange(dbData);
    }

    //订阅报警
    callbackAlm(dataBuffer){
        let lOffSet = 60 + 16;
        let lCount = dataBuffer.readUInt32LE(lOffSet);
        lOffSet += 4;
        //数据原始长度
        let dwSourceLen = dataBuffer.readUInt32LE(lOffSet);
        lOffSet += 4;
        if(lCount > 0){
            let len = dataBuffer.readUInt32LE(26);
            let ulLen = len - 8;
            //解药数据
            let buffer = zlib.unzipSync(dataBuffer.slice(lOffSet));
            let almLogInfo = [];
            let offer = 0;
            for(let i = 0; i < lCount; i++){
                let newAlmLogInfo = {};
                let almId = buffer.readUIntLE(offer,8);
                offer += 8;
                let dwAlmStatus = buffer.readInt16LE(offer);
                offer += 2;
                let almType = buffer.readInt16LE(offer);
                offer += 2;
                //newAlmLogInfo.dwMilli = buffer.readUInt32LE(offer);
                offer += 8;
                offer += 4;
                if(dwAlmStatus == 0){
                    newAlmLogInfo.almId = almId;
                    newAlmLogInfo.almType = almType;
                    newAlmLogInfo.tagId = buffer.readInt32LE(offer);
                    offer += 4;
                    //newAlmLogInfo.dwNodeId = buffer.readInt16LE(offer);
                    offer += 2;
                    //newAlmLogInfo.dwParNo = buffer.readInt16LE(offer);
                    offer += 2;
                    newAlmLogInfo.almPrio = buffer.readInt32LE(offer);
                    offer += 4;
                   // newAlmLogInfo.dwAlmGroup = buffer.readInt32LE(offer);
                    offer += 4;
                    //newAlmLogInfo.dbValue = buffer.readDoubleLE(offer);
                    offer += 8;
                    let len = buffer.readInt32LE(offer);
                    offer += 4;
                    let dwOffSet = buffer.readInt32LE(offer);
                    if(len > 0){
                        let bufferTest = DB.almLogReadString(buffer,dwOffSet,len*2); 
                        newAlmLogInfo.almDecs = iconv.decode(bufferTest, 'UTF-16');
                    }
                    offer += 4;
                    //len = buffer.readDoubleLE(offer);
                    offer += 4;
                    //dwOffSet = buffer.readDoubleLE(offer);
                    //if(len > 0){
                        //let bufferTest = DB.almLogReadString(buffer,dwOffSet,len*2); 
                        //newAlmLogInfo.dsDesc = iconv.decode(bufferTest, 'UTF-16');
                    //}
                    offer += 4;
                    //len = buffer.readDoubleLE(offer);
                    offer += 4;
                    //dwOffSet = buffer.readDoubleLE(offer);
                    //if(len > 0){
                        //let bufferTest = DB.almLogReadString(buffer,dwOffSet,len*2); 
                        //newAlmLogInfo.dsAlmRemark = iconv.decode(bufferTest, 'UTF-16');
                    //}
                    offer += 4;
                    almLogInfo.push({almId:newAlmLogInfo.almId,almType:newAlmLogInfo.almType,tagId:newAlmLogInfo.tagId,almPrio:newAlmLogInfo.almPrio,almDecs:newAlmLogInfo.almDecs});
                }
                if(dwAlmStatus == 2){

                }
            
            }
            if(almLogInfo.length == 0){
                console.log("报警回复和报警结束没有字符串");
                almLogInfo = "报警回复和报警结束没有字符串";
            }
            this.callbackAlmChange(almLogInfo);
        }
    }
}

module.exports = {
    //同步
    "localMethod":{
        "getPacketType":function(pkage){
            if(pkage.length == 20){
                return pkage.readInt16LE(12);
            }
            else{
                let number = pkage.readInt16LE(40);
                return number - 1;
            }
        },
        //方法必须存在
        "unknownPacket":function(pkage){
            if(pkage.readInt32LE(12) == this.PACK_TYPE_STAT){
                let buff = this.addPacketHeader(heartbeat);
                return buff;
            }
        },
        //获取点名 getTagName(arrTagId)
        "getTagName":function(arrTagId){ 
            let arrName = [];
            for (let j = 0; j < arrTagId.length; j++){
                let tagId = arrTagId[j];
                for(let i = 0; i < DB.listTagInfo.length; i++){
                    if(tagId == DB.listTagInfo[i].tagId){
                        arrName.push({tagId,name:DB.listTagInfo[i].tagName});
                    }
                }

            }
            return {retCode:true,retData:arrName}
        },

        //获取全部点类型信息
        "getAllTagType":function(){ 
            //点类型信息
            let dotTagType = [];
            let lCount = 0;
            let sType = 0;
            for (let i=0; i < 280; i++){
                if (DB.tagType[i] != null){
                    lCount++;
                }
            }
            for(let j = 0; j < lCount; j++){
                sType ++;
                dotTagType[j] = {typeId:sType,typeName:DB.szTypeName[j]}
            }
            return {retCode:true,retData:dotTagType}
        },

        //获取指定点类型参数列表
        "getTagTypeParInfo":function(typeId){ 
            //点的全部信息
            let dotInformation = [];
            for (let j = 0; j < typeId.length; j++){
                let number = typeId[j];
                let dotType = DB.szTypeName[number];
                //console.log(DB.tagType[number]);
                let type = DB.tagType[number].nameToParInfo;
                dotInformation.push({dotType:dotType,number:type.length});
            }
            return {retCode:true,retData:dotInformation}
        },

        //获取点参数序号 
        "getTagParId":function(arrName){ 
            let dotParId = [];
            for (let i = 0; i < arrName.length; i++){
                let name = arrName[i];
                /* dotParId[i] = */
                const tmpInfo = DB.mapNameToTag[name];
                // dotParId.push(tmpInfo.TagInfo.tagId);
                if(tmpInfo != undefined){
                    dotParId[i] = {tagId:tmpInfo.TagInfo.tagId};
                }
            }
            return {retCode:true,retData:dotParId}
        }, 

        //获取当前层的所有点名
        "getTagInfo":function(stratumId){
            let tagName = [];
            let tagInfo = [];
            for(let j = 0; j < stratumId.length; j++){
                for(let i = 0; i < DB.arrData.length; i++){
                    if(stratumId[j] ==  DB.arrData[i].tagInfo){
                        tagName.push({tagId:DB.arrData[i].tagId,tagName:DB.arrData[i].tagName,tagShortName:DB.arrData[i].tagShortName});
                    }
                }
            }
            function sort(tagName){
                for(let i = 0; i < tagName.length - 1; i++){
                    for(let j = 0; j < tagName.length - i - 1; j++){
                        if(tagName[j].tagId > tagName[j+1].tagId){
                            let hand = tagName[j];
                            tagName[j] = tagName[j+1];
                            tagName[j+1] = hand;
                        }
                    }
                }
                tagInfo = tagName;
                return tagName;
            }
            sort(tagName);
            return {retCode:true,retData:tagInfo}
        },

        //获取层数组
        "getLayer":function(){
            return {retCode:true,retData:DB.getLayer}
        },
        "login":async function(){
            await this.login1();
            await this.getDBNodeInfo();    
            if(this.options.enableAlarm == true){
                await this.openSubscribeAlm(1);
            }
        },

        //获取层节点信息的嵌套格式
        "getLayerInfo":function(){
            let tmp;
            xml2js.parseString(DB.nodeInfo, {explicitArray : false}, function (err, result) {
                let strRes = JSON.stringify(result);
                // let str1 = strRes.replace(/\"\$\"\:\{([a-zA-Z0-9-\u4e00-\u9fa5\\"\:\,]+)\}/g,function(m,g1,g2,g3){//保留字符
                //     return g1;
                // });
                // let layer = str1.replace(/LAYER/g,"children");
                // let layer1 = layer.replace(/NodeID/g,"layerId"); 
                // let layers = layer1.replace(/Name/g,"layerName");   
                
                let str1 = strRes.replace(/NodeID/g,"layerId"); 
                let layer = str1.replace(/LAYER/g,"children");
                let layer1 = layer.replace(/Name/g,"layerName");  
                let layers = layer1.replace(/\"\$\"\:\{([a-zA-Z0-9-\u4e00-\u9fa5\\"\:\,\_]+)\}/g,function(m,g1,g2,g3){//保留字符
                    return g1;
                });        
                let rJson = JSON.parse(layers);   
                tmp = rJson.DbManger;
                return rJson.DbManger;
            }); 
            return {retCode:true,retData:tmp}
        },
		"getTagTypeAddForUa":function(){
			
			return DB.tagTypeName;
		},
		"getTagInfoAddForUa":function(){
			return DB.listTagInfo;
		},
        "getTagType": function(){
            let tagType;
            for(let i = 0; i < DB.tagTypeName.length; i++){
                if(DB.tagTypeName[i].tagName == tagName){
                    tagType = DB.tagTypeName[i].tagType;
                    break;
                }
            }
            let tagTypeName;
            tagTypeName = DB.tagType[tagType].typeName;
      
            return tagTypeName;
        },
        "getParName": function(){
            let number = "此接口暂未开通";
            return number;
        },
        "getParId": function(){
            let number = "此接口暂未开通";
            return number;
        },
        "getTagCount": function(){
            let number = "此接口暂未开通";
            return number;
        },
        "getAlmCount": function(){
            let number = "此接口暂未开通";
            return number;
        },
        "getRegCount": function(){
            let number = "此接口暂未开通";
            return number;
        },
        "isWorking": function(){
            let number = "此接口暂未开通";
            return number;
        },
        "getHisReadProcessed": function(){
            let data = "此接口暂未开通";
            return data;
        }
    },
    //异步
    "remoteMethod":{
        //链接
        "login1":class{
            constructor(){
                this.packetType = 41;
            };
            serilize(jsonObj){
                DB.emMode = 2;
                let m_guidClient = DB.guid();
                let bufHead = Buffer.alloc(60);
                let RegdataPackage = Buffer.alloc(260 + 16);
                let ucLocal = (DB.emMode == 1) ? 0 : 1;
                //DB.addPacketHeader(RegdataPackage);
                //偏移量
                let lOffSet = 60 + 16;//sizeof(NETHEAD);
                //附上用户名和密码
        
                // PStructLoginInfo pLoginInfo = (PStructLoginInfo)(RegdataPackage + sizeof(NETHEAD));
                // memcpy(pLoginInfo, &m_LonginInfo, sizeof(StructLoginInfo));
                RegdataPackage.fill(0, 60, (96 + 16));
                lOffSet += 96;//sizeof(StructLoginInfo);
                //是否要开启订阅更新服务
                //*((BOOL *)(RegdataPackage+lOffSet)) = bUpdateSwitc;
                RegdataPackage.writeInt32LE(true,lOffSet);
                lOffSet += 4;//sizeof(BOOL);
        
                //客户端关注的通用处理事件
                //*((DWORD *)(RegdataPackage+lOffSet)) = GetGeneralCode();
                RegdataPackage.writeInt32LE(0,lOffSet);
                lOffSet += 4;//sizeof(DWORD);
                //附加上客户端的GUID
                // PLoginInfoExtra pLoginInfoEx = (PLoginInfoExtra)(RegdataPackage + lOffSet);
                // pLoginInfoEx->shVer = 1;
                // memcpy(&pLoginInfoEx->guidClient, &m_guidClient, sizeof(GUID));
                RegdataPackage.writeInt16LE(1,lOffSet);
                lOffSet += 2;
                RegdataPackage.write(m_guidClient,lOffSet);
                lOffSet += 16;//sizeof(tagLoginInfoExtra);
                
        
                bufHead.fill(0, 0, 5);//char szOldSource[SRC_LEN - 1]; //包发送者标识for client
                bufHead.writeInt8(0, 5);//BYTE bCompress;
                bufHead.writeInt16LE(1, 6);//short p3;//用户参数3
        
                bufHead.fill(0, 8, 4);//char szSource[4]; //保留 for client
                bufHead.writeInt8(0, 12);//BYTE cReserved[2]; //保留
        
                bufHead.writeInt32LE(1, 14);//long sock; //保留 for server
                bufHead.writeInt16LE(2, 18);//short serno; //保留 serial no
                bufHead.writeInt16LE(0, 20);//short no; //保留pack no
        
                bufHead.writeInt16LE(0, 22);//short id; //系列号 serial no
                bufHead.writeInt16LE(DB.nodeChange.NET_REGISTER_REQ, 24);//short type; //包类型 pack type
                bufHead.writeInt32LE(lOffSet - 60, 26);//long len;//包长度
        
                bufHead.writeInt16LE(2049, 30);//short p1;//用户参数1
                bufHead.writeInt16LE(0, 32);//short p2; //用户参数2
                bufHead.writeInt16LE(0, 34);//short code;//是否为结束包
        
                bufHead.fill(0, 36, 16);//char szNode[16];//目的地机器标识
                bufHead.fill(0, 52, 8);//char szTopic[8];//保留
        
        
                bufHead.copy(RegdataPackage,16);
                let buff = DB.addPacketHeader(RegdataPackage);
                return buff;
            };
            unserilize(buff){
                //获取db返回的客户端id
                //let buff = DB.onNetRecvMsg(dataPackage);
        
                DB.dwClientId = buff.readUInt32LE(52 + 16);
                // //记录获取站状态的时间
        
                //解析其他数据
                let lOffSet = 60 + 16;
                let stationStatus = buff.readUInt16LE(lOffSet);
                //获取站类型
                //statuionType = (emStationType)HIBYTE(stationStatus);
                let statuionType = 0;
                if(stationStatus == 0){
                    statuionType = DB.nodeSiteStata.station_detach;
                }
                else if(stationStatus == 1){
                    statuionType = DB.nodeSiteStata.station_master;
                }
                else if(stationStatus == 2){
                    statuionType = DB.nodeSiteStata.station_slave;
                }
                else if(stationStatus == 3){
                    statuionType = DB.nodeSiteStata.station_his;
                }
                else if(stationStatus == 4){
                    statuionType = DB.nodeSiteStata.station_hotbackup_master;
                }
                else if(stationStatus == 5){
                    statuionType = DB.nodeSiteStata.station_hotbackup_slave;
                }
                //获取db的工作状态
        
                let bIsWorking = stationStatus;
                lOffSet += 2;
                //DB的版本信息
                let dbVerMessage = {};
                dbVerMessage.wProductType = buff.readUInt16LE(lOffSet);
                lOffSet += 2;
                dbVerMessage.wMajor = buff.readUInt16LE(lOffSet);
                lOffSet += 2;
                dbVerMessage.wMinor = buff.readUInt16LE(lOffSet);
                lOffSet += 2;
                dbVerMessage.wBuild = buff.readUInt16LE(lOffSet);
                lOffSet += 2;
                dbVerMessage.wQFE = buff.readUInt16LE(lOffSet);
                lOffSet += 2;
                //数据原始长度
                let dwSourceSize = buff.readUInt32LE(lOffSet);
                lOffSet += 4;
            
                let bs = zlib.unzipSync(buff.slice(lOffSet));
                let buffer = Buffer.from(bs);
                let offSet = 0;
                let sTypeCount = buffer.readInt16LE(offSet);
                offSet += 2;
                //
                for (let i = 0; i < sTypeCount; i++){
                    //点类型号
                    let sTagType = -1;
        
                    sTagType = buffer.readInt16LE(offSet);
                    offSet += 2;
                    if ((sTagType < 0) || (sTagType > 280)){
                        bRet = false;
                        break;
                    }
                    //初始化点类型
                    //点类型名称
                    let name = DB.readStringName(buffer,offSet); 
                    let dotName = iconv.decode(name, 'UTF-16');
                    DB.szTypeName.push(dotName);
                    offSet += 64;
                    // szTypeName = buffer.readInt16LE(offSet);
                    // offSet += 64;
                    //参数个数
                    let nParCount = 0;
        
                    nParCount = buffer.readInt32LE(offSet);
                    offSet += 4;
                    //解析参数
                    var mapNameToParInfo = [];
                    for (let i = 0; i < nParCount; i++){
                        let parInfo = {};
                        parInfo.sParNo =  buffer.readInt16LE(offSet);
                        offSet += 2;
                        parInfo.cParType =  buffer.readUInt8(offSet);
                        offSet += 1;
                        let bufferTest = DB.readString(buffer,offSet); 
                        parInfo.szParName = iconv.decode(bufferTest, 'UTF-8');
                        offSet += 24;
                        //mapNameToParInfo[parInfo.szParName] = {ParNo:parInfo.sParNo,ParType:parInfo.cParType,ParName:parInfo.szParName};
                        mapNameToParInfo.push({ParNo:parInfo.sParNo,ParType:parInfo.cParType,ParName:parInfo.szParName});
                    }
                    DB.tagType[sTagType] = {nameToParInfo:mapNameToParInfo,type:sTagType,typeName:dotName};
                } 
                let numberCount = 0;	//个数
                //读取节点长名个数
                numberCount = buffer.readInt32LE(offSet);
                offSet += 4;
                let shLen;
                //let nodeId;
                //读取长节点名
                let tsLongNodeName;
                for (let i = 0; i < numberCount; i++){
                    //读取节点名长度
                    shLen = buffer.readInt16LE(offSet);
                    offSet += 2;
                    //获取节点名
                    
                    let tsLongname = DB.readStringName(buffer,offSet,shLen*2); 
                    tsLongNodeName = iconv.decode(tsLongname, 'UTF-16');
                    offSet += (shLen * 2);
                    //读取节点ID
                    let nodeId = buffer.readInt32LE(offSet);
                    offSet += 4;
                    DB.mapIdToNodeName[nodeId] = {nodeName:tsLongNodeName};
                    DB.getLayer.push({layerId:nodeId,layerName:tsLongNodeName});
                }
                let szLongTagName = Buffer.alloc(512);
                //读取测点信息
                let tagId;
                let kind;
                //buffer.Read(&Count, sizeof(int));    
                let messageCount = buffer.readInt32LE(offSet);
                offSet += 4;
                for (let i = 0; i < messageCount; i++){
                    //读取测点名长度
                    shLen = buffer.readInt16LE(offSet);
                    offSet += 2;
                    //获取测点名
                    let tagName;
                    let name = DB.readStringName(buffer,offSet,shLen * 2); 
                    tagName = iconv.decode(name, 'UTF-16');
                    offSet += (shLen * 2);
        
                    //读取测点序号     
                    tagId = buffer.readUInt32LE(offSet);
                    offSet += 4;
                    //读取节点号
                    let nodeId = buffer.readInt32LE(offSet);
                    offSet += 4;
                    //读取点类型号
                    kind = buffer.readInt32LE(offSet);
                    offSet += 4;
                    let tagInfo = {};
                    tagInfo.szTagName = tagName;
                    tagInfo.tagId = tagId;
                    tagInfo.sKind = kind;
                    tagInfo.sNode = nodeId;
                    
                    //获取长节点名
                    let it = DB.mapIdToNodeName[nodeId];
                    let dwTagId = tagId;
                    if(it == null){
                        szLongTagName = tagName;
                    }
                    else{
                        szLongTagName = (it.nodeName + "\\" + tagName);
                    }
                    DB.arrData.push({tagInfo:nodeId,tagName:szLongTagName,tagId:tagInfo.tagId,tagShortName:tagName});
                    //mapIdToNodeName.push({szLongTagName:szLongTagName,tagId:tagId,kind:kind,nodeId:nodeId});
                    DB.mapNameToTag[szLongTagName] = {TagInfo:tagInfo,tagName:szLongTagName};
                    //listTagInfo.push({tagId:tagId,kind:kind,nodeId:nodeId});
                    //DB.listTagInfo[tagId] = tagInfo;
                    DB.listTagInfo.push({tagId:tagInfo.tagId,sKind:tagInfo.sKind,nodeId:tagInfo.sNode,tagName:szLongTagName});
                    //m_mapIdToTagInfo.push({dwTagId:dwTagId,tagId:tagId,kind:kind,nodeId:nodeId});tagId
                    DB.mapIdToTagInfo[tagId] = {TagName:szLongTagName};
                    DB.tagTypeName.push({tagName:szLongTagName,tagType:tagInfo.sKind});
                }
            };
        }, 

        //获取实时数据
        "getData":class{
            constructor(){
                this.arrName = [];
                this.packetType = 46;
            };
            serilize(arrTagPar){
                this.arrName = [];
                let lSize = (arrTagPar.length * 6) + 68;
                let compressBuf =  Buffer.alloc(lSize + 16);
                let offSet = 60 + 16;
                let dwLength = lSize -  64;
                compressBuf.writeUInt32LE(dwLength,offSet);
                offSet += 4;
                //压入请求数据个数
                compressBuf.writeInt32LE(arrTagPar.length,offSet);
                offSet += 4;
                //压入点ID和参数ID
                for (let i = 0; i < arrTagPar.length; i++){
                    //设置点ID 
                    let tagIds = 0;
                    let stockpile  = false;
                    if(arrTagPar[i].tagId != undefined){
                        if(DB.mapIdToTagInfo[arrTagPar[i].tagId] != undefined){
                            compressBuf.writeUInt32LE(arrTagPar[i].tagId,offSet);
                            stockpile = true;
                            tagIds = arrTagPar[i].tagId;
                        }
                    }
                    else if(DB.mapNameToTag[arrTagPar[i].tagName] != undefined){
                        let tagId = DB.mapNameToTag[arrTagPar[i].tagName].TagInfo.tagId;
                        compressBuf.writeUInt32LE(tagId,offSet);
                        stockpile = true;
                        tagIds = tagId;
                    }
                    if(stockpile == true){
                        offSet += 4;
                        let parId = arrTagPar[i].parId || 13;
                        compressBuf.writeInt16LE(parId,offSet);
                        offSet += 2;
                        this.arrName.push({tagName:arrTagPar[i].tagName,tagId:tagIds});
                    }

                }
                let netHead = Buffer.alloc(60);
                netHead.writeInt16LE(DB.nodeChange.NET_READ_DATA_REQ,24);
                //this.packetType = DB.nodeChange.NET_READ_DATA_REQ;
                netHead.writeInt16LE(0, 32);//short p2; //用户参数2
                netHead.writeInt16LE(5, 6);//short p3;//用户参数3
                netHead.writeUInt8(0, 5);
                netHead.writeInt32LE((lSize - 60), 26);
        
                netHead.copy(compressBuf,16);
                //DB.dataCopy.copy(compressBuf,16);
                let buff = DB.addPacketHeader(compressBuf);
                return buff;
            };
            unserilize(dataBuffer){
                if(dataBuffer.length <= 67){
                    return undefined;
                }
                let dbValue = [];
                let dotName = [];
                let dotData = [];
                let pDbVal = [];
                let lOffSet = 60 + 16;
                //原始数据长度
                let dwSourceSize = dataBuffer.readUInt32LE(lOffSet);
                lOffSet += 4;
                //准备数据
                // let bs = zlib.unzipSync(dataBuffer.slice(lOffSet));
                // let buffer = Buffer.from(bs);
                let buffer = zlib.unzipSync(dataBuffer.slice(lOffSet));
                //zlib.unzip(dataBuffer.slice(lOffSet),(err, buffer) => {
                    let lDataCount = 0;
                    let offer = 0;
                    lDataCount = buffer.readInt32LE(offer);
                    offer += 4;
                    let ucDbvt = 0;
                    let time = 0;
                    let shMilli = 0;
                    let uiQuility = 0;
                    let value = 0;
                    let dbVal = 0.0;
        
                    for (let i = 0; i < lDataCount; i++){
                        if(i >= this.arrName.length){
                            break;
                        }
                        //类型
                        ucDbvt = buffer.readUInt8(offer);
                        offer += 1;
                        //时间
                        time = buffer.readInt32LE(offer);
                        offer += 8;
                        //毫秒
                        shMilli = buffer.readInt16LE(offer);
                        offer += 2;
                        //质量戳
                        uiQuility = buffer.readUInt32LE(offer);
                        offer += 4;
                        //数据
                        switch (ucDbvt){
                        case DB.emDBValType.dbvt_int:
                        case DB.emDBValType.dbvt_enum:
        
                            value = buffer.readInt32LE(offer);
                            offer += 4;
                            dbValue[i] = {value:value,time:time,shMilli:shMilli,uiQuility:uiQuility};
                            break;
                        case DB.emDBValType.dbvt_real:
                            dbVal = buffer.readDoubleLE(offer);
                            let value = dbVal.toFixed(3);
                            offer += 8;
                            dbValue[i]={dbVal:value,time:time,shMilli:shMilli,uiQuility:uiQuility};
                            if(DB.mapNameToTag[this.arrName[i].tagName] != undefined){
                                dotData.push({tagName:DB.mapNameToTag[this.arrName[i].tagName].tagName,value:dbValue[i].dbVal,time:dbValue[i].time*1000+dbValue[i].shMilli,quality:dbValue[i].uiQuility});
                            }
                            else if(DB.mapIdToTagInfo[this.arrName[i].tagId] != undefined){
                                dotData.push({tagName:DB.mapIdToTagInfo[this.arrName[i].tagId].TagName,value:dbValue[i].dbVal,time:dbValue[i].time*1000+dbValue[i].shMilli,quality:dbValue[i].uiQuility});
                            }
                            break;
                        case DB.emDBValType.dbvt_string:
                            let sLen = 0; 
                            sLen = buffer.readInt16LE(offer);
                            offer += 2;
                            let tagName = "";
                            if(sLen > 0){
                                let bufferTest = DB.readStringDescribe(buffer,offer,sLen); 
                                tagName = iconv.decode(bufferTest, 'UTF-16');
                                offer += sLen*2;
                            }
                            //字符串
                            dbValue[i] = {describe:tagName,sLen:sLen,time:time,shMilli:shMilli,quality:uiQuility};
                            if(DB.mapNameToTag[this.arrName[i].tagName] != undefined){
                                dotData.push({retCode:true,tagName:DB.mapNameToTag[this.arrName[i].tagName].tagName,value:dbValue[i].describe,time:dbValue[i].time*1000+dbValue[i].shMilli,quality:dbValue[i].quality});
                            }
                            else if(DB.mapIdToTagInfo[this.arrName[i].tagId] != undefined){
                                dotData.push({retCode:true,tagName:DB.mapIdToTagInfo[this.arrName[i].tagId].TagName,value:dbValue[i].describe,time:dbValue[i].time*1000+dbValue[i].shMilli,quality:dbValue[i].quality});
                            }
                            break;
                        default:
                            break;
                        }
                    }
                    return {retCode:true,retData:dotData}
                //});
            };
        },
        //插入历史
        "insertHisData":class{
            constructor(){
                this.packetType = 88;
            };
            serilize(arrHisData){
                let leng = 1024*1024;
                let compressBuf = Buffer.alloc(leng);
                let ucLastType = 2;
                let offset = 0;
                compressBuf.writeInt32LE(arrHisData.datas.length,offset);
                offset += 4;
                //写入点和参数ID
                if(arrHisData.tagId != undefined){
                    if(DB.mapIdToTagInfo[arrHisData.tagId] != undefined){
                        compressBuf.writeUInt32LE(arrHisData.tagId,offset);
                    }
                }
                else if(DB.mapNameToTag[arrHisData.tagName] != undefined){
                    compressBuf.writeUInt32LE(DB.mapNameToTag[arrHisData.tagName].TagInfo.tagId,offset);
                }

                offset += 4;
                let parId = arrHisData.parId || 13;
                compressBuf.writeInt16LE(parId,offset);
                offset += 2;

                //写入数据类型
                compressBuf.writeUInt8(ucLastType,offset);
                offset += 1;
                //
                let sMilli = 0;
                let uiQuility = 192;
                //将循环写在内部，提高效率
                switch (ucLastType){
                case DB.emDBValType.dbvt_int:{
                        for (let i = 0; i < arrHisData.datas.length; i++){
                            //时间戳
                            let t1 = Date.parse(arrHisData.datas[i].time) / 1000;
                            compressBuf.writeInt64LE(t1,offset);
                            offset += 8;
                            compressBuf.writeInt16LE(sMilli,offset);
                            offset += 2;
                            //质量戳
                            compressBuf.writeUInt32LE(uiQuility,offset);
                            offset += 4;
                            //值  
                            compressBuf.writeInt32LE(arrHisData.datas[i].value,offset);
                            offset += 8;
                        }
                    }
                    break;
                case DB.emDBValType.dbvt_real:{
                        for (let i = 0; i < arrHisData.datas.length; i++){
                            //时间戳
                            let t1 = Date.parse(arrHisData.datas[i].time) / 1000;
                            compressBuf.writeInt32LE(t1,offset);
                            offset += 8;
                            compressBuf.writeInt16LE(sMilli,offset);
                            offset += 2;
                            //质量戳
                            compressBuf.writeUInt32LE(uiQuility,offset);
                            offset += 4;
                            //值
                            compressBuf.writeDoubleLE(arrHisData.datas[i].value,offset);
                            offset += 8;
                        }
                    }
                    break;
                }
                let lSize = 64 + leng + 128;
                let dataPackage = Buffer.alloc(lSize + 16);
                let lOffSet = 60 + 16;
                //let pNetHead = Buffer.alloc(60);
                dataPackage.writeInt16LE(DB.nodeChange.NET_INSERT_HIS_DATA_REQ, (24 + 16));
                //this.packetType = DB.nodeChange.NET_INSERT_HIS_DATA_REQ;
                dataPackage.writeInt16LE(0, (30 + 16));
        
                //*((DWORD *)(dataPackage+lOffSet)) = (DWORD)compressBuf.GetLength();
                dataPackage.writeInt32LE(leng,lOffSet);
                lOffSet += 4;
        
                //压缩
                let lBufSize = lSize - lOffSet;
                let buffer = zlib.deflateSync(compressBuf);
                //zlib.deflate(compressBuf,(err, buffer) => {
                    buffer.copy(dataPackage,lOffSet);
                    let bufSize = buffer.length; 
                    dataPackage.writeInt32LE((bufSize + 4), (26 + 16));
                    dataPackage.writeInt8(1, (5 + 16));
                    dataPackage.writeInt16LE(0, (32 + 16));//short p2; //用户参数2
                    dataPackage.writeInt16LE(3, (6 + 16));
                    //发送
                    let buff = DB.addPacketHeader(dataPackage);
                    return buff;
                //});
            };
            unserilize(dataBuffer){
                if(dataBuffer.length <= 76){
                    return undefined;
                }
                else{
                    let lRet = dataBuffer.readUInt32LE(60 + 16);
                    return {retCode:true,retData:lRet}
                }
                
            };
        },

        //获取历史
        "getHisData":class{
            constructor(){
                this.name = [];
                this.packetType = 54;
            };
            serilize(arrTagHis){
                this.name = [];
                //准备数据包
                let dataNumber = 130 + (arrTagHis.tagIds.length * 6) + 16;
                let  compressBuf = Buffer.alloc(dataNumber);
                //预留包头
                let offSet = 60 + 16;
                // //压入请求的数据开始和结束时间
                let t1 = Date.parse(arrTagHis.beginTime) / 1000;
                let t2 = Date.parse(arrTagHis.endTime) / 1000;
                compressBuf.writeInt32LE(t1,offSet);//time_t lBeginTime;//开始时间
                offSet += 10;
                compressBuf.writeInt32LE(t2,offSet);//time_t endTime;//结束时间
                offSet += 10;
                //压入数据个数
                compressBuf.writeInt32LE(arrTagHis.count,offSet);
                offSet += 4;
                //压入点个数
                let number = arrTagHis.tagIds.length;
                compressBuf.writeInt32LE(number,offSet);
                offSet += 4;
                //压入取值状态(当请求的时间点上没有数据时0，取前一个；1，取后一个)
                compressBuf.writeInt32LE(0,offSet);
                offSet += 4;
                
                for(let i = 0; i < arrTagHis.tagIds.length; i++){
                    let tmpName = "";
                    //压入点序号和参数序号
                    if(arrTagHis.tagIds[i].tagId != undefined){
                        if(DB.mapIdToTagInfo[arrTagHis.tagIds[i].tagId] != undefined){
                            compressBuf.writeUInt32LE(arrTagHis.tagIds[i].tagId,offSet);
                            tmpName = DB.mapIdToTagInfo[arrTagHis.tagIds[i].tagId].TagName;
                            this.name.push(tmpName);
                        }
                    }
                    else if(DB.mapNameToTag[arrTagHis.tagIds[i].tagName] != undefined){
                        compressBuf.writeUInt32LE(DB.mapNameToTag[arrTagHis.tagIds[i].tagName].TagInfo.tagId,offSet);
                        tmpName = DB.mapNameToTag[arrTagHis.tagIds[i].tagName].tagName;
                        this.name.push(tmpName);
                    }
                    offSet += 4;

                    let parId = arrTagHis.tagIds[i].parId || 13;
                    compressBuf.writeInt16LE(parId,offSet);
                    offSet += 2;
                    // this.name.push(tmpName);
                }
                //填充包头
                let netHead = Buffer.alloc(60);
                netHead.writeInt16LE(DB.nodeChange.NET_READ_HIS_REQ,24);
                //this.packetType = DB.nodeChange.NET_READ_HIS_REQ;
                netHead.writeInt16LE(0, 30);//short p1;//用户参数1
                //准备数据包编号
                netHead.writeInt16LE(0, 32);//short p2; //用户参数2
                netHead.writeInt16LE(4, 6);
                netHead.writeInt8(0, 5);
                netHead.writeInt32LE(offSet - 60, 26);

                netHead.copy(compressBuf,16);
                let buff = DB.addPacketHeader(compressBuf);
                return buff;
            };
            unserilize(dataBuffer){
                if(dataBuffer.length <= 76){
                    return undefined;
                }
                //先赋空值
                let lOffSet = 60 + 16;
                //数据的原始长度
                let dwSourceSize = dataBuffer.readUInt32LE(lOffSet);
                lOffSet += 4;
                let buffer = zlib.unzipSync(dataBuffer.slice(lOffSet));
                // zlib.unzip(dataPackage.slice(lOffSet),(err, buffer) => {
                    //值
                    let value; 
                    let dbVal;
                    let offSet = 0;
                    let hisData = [];
                    do {
                        //点个数
                        let lTagCount;
                        lTagCount = buffer.readInt32LE(offSet);
                        offSet += 4;
                        if (lTagCount <= 0){
                            break;
                        }
                        let hisDataResult = {};
                        //失败
                        let bFail = false;
                        for (let i=0; i < lTagCount; i++){
                            //读取点和参数序号
                            hisDataResult.tagId = buffer.readUInt32LE(offSet);
                            offSet += 4;
                            hisDataResult.nParId = buffer.readInt16LE(offSet);
                            offSet += 2;
                            //返回的数据个数
                            let lRetDataCount;
                            lRetDataCount = buffer.readInt32LE(offSet);
                            offSet += 4;
                            //填充数据个数,如果是负数那就发生错误了，取下一个
                            hisDataResult.lDataCount = lRetDataCount;
                            if (lRetDataCount <= 0){
                                //转换一下错误码
                                //hisDataResult.lDataCount = ParseErrorCode(lRetDataCount);
                                hisData[i] = {name:this.name[i],values:[]};
                                continue;
                            }
        
                            //分配数据缓冲区
                            let tagParVal = [];
                            //填充到历史数据结果中
                            hisDataResult.hisData = tagParVal;
                            //中间数据
                            let time, sMilli, uiQuality, ucDataType;
                            let data = [];
                            for (let j = 0; j < lRetDataCount; j++){
                                //读取时间戳和质量戳
                                time = buffer.readInt32LE(offSet);
                                offSet += 8;
                                sMilli = buffer.readInt16LE(offSet);
                                offSet += 2;
                                uiQuality = buffer.readUInt32LE(offSet);
                                offSet += 4;
                                ucDataType = buffer.readUInt8(offSet);
                                offSet += 1;
                                switch (ucDataType) {
                                case DB.emDBValType.dbvt_none:
                                    break;
                                case DB.emDBValType.dbvt_int:
                                case DB.emDBValType.dbvt_enum:{    
                                        value = buffer.readInt32LE(offSet);
                                        offSet += 4;
                                        tagParVal[j] = {value:value,time:time,sMilli:sMilli,uiQuality:uiQuality};
                                        break;
                                    }
                                case DB.emDBValType.dbvt_real:{
                                        dbVal = buffer.readDoubleLE(offSet);
                                        let value = dbVal.toFixed(3);
                                        offSet += 8;
                                        tagParVal[j] = {dbVal:value,time:time,sMilli:sMilli,uiQuality:uiQuality};
                                        data.push({data:tagParVal[j].dbVal,time:tagParVal[j].time * 1000 + sMilli,quality:tagParVal[j].uiQuality});
                                        hisData[i] = {name:this.name[i],values:data};
                                        break;
                                    }
                                default:
                                    break;
                                }
                            }
                        }
                    } while (0);
                    return {retCode:true,retData:hisData}
                //});
            };
        },

        //注册点  
        "subRealData":class{
            constructor(){
                this.register = [];
                this.packetType = 49;
            };
            //写的数据
            serilize(arrRegInfo){
                //console.log("arrRegInfo:",arrRegInfo);
                this.register = [];
                this.register = arrRegInfo;
                //准备注册数据
                let compressBuf = Buffer.alloc(4 + arrRegInfo.length * 10);
                //注册个数
                let lRegCount = 0;
                let offSet = 0;
                // compressBuf.Write(&lRegCount, sizeof(long));
                compressBuf.writeInt32LE(lRegCount,offSet);
                offSet += 4;
                //中间数据
                let lIdx = 0;
                for (let i = 0; i < arrRegInfo.length; i++){
                    let iKey = arrRegInfo[i].tagId;
                    iKey = (iKey<<16)|arrRegInfo[i].parId;

                    let it = DB.mapIdToRegTagPar[iKey];
                    if(it != null){
                        // //产生新的注册ID
                        // let dwRegTagParNo = getNewRegNo();
                        // //注册
                        // dwRegNo[i] = it->second->AddRegInfo(dwRegTagParNo, (pdwRegData==NULL)?0:pdwRegData[i]);
                        // mapRegNoToRegTagPar.insert(CMapRegNoToRegTagPar::value_type(dwRegTagParNo, it->second));
                        // //
                        // lRet++;
                    }
                    else{
                        //没找到就要去向DB注册
                        lIdx = i;
                        //compressBuf.Write(&lIdx, sizeof(long));
                        compressBuf.writeInt32LE(lIdx,offSet);
                        offSet +=4;
                        //compressBuf.Write(&tagId[i], sizeof(DWORD));
                        if(arrRegInfo[i].tagId != undefined){
                            if(DB.mapIdToTagInfo[arrRegInfo[i].tagId] != undefined){
                                compressBuf.writeUInt32LE(arrRegInfo[i].tagId,offSet);
                            }
                        }
                        else if(DB.mapNameToTag[arrRegInfo[i].tagName] != undefined){
                            compressBuf.writeUInt32LE(DB.mapNameToTag[arrRegInfo[i].tagName].TagInfo.tagId,offSet);
                        }
                        offSet += 4;
                        //compressBuf.Write(&parId[i], sizeof(short));
                        let parId = arrRegInfo[i].parId || 13;
                        compressBuf.writeInt16LE(parId,offSet);
                        offSet += 2;
                        lRegCount++;
                    }
                }
                if (lRegCount > 0){
                    //需要向DB注册
                    let offer = 0;
                    compressBuf.writeInt32LE(lRegCount,offer);
                    offer += 4; 
                    //准备数据包
                    let lSize = 264 + offSet;
                    let dataPackage = Buffer.alloc(lSize + 16);
                    if (dataPackage != null){
                        //let pNetHead = Buffer.alloc(60);
                        dataPackage.writeInt16LE(DB.nodeChange.NET_REG_TAGPAR_REQ,(24 + 16));
                        //this.packetType = DB.nodeChange.NET_REG_TAGPAR_REQ;
                        let lOffSet = 60 + 16;
                        //数据包原始长度
                        dataPackage.writeUInt32LE(offSet,lOffSet);
                        lOffSet += 4;
                        dataPackage.writeInt16LE(0, (30 + 16));
                        dataPackage.writeInt16LE(0, (32 + 16));
                        dataPackage.writeInt16LE(4, (6 + 16));
                        //缓冲区长度
                        let lBufSize = lSize - lOffSet;
                        //压缩
                        let buffer = zlib.deflateSync(compressBuf);
                        //zlib.deflate(compressBuf,(err, buffer) => {
                            buffer.copy(dataPackage,lOffSet);
                            let bufSize = buffer.length; 
                            dataPackage.writeInt8(1, (5 + 16));
                            dataPackage.writeInt32LE((bufSize + 4), (26 + 16));
                            //发送
                            let buff = DB.addPacketHeader(dataPackage);
                            return buff;
                        //});
                    }
                }
            };
            //读的数据
            unserilize(dataBuffer){
                if(dataBuffer.length <= 76){
                    return undefined;
                }
                let regTagPar = {};
                let regData = [];
                let pNetHead = Buffer.alloc(60);
                let lOffSet = 60 + 16;
                let dwSourceLen = dataBuffer.readUInt32LE(lOffSet);
                lOffSet += 4;
                let buffer = zlib.unzipSync(dataBuffer.slice(lOffSet));
                //zlib.unzip(dataPackage.slice(lOffSet),(err, buffer) => {
                    let lRet = 0;
                    let offser = 0;
                    //解析数据
                    //注册成功个数
                    let lRegCount = 0;
                    lRegCount = buffer.readInt32LE(offser);
                    offser += 4;
                    //索引
                    let lIdx = 0;
                    //注册结果
                    let bRegRet = false;
                    //数据类型
                    let cDataType;
                    //时间戳
                    let time;
                    let sMilli;
                    //数据
                    let dbVal; 
                    let value;	
                    //质量戳
                    let uiQuility;
                    let shStrLen = 0;
                    let dwRegTagParNo = 0;
                    let dotName = [];
                    DB.mapIdToRegTagPar = [];
                    for (let i = 0; i < lRegCount; i++){
                        lIdx = buffer.readInt32LE(offser);
                        offser += 4;
                        //读取数据类型
                
                        cDataType = buffer.readUInt8(offser);
                        offser += 1;
                        time = buffer.readInt32LE(offser);
                        offser += 8;
                        sMilli = buffer.readInt16LE(offser);
                        offser += 2;
                        uiQuility = buffer.readUInt32LE(offser);
                        offser += 4;
                        if(this.register[lIdx].tagId != undefined){
                            if(DB.mapIdToTagInfo[this.register[lIdx].tagId] != undefined){
                                regTagPar.tagId = this.register[lIdx].tagId;
                            }
                        }
                        else if(DB.mapNameToTag[this.register[lIdx].tagName] != undefined){
                            regTagPar.tagId = DB.mapNameToTag[this.register[lIdx].tagName].TagInfo.tagId;
                        }
                        let tagName = DB.mapIdToTagInfo[regTagPar.tagId].TagName;
                        if (regTagPar != null){
                            regTagPar.parId = this.register[lIdx].parId || 13;
                            //加入的Map中
                            DB.mapIdToRegTagPar.push({tagId:regTagPar.tagId,parId:regTagPar.parId,tagName:tagName});
                        }
                        
                        if (regTagPar != null){
                            //注册
                            dwRegTagParNo ++;
                            let dwRegNo = dwRegTagParNo;
                            //[lIdx] = dwRegNo;
                            DB.dwRegisterNo.push(dwRegNo);
                            //DB.mapRegNoToRegTagPar[dwRegNo] = regTagPar;

                            //附上初始值
                            switch (cDataType){
                            case DB.emDBValType.dbvt_int:
                            case DB.emDBValType.dbvt_enum:
                                value = buffer.readInt32LE(offser);
                                offser += 4;
                                regData[i] = {value:value,time:time,sMilli:sMilli,uiQuility:uiQuility};
                                break;
                            case DB.emDBValType.dbvt_real:
                                dbVal = buffer.readDoubleLE(offser);
                                offser += 8;
                                regData[i] = {dbVal:dbVal,time:time,sMilli:sMilli,uiQuility:uiQuility};
                                break;
                            case DB.emDBValType.dbvt_string:{
                                    //字符串的长度
                                    shStrLen = buffer.readInt16LE(offser);
                                    offser += 2;
                                    //字符串
                                    let tagName = iconv.decode(bufferTest, 'UTF-16');
                                    offser += 4;
                                    regData[i] = {tagName:tagName,shStrLen:shStrLen,time:time,sMilli:sMilli,uiQuility:uiQuility};
                                    dotName.push(tagName);
                                }
                                break;
                            default:
                                break;
                            }
                            //注册成功计数
                            DB.mapRegNoToRegTagPar.push({regNo:dwRegNo,regTagPar:DB.mapIdToRegTagPar[i],value:regData[i].dbVal});
                            lRet++;
                        }
                        else
                            break;
                    }
                    DB.bUpdateSwitch = 1;
                    //console.log("subret:",JSON.stringify(DB.mapRegNoToRegTagPar));
                    return {retCode:true,retData:DB.mapRegNoToRegTagPar}
                //});
            };
        },

        //历史追忆 
        "getRawHisData":class{
            constructor(){
                this.packetType = 56;
            };
            //写的数据
            serilize(arrRawData){
                //组织数据包
                let dataPackage = Buffer.alloc(256 + 16);
                dataPackage.writeInt16LE(DB.nodeChange.NET_READ_RAWHIS_REQ,(24 + 16));
                //this.packetType = DB.nodeChange.NET_READ_RAWHIS_REQ;
                dataPackage.writeInt8(0, (5 + 16));
                dataPackage.writeInt32LE(26,(26 + 16));
                dataPackage.writeInt16LE(0,(30 + 16));
                dataPackage.writeInt16LE(0,(32 + 16));
                dataPackage.writeInt16LE(3,(6 + 16));
                //填充请求的数据
                let lOffSet = 60 + 16;
                //点编号
                if(arrRawData.tagId != undefined){
                    if(DB.mapIdToTagInfo[arrRawData.tagId] != undefined){
                        dataPackage.writeUInt32LE(arrRawData.tagId,lOffSet);
                    }
                }
                else if(DB.mapNameToTag[arrRawData.tagName] != undefined){
                    dataPackage.writeUInt32LE(DB.mapNameToTag[arrRawData.tagName].TagInfo.tagId,lOffSet);
                }
                lOffSet += 4;
                //参数序号
                let parId = arrRawData.parId || 13;
                dataPackage.writeInt16LE(parId,lOffSet);
                lOffSet += 2;
                //请求开始时间结束时间
                let t1 = Date.parse(arrRawData.beginTime) / 1000;
                let t2 = Date.parse(arrRawData.endTime) / 1000;
                dataPackage.writeInt32LE(t1,lOffSet);//time_t lBeginTime;//开始时间
                lOffSet += 10;
                dataPackage.writeInt32LE(t2,lOffSet);//time_t lSpan;//时间长度
                lOffSet += 10;
                //发送失败的话就移除
                let buff = DB.addPacketHeader(dataPackage);
                return buff;
            };
            //读的数据
            unserilize(dataBuffer){
                //先置空指针
                if(dataBuffer.length <= 76){
                    return undefined;
                }
                let lOffSet = 60 + 16;
                let dwSourceLen = dataBuffer.readUInt32LE(lOffSet);
                lOffSet += 4;
                //解压
                let buffer = zlib.unzipSync(dataBuffer.slice(lOffSet));
                //zlib.unzip(dataPackage.slice(lOffSet),(err, buffer) => {
                    let tagId; 
                    let sParNo; 
                    let bMoreData = false;
                    let offSet = 0;
                    let hidPalimnesis = [];
                    //读取请求时的点和参数ID
                    tagId = buffer.readUInt32LE(offSet);
                    offSet += 4;
                    sParNo = buffer.readInt16LE(offSet);
                    offSet += 2;
                    //是否超过1W条数据
                    bMoreData = buffer.readInt32LE(offSet);
                    offSet += 4;
                    //读取返回的数据个数
                    let lCount = 0;
                    lCount = buffer.readInt32LE(offSet);
                    offSet += 4;
                    if (lCount > 0){
                        let hisResult = [];
                        let rawHisData = [];
                        hisResult.tagId = tagId;
                        hisResult.nParId = sParNo;
                        hisResult.lDataCount = lCount;
                        hisResult.hisData = rawHisData;
                        //中间数据
                        let time,sMilli,uiQuality;
                        //数据
                        let value = 0; 
                        let dbVal = 0.0;
                        let shStrLen = 0;
                        //数据类型
                        let ucDataType;
                        for (let i = 0; i < lCount; i++){
                            //读取时间戳和质量戳
                            time = buffer.readInt32LE(offSet);
                            offSet += 8;
                            sMilli = buffer.readInt16LE(offSet);
                            offSet += 2;
                            uiQuality = buffer.readUInt32LE(offSet);
                            offSet += 4;
                            ucDataType = buffer.readUInt8(offSet);
                            offSet += 1;

                            switch (ucDataType){
                            case DB.emDBValType.dbvt_int:
                            case DB.emDBValType.dbvt_enum:{
                                    value = buffer.readInt32LE(offSet);
                                    offSet += 4;
                                    rawHisData[i] = {value:value,time:time,sMilli:sMilli,uiQuality:uiQuality};
                                    break;
                                }
                            case DB.emDBValType.dbvt_real:{			
                                    dbVal = buffer.readDoubleLE(offSet);
                                    offSet += 8;
                                    rawHisData[i] = {dbVal:dbVal,time:time,sMilli:sMilli,uiQuality:uiQuality};
                                    hidPalimnesis[i] = {data:rawHisData[i].dbVal};
                                    //hidPalimnesis.push(rawHisData[i].dbVal);
                                    break;
                                }
                            case DB.emDBValType.dbvt_string: {
                                    //读取字符传的长度
                                    shStrLen = buffer.readInt16LE(offSet);
                                    offSet += 2;
                                    //字符串
                                    let bufferTest = DB.readString(buffer,offSet); 
                                    let pszVal = iconv.decode(bufferTest, 'utf-8');
                                    offSet += 4;
                                    rawHisData[i] = {val:pszVal, strLen:shStrLen, time:time, milli:sMilli, quality:uiQuality};
                                    break;
                                }
                            default:
                                break;
                            }
                        }
                        //console.log(hidPalimnesis);
                    }
                    return {retCode:true,retData:hidPalimnesis}
                //});
            };            
        },

        //获取全部测点id  
        "getTagId":class{
            constructor(){
                this.packetType = 60;
            };
            //写的数据
            serilize(){
                let dataPackage = Buffer.alloc(256 + 16);
                dataPackage.writeInt16LE(DB.nodeChange.NET_TAGINFO_REQ,(24 + 16));
                //this.packetType = DB.nodeChange.NET_TAGINFO_REQ;
                dataPackage.writeInt8(0, (5 + 16));
                dataPackage.writeInt32LE(8,(26 + 16));
                dataPackage.writeInt16LE(0,(32 + 16));
                dataPackage.writeInt16LE(3,(6 + 16));
                //配上节点-点类型和获取点名的类型(长点名还是短点名)
                let lOffSet = 60 + 16;
                //节点
                dataPackage.writeInt32LE(-1,lOffSet);
                lOffSet += 4;
                //点类型
                dataPackage.writeInt32LE(-1,lOffSet);
                lOffSet += 4;

                //发送
                let buff = DB.addPacketHeader(dataPackage);
                return buff;
            };
            //读的数据
            unserilize(dataBuffer){
                if(dataBuffer.length <= 76){
                    return undefined;
                }
                let tagId = 0;
                let arrTagId = [];
                let offSet = 60 + 16;
                let lCount = dataBuffer.readInt32LE(offSet);
                offSet += 4;
                for(let i = 0; i < lCount; i++){
                    tagId = dataBuffer.readInt32LE(offSet);
                    offSet += 4;
                    arrTagId[i] = {tagId:tagId};
                }
                return {retCode:true,retData:arrTagId}
            };
        },

        //获取全部的报警信息 
        "getAlarmByArea":class{
            constructor(){
                this.tierId = [];
                this.packetType = 66;
            };
            //写的数据
            serilize(stratumId){
                this.tierId = [];
                this.tierId = stratumId;
                let dataPackage = Buffer.alloc(256 + 16);
                dataPackage.writeInt16LE(DB.nodeChange.NET_ALL_ALMINFO_REQ,(24 + 16));
                //this.packetType = DB.nodeChange.NET_ALL_ALMINFO_REQ;
                dataPackage.writeInt8(0, (5 + 16));
                dataPackage.writeInt32LE(0,(26 + 16));
                dataPackage.writeInt16LE(0,(30 + 16));
                dataPackage.writeInt16LE(0,(32 + 16));
                dataPackage.writeInt16LE(3,(6 + 16));

                //发送
                let buff = DB.addPacketHeader(dataPackage);
                return buff;
            };
            //读的数据
            unserilize(dataBuffer){
                if(dataBuffer.length <= 76){
                    return undefined;
                }
                let tagName = [];
                for(let j = 0; j < this.tierId.length; j++){
                    for(let i = 0; i < DB.arrData.length; i++){
                        if(this.tierId[j] ==  DB.arrData[i].tagInfo){
                            tagName.push({tagId:DB.arrData[i].tagId,tagName:DB.arrData[i].tagName});
                        }
                    }
                }
                //默认赋空
                let lOffSet = 60 + 16;
                //报警信息数组
                let  almLogInfo = [];
                let dwUnCompressSize = dataBuffer.readUInt32LE(lOffSet);
                lOffSet += 4;
                if (dwUnCompressSize > 0){
                    let buffer = zlib.unzipSync(dataBuffer.slice(lOffSet));
                    //zlib.unzip(dataPackage.slice(lOffSet),(err, buffer) => {
                        let offer = 0;
                        let almCount = buffer.readInt32LE(offer);
                        offer += 4;
                        let commentCount = buffer.readInt32LE(offer);
                        offer += 4;
                        let lPos = buffer.readInt32LE(offer);
                        offer = lPos;
                        let nLoop = 0;
                        if(almCount >= commentCount){
                            nLoop = almCount;
                        }
                        else {
                            nLoop = commentCount;
                        }
                        for (let i = 0; i < nLoop; i++){
                            let almLogInfoEx = {};
                            //almLogInfoEx.almId = buffer.readUIntLE(offer,8);
                            offer += 8;
                            almLogInfoEx.tagId = buffer.readUIntLE(offer,8) & 0xffffffff;
                            almLogInfoEx.iackStatu = buffer.readUIntLE(offer + 4,2);
                            almLogInfoEx.almType = buffer.readUIntLE(offer + 6,2);
                            offer += 8;
                            switch (almLogInfoEx.almType) {
                                case 0:
                                {
                                    almLogInfoEx.almType = "低低报";
                                    break;
                                }
                                case 1:
                                {
                                    almLogInfoEx.almType = "低5报";
                                    break;
                                }
                                case 2:
                                {
                                    almLogInfoEx.almType = "低4报";
                                    break;
                                }
                                case 3:
                                {
                                    almLogInfoEx.almType = "低3报";
                                    break;
                                }
                                case 4:
                                {
                                    almLogInfoEx.almType = "低低报";
                                    break;
                                }
                                case 5:
                                {
                                    almLogInfoEx.almType = "低报";
                                    break;
                                }
                                case 6:
                                {
                                    almLogInfoEx.almType = "高报";
                                    break;
                                }
                                case 7:
                                {
                                    almLogInfoEx.almType = "高高报";
                                    break;
                                }
                                case 8:
                                {
                                    almLogInfoEx.almType = "高3报";
                                    break;
                                }
                                case 9:
                                {
                                    almLogInfoEx.almType = "高4报";
                                    break;
                                }
                                case 10:
                                  {
                                    almLogInfoEx.almType = "高5报";
                                    break;
                                  }
                                case 11:
                                  {
                                    almLogInfoEx.almType = "偏差报警";//IDS_ALM_DEV;
                                    break;
                                  }
                                case 12:
                                  {
                                    almLogInfoEx.almType = "变化率报警";//IDS_ALM_RATE;
                                    break;
                                  }
                                case 13:
                                case 14:
                                case 15:
                                  {
                                    almLogInfoEx.almType = "数字量报警";//IDS_ALM_DIO;
                                    break;
                                  }
                                case 16:
                                  {
                                    almLogInfoEx.almType = "IO设备报警";//IDS_ALM_IO;
                                    break;
                                  }
                            }
                            almLogInfoEx.almPrio = buffer.readUInt32LE(offer);
                            offer += 4;
                            //almLogInfoEx.almGroup = buffer.readUInt32LE(offer);
                            offer += 4;
                            //almLogInfoEx.dwParNo = buffer.readUInt16LE(offer);
                            offer += 2;
                            almLogInfoEx.iUnit = buffer.readUInt16LE(offer);
                            offer += 2;
                            //拼接毫秒
                            //almLogInfoEx.almMilli = buffer.readUInt32LE(offer)& 0x3ff;
                            //almLogInfoEx.dwEndMilli = buffer.readUInt32LE(offer) >> 10 & 0x3ff;
                            //almLogInfoEx.iackMilli = buffer.readUInt32LE(offer)>> 10 & 0xfff;
                            let almMilli = buffer.readUInt32LE(offer)& 0x3ff;
                            let iackMilli = buffer.readUInt32LE(offer)>> 10 & 0xfff;
                            
                            offer += 4;
                            //拼接毫秒后的时间
                            //almLogInfoEx.almTime = buffer.readInt32LE(offer);
                            let almTime = buffer.readInt32LE(offer);
                            almLogInfoEx.almTime = almTime*1000+almMilli;
                            offer += 8;
                            //almLogInfoEx.endTime = buffer.readInt32LE(offer);
                            offer += 8;

                            //拼接毫秒后的时间
                            //almLogInfoEx.iackTime = buffer.readInt32LE(offer);
                            let iackTime = buffer.readInt32LE(offer);
                            almLogInfoEx.iackTime = iackTime*1000+iackMilli;
                            offer += 8;
                            //almLogInfoEx.dbStartValue = buffer.readDoubleLE(offer);
                            offer += 8;
                            //almLogInfoEx.dbEndValue = buffer.readDoubleLE(offer);
                            offer += 8;
                            //almLogInfoEx.dbAckValue = buffer.readDoubleLE(offer);
                            offer += 8;
                            //almLogInfoEx.usernLen = buffer.readInt32LE(offer);
                            let len = buffer.readInt32LE(offer);
                            offer += 4;
                            let offSet = buffer.readInt32LE(offer);
                            if(len > 0){
                                let bufferTest = DB.almLogReadString(buffer,offSet,len*2); 
                                almLogInfoEx.ackUser = iconv.decode(bufferTest, 'UTF-16');
                            }
                            offer += 4;
                            len = buffer.readInt32LE(offer);
                            offer += 4;
                            //len = almLogInfoEx.almContentLen;
                            offSet = buffer.readInt32LE(offer);
                            if(len > 0){
                                let bufferTest = DB.almLogReadString(buffer,offSet,len*2); 
                                almLogInfoEx.almInfo = iconv.decode(bufferTest,'UTF-16');
                            }
                            if(i < commentCount){
                                offSet += 46;
                                let bufferTest = DB.almLogReadCommentString(buffer,offSet); 
                                almLogInfoEx.dsCommentString = iconv.decode(bufferTest,'UTF-16');
                            }
                            offer += 4;
                            len = buffer.readInt32LE(offer);
                            offer += 4;
                            //len = almLogInfoEx.descLen;
                            offSet = buffer.readInt32LE(offer);
                            if(len > 0){
                                let bufferTest = DB.almDecsReadString(buffer,offSet,len); 
                                almLogInfoEx.almDecs = iconv.decode(bufferTest,'UTF-16');
                            }
                            offer += 4;
                            //almLogInfoEx.almRemarkLen = buffer.readInt32LE(offer);
                            offer += 4;
                            //len = almLogInfoEx.almRemarkLen;
                            //offSet = buffer.readInt32LE(offer);
                            //if(len > 0){
                                //let bufferTest = DB.almLogReadString(buffer,offSet,len*2); 
                                //almLogInfoEx.almRemarkString = iconv.decode(bufferTest,'UTF-16');
                            //}
                            offer += 4;
                            for(let j = 0; j < tagName.length; j++){
                                if(tagName[j].tagId == almLogInfoEx.tagId){
                                    almLogInfoEx.tagName = tagName[j].tagName;
                                    almLogInfo.push(almLogInfoEx);
                                }
                            }
                        }
                    //});
                }
                return {retCode:true,retData:almLogInfo}
            };
        },

        //查询历史报警 
        "getHisAlarmInfo":class{
            constructor(){
                this.packetType = 76;
            };
            //写的数据
            serilize(jsonAlmInfoReq){
                let lSize = 68 + ((47 + 1) * 2);
                let dataPackage = Buffer.alloc(lSize + 16);
                dataPackage.writeInt16LE(DB.nodeChange.NET_QUERY_HIS_ALM_REQ,(24 + 16));
                //this.packetType = DB.nodeChange.NET_QUERY_HIS_ALM_REQ;
                dataPackage.writeInt8(0, (5 + 16));
                dataPackage.writeInt32LE(lSize - 60,(26 + 16));
                dataPackage.writeInt16LE(0,(30 + 16));
                dataPackage.writeInt16LE(0,(32 + 16));
                dataPackage.writeInt16LE(3,(6 + 16));

                let lOffSet = 60 + 16;
                //已经获取的个数
                dataPackage.writeInt32LE(jsonAlmInfoReq.haveCount,lOffSet);
                lOffSet += 4;
                //当前要获取的个数
                dataPackage.writeInt32LE(jsonAlmInfoReq.maxCount,lOffSet);
                lOffSet += 4;
                //查询条件
                let t1 = Date.parse(jsonAlmInfoReq.beginTime) / 1000;
                let t2 = Date.parse(jsonAlmInfoReq.endTime) / 1000;
                
                let string = "StartTime>="+ t1 + " AND StartTime<=" + t2;
                for(let i = 0; i < string.length; i++){ 
                    dataPackage.writeIntLE(( "00" + string.charCodeAt(i)).slice(-4),lOffSet,);
                    lOffSet += 2;
                }  
                //发送
                let buff = DB.addPacketHeader(dataPackage);
                return buff;
            };
            //读的数据
            unserilize(dataBuffer){
                if(dataBuffer.length <= 76){
                    return undefined;
                }
                let hisAlmLogInfo = [];
                let lOffSet = 60 + 16;
                //报警个数
                let  lAlmCount = dataBuffer.readInt32LE(lOffSet);
                lOffSet += 4;
                let offer = 0;
                if (lAlmCount > 0){
                    let dwUnCompressSize = dataBuffer.readUInt32LE(lOffSet);
                    lOffSet += 4;
                    let buffer = zlib.unzipSync(dataBuffer.slice(lOffSet));
                    //zlib.unzip(dataPackage.slice(lOffSet),(err, buffer) => {
                        for (let i = 0; i < lAlmCount; i++){
                            let almLogInfoEx = {};
                            almLogInfoEx.almId = buffer.readUIntLE(offer,8);
                            offer += 8;
                            almLogInfoEx.tagId = buffer.readUIntLE(offer,8) & 0xffffffff;


                            //almLogInfoEx.dwAlmStatus = buffer.readUIntLE(offer + 4,2);
                            //almLogInfoEx.dwAlmType = buffer.readUIntLE(offer + 6,2);


                            offer += 8;
                            almLogInfoEx.almPrio = buffer.readUInt32LE(offer);
                            offer += 4;


                            //almLogInfoEx.dwAlmGroup = buffer.readUInt32LE(offer);
                            offer += 4;
                            //almLogInfoEx.dwParNo = buffer.readUInt16LE(offer);
                            offer += 2;
                            //almLogInfoEx.dwNodeId = buffer.readUInt16LE(offer);
                            offer += 2;
                            //时间拼接
                            //almLogInfoEx.dwStartMilli = buffer.readUInt32LE(offer)& 0x3ff;
                            //almLogInfoEx.dwEndMilli = buffer.readUInt32LE(offer) >> 10 & 0x3ff;
                            //almLogInfoEx.dwAckMilli = buffer.readUInt32LE(offer)>> 10 & 0xfff;
                            let dwStartMilli = buffer.readUInt32LE(offer)& 0x3ff;
                            let dwEndMilli = buffer.readUInt32LE(offer) >> 10 & 0x3ff;
                            let dwAckMilli = buffer.readUInt32LE(offer)>> 10 & 0xfff;
                            offer += 4;
                            //almLogInfoEx.startTime = buffer.readInt32LE(offer);
                            let startTime = buffer.readInt32LE(offer);
                            almLogInfoEx.startTime = startTime*1000+dwStartMilli;
                            offer += 8;
                            //almLogInfoEx.endTime = buffer.readInt32LE(offer);
                            let endTime = buffer.readInt32LE(offer);
                            almLogInfoEx.endTime = endTime*1000+dwEndMilli;
                            offer += 8;
                            //almLogInfoEx.ackTime = buffer.readInt32LE(offer);
                            let ackTime = buffer.readInt32LE(offer);
                            almLogInfoEx.ackTime = ackTime*1000+dwAckMilli;
                            offer += 8;


                            //almLogInfoEx.dbStartValue = buffer.readDoubleLE(offer);
                            offer += 8;
                            //almLogInfoEx.dbEndValue = buffer.readDoubleLE(offer);
                            offer += 8;
                            //almLogInfoEx.dbAckValue = buffer.readDoubleLE(offer);
                            offer += 8;
                            //almLogInfoEx.usernLen = buffer.readInt32LE(offer);
                            offer += 4;
                            let len;
                            let offSet;
                            // len = almLogInfoEx.usernLen;
                            // offSet = buffer.readInt32LE(offer);
                            // if(len > 0){
                            //     almLog = true;
                            //     let bufferTest = DB.almLogReadString(buffer,offSet,len*2); 
                            //     almLogInfoEx.usernString = iconv.decode(bufferTest, 'UTF-16');
                            // }

                            offer += 4;
                            len = buffer.readInt32LE(offer);
                            offer += 4;
                            //len = almContentLen;
                            offSet = buffer.readInt32LE(offer);
                            if(len > 0){
                                let bufferTest = DB.almLogReadString(buffer,offSet,len*2); 
                                almLogInfoEx.almInfo = iconv.decode(bufferTest,'UTF-16');
                            }
                            offer += 4;
                            //almLogInfoEx.descLen = buffer.readInt32LE(offer);
                            len = buffer.readInt32LE(offer);
                            offer += 4;
                            //len = almLogInfoEx.descLen;
                            offSet = buffer.readInt32LE(offer);
                            if(len > 0){
                                let bufferTest = DB.almDecsReadString(buffer,offSet,len); 
                                almLogInfoEx.almDecs = iconv.decode(bufferTest,'UTF-16');
                            }
                            offer += 4;
                            //almLogInfoEx.almRemarkLen = buffer.readInt32LE(offer);
                            offer += 4;
                            //len = almLogInfoEx.almRemarkLen;
                            //offSet = buffer.readInt32LE(offer);
                            // if(len > 0){
                            //     let bufferTest = DB.almLogReadString(buffer,offSet,len*2); 
                            //     almLogInfoEx.almRemarkString = iconv.decode(bufferTest,'UTF-16');
                            // }
                            offer += 4;
                            hisAlmLogInfo.push(almLogInfoEx);
                        }
                        return {retCode:true,retData:hisAlmLogInfo}
                    //});
                }
            };
        },

        //查询历史报警评论
        "getHisAlmComment":class{
            constructor(){
                this.packetType = 78;
            };
            //写的数据
            serilize(arrAlmCommentReq){
                let lSize = 64 + (arrAlmCommentReq.length * 8);
                let dataPackage = Buffer.alloc(lSize + 16);
                dataPackage.writeInt16LE(DB.nodeChange.NET_QUERY_HIS_ALM_COMMENT_REQ,(24 + 16));
                //this.packetType = DB.nodeChange.NET_QUERY_HIS_ALM_COMMENT_REQ;
                dataPackage.writeInt8(0,(5 + 16));
                dataPackage.writeInt16LE(0,(30 + 16));
                dataPackage.writeInt32LE(lSize - 60,(26 + 16));
                //准备数据包编号
                dataPackage.writeInt16LE(0,(32 + 16));
                dataPackage.writeInt16LE(3,(6 + 16));
                let lOffSet = 60 + 16;
                for(let i = 0;i < arrAlmCommentReq.length; i++){
                    dataPackage.writeInt32LE(1,lOffSet);
                    lOffSet += 4;
                    //复制报警编号
                    //dataPackage.writeInt32LE(arrAlmCommentReq.alarmId,lOffSet,true);
                    dataPackage.writeUIntLE(arrAlmCommentReq[i].alarmId,lOffSet,8);
                    lOffSet += 8;
                }
                //发送
                let buff = DB.addPacketHeader(dataPackage);
                return buff;
            };
            //读的数据
            unserilize(dataBuffer){
                if(dataBuffer.length <= 76){
                    return undefined;
                }
                let almComment = [];
                let lOffSet = 60 + 16;
                //个数
                let lCount = dataBuffer.readInt32LE(lOffSet);
                lOffSet += 4;
                if (lCount > 0){
                    //数据原始长度
                    let dwSourceLen = dataBuffer.readUInt32LE(lOffSet);
                    lOffSet += 4;
                    let buffer = zlib.unzipSync(dataBuffer.slice(lOffSet));
                    //zlib.unzip(dataPackage.slice(lOffSet),(err, buffer) => {
                        let offer = 0;
                        for (let i = 0; i < lCount; i++){
                            let almLogInfoEx = {};
                            offer += 32;
                            almLogInfoEx.commentLen = buffer.readInt32LE(offer);
                            offer += 4;
                            let len = almLogInfoEx.commentLen;
                            let offSet = buffer.readInt32LE(offer);
                            if(len > 0){
                                let bufferTest = DB.reviewReadString(buffer,offSet); 
                                almLogInfoEx.commentString = iconv.decode(bufferTest,'UTF-16');
                            }
                            offer += 8;
                            almComment.push(almLogInfoEx);
                        }
                        return {retCode:true,retData:almComment};
                    //});
                }
            };
        },

        //获取全部历史点参数 
        "getAllHisTagPar":class{
            constructor(){
                this.packetType = 64;
            };
            //写的数据
            serilize(){
                let NetHead = Buffer.alloc(60 + 16);
                NetHead.writeInt16LE(DB.nodeChange.NET_HISTAGPAR_REQ,(24 + 16));
                //this.packetType = DB.nodeChange.NET_HISTAGPAR_REQ;
                NetHead.writeInt8(0,(5 + 16));
                NetHead.writeInt16LE(0,(30 + 16));
                NetHead.writeInt32LE(0,(26 + 16));
                //准备数据包编号
                NetHead.writeInt16LE(0,(32 + 16));
                NetHead.writeInt16LE(3,(6 + 16));
                //发送
                let buff = DB.addPacketHeader(NetHead);
                return buff;
            };
            //读的数据
            unserilize(dataBuffer){
                if(dataBuffer.length <= 76){
                    return undefined;
                }
                let tagId = [];
                let parId = [];
                let tagParID = [];
                if (dataBuffer != null){
                    let offser = 60 + 16;
                    let lCount;
                    lCount = dataBuffer.readInt32LE(offser);
                    offser += 4;
                    if(lCount > 0){
                        let tagIdBuf;
                        let parIdBuf;
                        for (let i = 0; i < lCount; i++){
                            tagIdBuf = dataBuffer.readUInt32LE(offser);
                            offser += 4;
                            //tagId.push(tagIdBuf);
                            parIdBuf = dataBuffer.readInt16LE(offser);
                            offser += 2;
                            //parId.push(parIdBuf);
                            tagParID.push({tagId:tagIdBuf,parId:parIdBuf});
                        }
                        return {retCode:true,retData:tagParID}
                    }
                }     
            };
        },    
        
        //获取层节点信息 
        "getDBNodeInfo":class{
            constructor(){
                this.packetType = 92;
            };
            //写的数据
            serilize(){
                let netHead = Buffer.alloc(256 + 16);
                netHead.writeInt16LE(DB.nodeChange.NET_READ_NODEXML_REQ,(24 + 16));
                //this.packetType = DB.nodeChange.NET_READ_NODEXML_REQ;
                netHead.writeInt8(0, (5 + 16));
                netHead.writeInt16LE(0, (30 + 16));
                netHead.writeInt32LE(0, (26 + 16));
                //生成一个数据包号
                //DWORD dwdataPackageNo = GetNewdataPackageNo();
                netHead.writeInt16LE(0, (32 + 16));//short p2; //用户参数2
                netHead.writeInt16LE(3, (6 + 16));
                //设置数据包编号
                //发送
                let buff = DB.addPacketHeader(netHead);
                return buff;
            };
            //读的数据
            unserilize(dataBuffer){
                if(dataBuffer.length <= 76){
                    return undefined;
                }
                let pszNodeXml = [];
                //let nWStrLen = dataPackage.readInt32LE(26)/2;
                let lent = dataBuffer.readInt32LE(26 + 16);
                pszNodeXml = Buffer.alloc(lent + 2);
                if (pszNodeXml != null){
                    let bufferTest = DB.readStringXml(dataBuffer,60 + 16); 
                    pszNodeXml = iconv.decode(bufferTest, 'UTF-16');
                    DB.nodeInfo = pszNodeXml;
                    return {retCode:true,retData:DB.nodeInfo}
                }
            };
        },
        
        //报警确认 
        "getAlarmAck":class{
            constructor(){
                this.packetType = 74;
            };
            //写的数据
            serilize(arrAlmLogInfo){
                //计算空间大小
                let lCalcSize = 60;
                lCalcSize += (16 + arrAlmLogInfo.length * 8);
                let lOffSet = 60 + 16;
                for(let j = 0; j <arrAlmLogInfo.length; j++){
                    lCalcSize += arrAlmLogInfo[j].user.length * 4;
                }
                
                //准备空间
                let compressBuf = Buffer.alloc(lCalcSize + 16);
                for(let i = 0; i <arrAlmLogInfo.length; i++){
                    //写入报警确认时间
                    let t1 = Date.parse(arrAlmLogInfo[i].ackTime) / 1000;
                    compressBuf.writeInt32LE(t1,lOffSet);
                    lOffSet += 10;
                    //写入确认人长度
                    compressBuf.writeInt16LE(arrAlmLogInfo[i].user.length, lOffSet);
                    lOffSet += 2;
                    if (arrAlmLogInfo[i].user.length > 0){
                        compressBuf.writeInt16LE(arrAlmLogInfo[i].user, lOffSet);
                        lOffSet += arrAlmLogInfo[i].user.length * 2;
                    }
                    //写入报警个数
                    compressBuf.writeInt32LE(1, lOffSet);
                    lOffSet += 4;
                    //写入报警编号
                    compressBuf.writeUIntLE(arrAlmLogInfo[i].alarmId, lOffSet, 8);
                }


                //组织包头
                compressBuf.writeInt16LE(DB.nodeChange.NET_ACK_ALM_REQ,24 + 16);
                //this.packetType = DB.nodeChange.NET_ACK_ALM_REQ;
                compressBuf.writeInt8(0, 5 + 16);
                compressBuf.writeInt32LE(lCalcSize - 60,26 + 16);
                compressBuf.writeInt16LE(0,30 + 16);
                //发送
                let buff = DB.addPacketHeader(compressBuf);
                return buff;
            };
            unserilize(){
                return {retCode:true};
            };
        },       
        
        //增加报警评论 
        "addRealTimeAlmComment":class{
            constructor(){
                this.packetType = 75;
            };
            //写的数据
            serilize(arrAlmComment){
                //计算空间大小
                let lSize = 16 + (arrAlmComment.length * 10);
                for(let i = 0; i < arrAlmComment.length; i++){
                    if (arrAlmComment[i].user.length > 0)
                        lSize += arrAlmComment[i].user.length * 4;

                    if (arrAlmComment[i].describe.length > 0)
                        lSize += arrAlmComment[i].describe.length * 4;
                }

                //准备空间
                let compressBuf = Buffer.alloc(lSize);
                let offSet = 0;
                //写入评论时间
                for (let j = 0; j < arrAlmComment.length; j++){
                    let t1 = Date.parse(arrAlmComment[j].time) / 1000;
                    compressBuf.writeInt32LE(t1,offSet);
                    offSet += 8;
                    //评论用户 
                    compressBuf.writeInt16LE(arrAlmComment[j].user.length, offSet);
                    offSet += 2;
                    if (arrAlmComment[j].user.length > 0){
                        compressBuf.writeInt16LE(arrAlmComment[j].user, offSet);
                        offSet += arrAlmComment[j].user.length * 2;
                    }
                    //评论条数
                    compressBuf.writeInt16LE(1, offSet);
                    offSet += 4;
                    //评论内容
                    //评论的报警编号
                    compressBuf.writeUIntLE(arrAlmComment[j].alarmId + j, offSet, 8);
                    offSet += 8;
                    //评论内容
                    compressBuf.writeInt16LE(arrAlmComment[j].describe.length, offSet);
                    offSet += 2;
                    if (arrAlmComment[j].describe.length > 0)
                        compressBuf.writeInt16LE(arrAlmComment[j].describe, offSet);
                        offSet += arrAlmComment[j].describe.length * 2;
                }

                let size = 64 + offSet + 128;
                let dataPackage = Buffer.alloc(size + 16);
                if (dataPackage != null){
                    dataPackage.writeInt16LE(DB.nodeChange.NET_ADD_ALM_COMMENT_REQ,24 + 16);
                    //this.packetType = DB.nodeChange.NET_ADD_ALM_COMMENT_REQ;
                    let lOffSet = 60 + 16;
                    //数据包原始长度
                    //*((DWORD *)(dataPackage+lOffSet)) = compressBuf.GetLength();
                    dataPackage.writeInt16LE(0, 30 + 16);
                    dataPackage.writeUInt32LE(offSet,lOffSet);
                    lOffSet += 4;
                    //缓冲区长度
                    let lBufSize = size - lOffSet;
                    //压缩
                    let buffer = zlib.deflateSync(compressBuf);
                    //zlib.deflate(compressBuf,(err, buffer) => {  
                        buffer.copy(dataPackage,lOffSet);
                        let bufSize = buffer.length; 
                        dataPackage.writeInt8(1, 5 + 16);
                        dataPackage.writeInt32LE((bufSize + 4), 26 + 16);
                        //发送
                        let buff = DB.addPacketHeader(dataPackage);
                        return buff;
                    //});
                }
            };
            unserilize(){
                return {retCode:true};
            };
        },
                
        //下置数据
        "setData":class{
            constructor(){
                this.packetType = 48;
            };
            //写的数据
            serilize(arrTagData){
                let uiQuility = 232;
                let number = arrTagData.length;
                let offSet = 0;
                let compressBuf = Buffer.alloc(20 + (number * 16));
                
                compressBuf.writeInt32LE(number, offSet);
                offSet += 4;
                let myDate = new Date();
                myDate.toLocaleString( );
                //console.log(myDate);
                let t1 = Date.parse(myDate) / 1000;
                compressBuf.writeInt32LE(t1, offSet);
                offSet += 8;
                offSet += 2;
                compressBuf.writeInt16LE(number, offSet);
                offSet += 2;
                for(let j = 0; j < arrTagData.length; j++)
                {
                    let parId = arrTagData[j].parId || 13;
                    compressBuf.writeInt32LE(parId, offSet);
                    offSet += 4;
                    if(arrTagData[j].tagId != undefined){
                        if(DB.mapIdToTagInfo[arrTagData[j].tagId] != undefined){
                            compressBuf.writeUInt32LE(arrTagData[j].tagId,offSet);
                        }
                    }
                    else if(DB.mapNameToTag[arrTagData[j].tagName] != undefined){
                        compressBuf.writeUInt32LE(DB.mapNameToTag[arrTagData[j].tagName].TagInfo.tagId,offSet);
                    }
                    offSet += 4;
                    compressBuf.writeInt32LE(uiQuility, offSet);
                    offSet += 4;
                    compressBuf.writeUInt32LE(arrTagData[j].data, offSet);
                    offSet += 4;
                }
                //压缩是否 后续优化
                let lSize = 300;
                let dataPackage = Buffer.alloc(lSize + 16);

                dataPackage.writeInt16LE(DB.nodeChange.NET_WRITE_DATA_REQ,24 + 16);
                //this.packetType = DB.nodeChange.NET_WRITE_DATA_REQ;
                dataPackage.writeInt16LE(0,30 + 16);
                dataPackage.writeInt16LE(0,32 + 16);
                dataPackage.writeInt16LE(3,6 + 16);

                //数据原始长度
                let lOffSet = 60 + 16;
                dataPackage.writeUInt32LE(36,lOffSet);
                lOffSet += 4;
                //压缩
                let lBufSize = lSize - lOffSet;
                let buffer = zlib.deflateSync(compressBuf);
                //zlib.deflate(compressBuf,(err, buffer) => {
                    buffer.copy(dataPackage,lOffSet);
                    let bufSize = buffer.length; 
                    dataPackage.writeInt8(1,5 + 16);
                    dataPackage.writeInt32LE((bufSize + 4), 26 + 16);

                    //发送
                    let buff = DB.addPacketHeader(dataPackage);
                    return buff;	
                //});
            };
            unserilize(){
                return {retCode:true};
            };
        },
                
        //注销点 
        "unSubRealData":class{
            constructor(){
                this.packetType = 53;
            };
            contains(a, obj) { 
                var i = a.length; 
                while (i--) { 
                    if (a[i] === obj) { 
                    return i; 
                    } 
                } 
                return false; 
            }
            //写的数据
            serilize(arrLogout){
                let lRet = 0;
                let tagId;
                let parId;
                let iTagParKey = [];
                let interspaceSize = (10 * (arrLogout.length));
                let compressBuf = Buffer.alloc(interspaceSize);
                //写入个数
                let lUnRegCount = 0;
                let offSet = 0;
                compressBuf.writeInt32LE(lUnRegCount,offSet);
                offSet += 4;
                for (let i = 0; i < arrLogout.length; i++){
                    //等于0为无效注册点
                    if (arrLogout[i] == 0)
                        continue;
                    //清除
                    for(let j = 0; j < DB.mapRegNoToRegTagPar.length; j++){
                        if(arrLogout[i] == DB.mapRegNoToRegTagPar[j].regNo){
                            tagId = DB.mapRegNoToRegTagPar[j].regTagPar.tagId;
                            parId = DB.mapRegNoToRegTagPar[j].regTagPar.parId;
                        }
                    }
                    //注销点数++
                    lUnRegCount++;
                    //需要向DB注销
                    compressBuf.writeUInt32LE(tagId,offSet);
                    offSet += 4;
                    compressBuf.writeInt16LE(parId,offSet);
                    offSet += 2;
                    let a = DB.mapRegNoToRegTagPar[(arrLogout[i]) - 1];
                    DB.mapRegNoToRegTagPar.splice(this.contains(DB.mapRegNoToRegTagPar,a),1);
                    lRet++;		
                }

                //向DB发送数据
                if (lUnRegCount > 0){
                    let lSize = 264 + offSet;
                    let dataPackage = Buffer.alloc(lSize + 16);
                    if (dataPackage != null){
                        let lOffSet = (0 + 16);
                        dataPackage.writeInt16LE(DB.nodeChange.NET_UNREG_TAGPAR_REQ,(24 + 16));
                        //this.packetType = DB.nodeChange.NET_UNREG_TAGPAR_REQ;
                        dataPackage.writeInt16LE(0,(30 + 16));
                        dataPackage.writeInt16LE(0,(32 + 16));
                        dataPackage.writeInt16LE(6,(6 + 16));
                        lOffSet += 60;
                        //数据原始长度
                        dataPackage.writeUInt32LE(offSet,lOffSet);
                        lOffSet += 4;
                        //压缩
                        let lBufSize = lSize - lOffSet;
                        let buffer = zlib.deflateSync(compressBuf);
                        //zlib.deflate(compressBuf,(err, buffer) => {
                            buffer.copy(dataPackage,lOffSet);
                            let bufSize = buffer.length; 
                            dataPackage.writeInt8(1, (5 + 16));
                            dataPackage.writeInt32LE((bufSize + 4), (26 + 16));    
                            //发送
                            let buff = DB.addPacketHeader(dataPackage);    
                            return buff;    
                        //});
                    }
                }
            };
            //读的数据
            unserilize(){
                return {retCode:true}
            };
        },
                
        //开启订阅报警
        "openSubscribeAlm":class{
            constructor(){
                this.packetType = [68,72]; 
            };
            serilize(subscribe){
                let dataPackage = Buffer.alloc(60 + 16);
                let identifying = subscribe?DB.nodeChange.NET_SUBSCRIBE_ALMINFO_REQ:DB.nodeChange.NET_UNSUBSCRIBE_ALMINFO_REQ;
                //this.packetType = identifying;
                dataPackage.writeInt16LE(identifying,(24 + 16));
                dataPackage.writeInt8(0,(5 + 16));
                dataPackage.writeInt32LE(0,(26 + 16));
                dataPackage.writeInt16LE(0,(30 + 16));
                dataPackage.writeInt16LE(0,(32 + 16));
                dataPackage.writeInt16LE(3,(6 + 16));
                //发送
                let buff = DB.addPacketHeader(dataPackage);     
                DB.alm = true;
                DB.notarizeAlm = subscribe;
                return buff;  
            };
            unserilize(dataPackage){
                return {retCode:true}
            };           
        },

        //订阅报警   
        "heartBeatAlm":class{
            constructor(){
                this.packetType = 70;
            };
            serilize(){
                let dataPackage = Buffer.alloc(60 + 16);
                dataPackage.writeInt16LE(DB.nodeChange.NET_CHANGE_ALMINFO_REQ,(24 + 16));
                //this.packetType = DB.nodeChange.NET_CHANGE_ALMINFO_REQ;
                dataPackage.writeInt8(0,(5 + 16));
                dataPackage.writeInt32LE(0,(26 + 16));
                dataPackage.writeInt16LE(DB.notarizeAlm,(30 + 16));
                //发送
                let buff = DB.addPacketHeader(dataPackage);
                return buff;
            };
            unserilize(dataPackage){
                if(dataPackage == null){
                    return;
                }
                if(dataPackage.readInt32LE(12) == DB.PACK_TYPE_DATA){
                    let type = dataPackage.readInt16LE(40);
                    if(type == DB.nodeChange.NET_CHANGE_ALMINFO_ANS){
                        if(DB.alm == true){
                            DB.callbackAlm(dataPackage);
                        }
                    }
                }
                else if(dataPackage.readInt32LE(12) == DB.PACK_TYPE_STAT){
 
                }
            };
        },

        //订阅实时  
        "heartBeatData":class{
            constructor(){
                this.packetType = 51;
            };
            serilize(){
                let dataPackage = Buffer.alloc(60 + 16);
                dataPackage.writeInt16LE(DB.nodeChange.NET_UPDATE_REG_TAGPAR_DATA_REQ,(24 + 16));
                //this.packetType = DB.nodeChange.NET_UPDATE_REG_TAGPAR_DATA_REQ;
                dataPackage.writeInt8(0,(5 + 16));
                dataPackage.writeInt32LE(0,26);
                dataPackage.writeInt16LE(DB.bUpdateSwitch,(30 + 16));
                //发送
                let buff = DB.addPacketHeader(dataPackage);    
                return buff;          
             };
             
             unserilize(dataPackage){
                if(dataPackage == null){
                    return;
                }
                if(dataPackage.readInt32LE(12) == DB.PACK_TYPE_DATA){
                    let type = dataPackage.readInt16LE(40);
                    if(type == DB.nodeChange.NET_UPDATE_REG_TAGPAR_DATA_ANS){
                        DB.callbackData(dataPackage);
                    }
                }
                else if(dataPackage.readInt32LE(12) == DB.PACK_TYPE_STAT){
                }
            };
        }
    }
};
var init = function(FRtdb,dataChange,alarmChange) {
    DB = new ef5();
    DB.callbackDataChange = dataChange;
    DB.callbackAlmChange = alarmChange;
    //设置报头
    FRtdb.conn.setHeader(16,8,4);
    //处理心跳报警
    let heartBeat = async function(){
        FRtdb.heartBeatData(); 
        if(FRtdb.options.enableAlarm == true){
           FRtdb.heartBeatAlm(); 
        }

        setTimeout(heartBeat,FRtdb.options.heartBeat);
    }
    setTimeout(heartBeat,FRtdb.options.heartBeat); 

};

module.exports.init = init;
