const fs = require('fs');//文件
var iconv = require('iconv-lite');//编码
var SMB2 = require("smb2");//共享路径
var xml2js = require('xml2js');//解析xml
var zlib = require('zlib'); //解压 压缩
var DB;

class fc7{
    constructor(){
        this.myMap = new Map();
        this.HISIDXCOUNT = 400;
        this.BLOCKSIZE = 600;
        this.BADFLOAT = (-9999.0);
        this.tagnoName = [];
		
        this.PAR_L3 = 46;
        this.PAR_L5 = 48;
        this.PAR_H3 = 71; 
        this.PAR_H5 = 73;
        this.PAR_RATE = 56;
        this.PAR_DEV = 57;
        this.PAR_LL = 52;
        this.PAR_HH = 55;
        this.Node = {
            FUC_TAG_INI: 6,
            FUC_HANDLE: 7,
            FUC_GETHISDATA: 12,
            FUC_INSERTHISDATA: 13,
            FUC_UNREGISTER_TAGPARS: 15,
            FUC_DBCOMM_SETDATA: 16,
            FUC_DBCOMM_GETDATA: 17,
            FUC_DBCOMM_REGTAG: 18,
            FUC_DBCOMM_UNREGTAG: 19,
            FUC_DBCOMM_UPDATE: 20,
            FUC_DBCOMM_ALLREGTAG: 21,
            FUC_DBCOMM_AllUNREGTAG: 22,
            FUC_GETHISDATATRACE: 23,
            FUC_HANDLE_EX: 24,
            FUC_DBCOMM_UPDATE_EX: 25
        }
        this.REGISTER_ERR_NOAUTH = -3;
        ////////////////////////////////////////////////////
        this.DBCOMM_DBTAGTYPE_LONG = 1;
        this.DBCOMM_DBTAGTYPE_DOUBLE = 2;
        this.DBCOMM_DBTAGTYPE_STR = 4;
        this.PACK_HEAD_LEN = 16;
        this.PACK_LEN = 64;
        //包的类型
        this.PACK_TYPE_DATA = 0;    //是数据
        this.PACK_TYPE_STAT = 2;    //网络状态
        this.NET_USER_MANAGER = 1047;
        this.NET_ALM_REQ = 1007
        ///////////////////////////////////////////////////////
        this.dbTagObj = {};         //数据库点信息
        this.dbTagArr = [];         //数据库点信息
        this.dbTagCnt = 0;          //数据库点个数
        this.dbAlmReqCnt = 0;       //报警请求
        this.dbAlmCnt = 0;          //报警点个数
        this.dbAlmArrInfo = [];     //初始化de报警信息[报警编号]
        this.keyToAlmData = [];     //报警信息通过key绑定
        this.dbAlmArr = [];         //全部报警数据
        this.arrTreeInfo = [];      //xml层结构信息
        this.tagTypeArr = [];       //类型7个汇总
        this.dbXmlInfo;             //xml信息
        this.clientID = 0;          //客户端ID
        this.packSNo = 0;
        this.dbRegTagCnt = 0;       //所有注册点
        /////////////////////////////////////////////////
        this.regTagNoObj = {};      //key值
        this.regNoInfo = [];        //注册信息[ID]
        this.regNoID = 0;           //注册ID
        this.isWork = false;        //工作状态
        this.arrData = [];                
    } 
    
    //初始化函数第一包
    initDbMap(initBuf){
        var nOffset = 0;
        let nTagStartBit = initBuf.readInt32LE(nOffset);//2858
        nOffset += 4;
        let nTypeCount = initBuf.readInt16LE(nOffset);
        nOffset += 2;  
        //sizeof(int) + nTagStartBit + sizeof(int)
        let nAreaCount = initBuf.readInt8(4 + 4 + nTagStartBit);
        let nTagCount = initBuf.readInt32LE(4 + 4 + nTagStartBit + 1);
        //初始化参数列表
        for (let i = 0; i < nTypeCount; i++){
            let tagParObjBuf = [];
            let tagParBuf = [];
            let tagParArr = [];
            let tagParMap = [];//0.pv点参数名拼接的
            let nKind = initBuf.readInt16LE(nOffset);
            nOffset += 4;            
            let parCount = initBuf.readInt16LE(nOffset);        
            nOffset += 4;
            //初始化点参数列表
            for (let j = 0; j < parCount; j++) {
                let tagParObj = {};               
                tagParObj.tagKind = initBuf.readInt8(nOffset);
                nOffset += 1;   
                let bufferTest = this.readString(initBuf,nOffset); 
                tagParObj.parName = iconv.decode(bufferTest, 'gbk');
                nOffset += 12;    
                tagParObj.ParNo = initBuf.readInt8(nOffset);
                nOffset += 1;
                tagParObjBuf[tagParObj.parName] = {parId:tagParObj.ParNo,tagKind:tagParObj.tagKind,parName:tagParObj.parName};
                tagParBuf[tagParObj.ParNo] = tagParObjBuf[tagParObj.parName];
                let csNameAdd = nKind + "." + tagParObj.parName;
                tagParMap[csNameAdd] = tagParObjBuf[tagParObj.parName]; 
                tagParArr[j] = tagParObjBuf[tagParObj.parName];     
            }
            this.tagTypeArr.push({arr:tagParArr,parNameToObj:tagParObjBuf,parNoToObj:tagParBuf,tagParToObj:tagParMap});
        }
        nOffset = 4 + 4 + nTagStartBit + 1 + 4;
        nOffset += (72 * nTagCount);
        nOffset += 4;
        let buffer = zlib.unzipSync(initBuf.slice(nOffset));
        nOffset = 0;
        //获取层结构信息 JSON
        let tmpXml = this.readString(buffer,nOffset);
        nOffset += (tmpXml.length);
        this.dbXmlInfo = iconv.decode(tmpXml, 'gbk');
        //xml转为JOSN
        let arrTreeInfoTmp = [];
        xml2js.parseString(this.dbXmlInfo, {explicitArray : false}, function (err, result) {
            function loadData(layer,parenName){
                for (let i = 0; i < layer.length; i++) {
                    var jsonTreeInfo = {NodeID:layer[i].$.NodeID,Name:layer[i].$.Name,Parent:parenName,almTagList:[]};
                    arrTreeInfoTmp.push(jsonTreeInfo);
                    if (layer[i].LAYER instanceof Array) {
                        loadData(layer[i].LAYER,parenName.length == 0? jsonTreeInfo.Name : parenName + "\\" + jsonTreeInfo.Name);
                    }
                    else{				
                        if (layer[i].LAYER) {
                            var jsonSubTreeInfo = {NodeID:layer[i].LAYER.$.NodeID,Name:layer[i].LAYER.$.Name,Parent:parenName.length == 0? jsonTreeInfo.Name : parenName + "\\" + jsonTreeInfo.Name,almTagList:[]};
                            arrTreeInfoTmp.push(jsonSubTreeInfo);
                        }
                    }
                }
            }
            var jsonTreeInfo = {NodeID:0,Name:"",Parent:"",almTagList:[]};
            arrTreeInfoTmp.push(jsonTreeInfo);
            loadData(result.DbManger.LAYER,"");
        });
        this.arrTreeInfo = arrTreeInfoTmp;
        //获取报警信息
        nOffset ++; // \0 结束位+1
        let nAlmCnt = 0;
        nAlmCnt = buffer.readInt32LE(nOffset);
        nOffset += 4;
        for (let i = 0;i < nAlmCnt; i++){
            var dbTagInfo = {};
            dbTagInfo.nId = buffer.readInt32LE(nOffset); nOffset += 4;
            dbTagInfo.nUnit = buffer.readInt16LE(nOffset); nOffset += 2;               
            let bufferTest = this.readString(buffer,nOffset); 
            dbTagInfo.csTagName = iconv.decode(bufferTest, 'gbk');
            nOffset += (bufferTest.length + 1);
            dbTagInfo.cGroup = buffer.readInt8(nOffset); nOffset += 1;
            dbTagInfo.cType = buffer.readInt8(nOffset); nOffset += 1;
            dbTagInfo.arrInfoStr = [];
            for (let j = 0; j < this.arrTreeInfo.length; j++) {
                const jsonTree = this.arrTreeInfo[j];               
                if (jsonTree.NodeID == dbTagInfo.nUnit) {
                    let tmpName = jsonTree.Parent.length == 0 ? jsonTree.Name : jsonTree.Parent + "\\" + jsonTree.Name
                    if (tmpName.length > 0) {

                        dbTagInfo.csTagName = tmpName + "\\" + dbTagInfo.csTagName;
                    }
                    this.arrTreeInfo[j].almTagList.push(dbTagInfo.csTagName);
                    break;
                }                
            }  
            let parnum = dbTagInfo.cType == 1 ? 14 : 22;
            for (let j = 0; j < parnum; j++){
                let bufferName = this.readString(buffer,nOffset); 
                let csTagName = iconv.decode(bufferName, 'gbk');
                nOffset += (bufferName.length + 1);
                dbTagInfo.arrInfoStr.push(csTagName);
            }
            this.dbAlmArrInfo[dbTagInfo.nId] = dbTagInfo;
        }
        //数据库点信息
        nOffset = 4 + 4 + nTagStartBit + 1 + 4;
        for (let i = 0; i < nTagCount; i++){
            //解析CDBIFTag* pTag
            let tmpTagArea = initBuf.readInt16LE(nOffset);
            nOffset += 2;

            let tmpTagKind = initBuf.readInt16LE(nOffset);
            nOffset += 2;

            let tmpGroup = initBuf.readInt16LE(nOffset);
            nOffset += 2;

            let tmpHis = initBuf.readInt16LE(nOffset);
            nOffset += 2;

            let m_cTagName = this.readString(initBuf,nOffset); 
            let csNameTag = iconv.decode(m_cTagName, 'gbk');
            nOffset += 64;
            let  tagName  =  0;
            let  tagShortName  =  0;
            tagShortName = csNameTag;
            for (let j = 0; j < this.arrTreeInfo.length; j++) {
                const jsonTree = this.arrTreeInfo[j];               
                if (jsonTree.NodeID == tmpTagArea) {
                    if ((jsonTree.Parent.length > 0) ||(jsonTree.Name.length > 0)) {
                        if(jsonTree.Parent.length == 0){
                            csNameTag = jsonTree.Name + "\\" + csNameTag;
                            tagName  =  csNameTag;
                        }
                        else{
                            csNameTag = jsonTree.Parent + "\\" + jsonTree.Name + "\\" + csNameTag;
                            tagName  =  csNameTag;
                        }
                    }
                    break;
                }                
            }
            this.dbTagObj[csNameTag] = {TagArea:tmpTagArea,tagKind:tmpTagKind,Group:tmpGroup,His:tmpHis,TagName:csNameTag,TagNo:i};                        
            this.dbTagArr[this.dbTagObj[csNameTag].TagNo] = this.dbTagObj[csNameTag];
            if(tmpTagArea == 0){
                this.arrData.push({tagName:csNameTag,tagShortName:tagShortName,nodeId:tmpTagArea,tagId:i});
            }
            else{
                this.arrData.push({tagName:tagName,tagShortName:tagShortName,nodeId:tmpTagArea,tagId:i});
            }
            this.dbTagCnt ++;
        }
        return true;
    }

	//拼包
    getPackBuf(type, p1, p2, p3, packSign, packSsNo, msg, msgLen, buff, len) {
        //经过NetServer需要添加NetServer包头，和本地消息不同。
        //包体=NetServer包头+Data包头+Data
        let msgLength = this.PACK_HEAD_LEN/*NetServer包头长度*/ + this.PACK_LEN/*Package包头*/ + msgLen;
        let buf = Buffer.alloc(msgLength);
        //NetServer包头封装
        buf.writeUInt32LE(0x88888888, 0, true);
        buf.writeUInt32LE(0x88888888, 4, true);
        buf.writeInt32LE(msgLength, 8, true);
        if ((msg == null) && (msg == null)) {
            buf.writeInt32LE(this.PACK_TYPE_STAT, 12);
            buf.writeInt32LE(0, 16);
        }
        else {
            buf.writeInt32LE(this.PACK_TYPE_DATA, 12);
            buf.writeInt16LE(0, 16);//对齐
            //buf.fill(msg,15,msgLen);
        }
        //Data Msg包头封装
        let a = 16;
        //Data Package封装
        buf.fill(0, 0 + a, 5);//char szOldSource[SRC_LEN - 1]; //包发送者标识for client
        buf.writeInt8(0, 5 + a);//BYTE bCompress;
        buf.writeInt16LE(p3, 6 + a);//short p3;//用户参数3
    
        buf.fill(0, 8 + a, 4);//char szSource[4]; //保留 for client
        buf.writeInt8(0, 12 + a);//BYTE cReserved[2]; //保留
        buf.writeInt16LE(0, 14 + a);//对齐
    
         
        buf.writeInt32LE(1, 16 + a);//long sock; //保留 for server
        buf.writeInt16LE(2, 20 + a);//short serno; //保留 serial no
        buf.writeInt16LE(0, 22 + a);//short no; //保留pack no
    
        buf.writeInt16LE(0, 24 + a);//short序号; //系列号 serial no
        buf.writeInt16LE(type, 26 + a);//short type; //包类型 pack type
        buf.writeInt32LE(msgLen, 28 + a);//long len;//包长度
    
        buf.writeInt16LE(p1, 32 + a);//short p1;//用户参数1
        buf.writeInt16LE(p2, 34 + a);//short p2; //用户参数2
        buf.writeInt16LE(0, 36 + a);//short code;//是否为结束包
    
        buf.fill(0, 38 + a, 16);//char szNode[16];//目的地机器标识
        buf.fill(0, 54 + a, 8);//char szTopic[8];//保留
        buf.writeInt8(packSign, 54 + a);
        buf.writeInt8(packSsNo, 58 + a);
        buf.writeInt16LE(0, 62 + a);//对齐
        return buf;
    }

    setWorking(bWorking){
        this.isWork = bWorking;
    }

    //自定义解析文字
    readString(buffer,nOffset,encoding = 'ascii'){
        let nLen = 0;
        let arrContent = [];
        let c;
        while ((c = buffer.readInt8(nOffset)) != 0) {
            arrContent[nLen++] = c;
            nOffset ++;
        }
        const buf = Buffer.from(arrContent);
        return buf;
    }

    readStringDescribe(buffer,nOffset,encoding = 'ascii'){
        let nLen = 0;
        let arrContent = [];
        let c;
        while (1) {
            c = buffer.readInt8(nOffset);
            if( (c == 0) && (buffer.readInt8(nOffset + 1) == 0)){
                break;
            }
            arrContent[nLen++] = c;
            nOffset ++;
        }
        const buf = Buffer.from(arrContent);
        return buf;
    }

    //加载点名文件
    async load(csFile){
        let m_csFile = this.filePath + "\\dat\\";
        m_csFile += csFile;
        let data = await this.readIdxData(m_csFile);
        let bUnicode = false;
        let nOffset = 0;
        let wUnicodeFlag = data.readUInt16LE(nOffset);
        if ((wUnicodeFlag == 0xFEFF) || (wUnicodeFlag == 0xFFFE)){
            bUnicode = true;
            nOffset += 2;
        }
        else{
            data.readUInt16LE(0);
        }
        let number = -1;	
        for (;;){
            let csLineString = "";
            let nRet = 0;
            let nCount = 0;
            let bEndLine = false;
            let csRead;	
            let chW;
            if (bUnicode){
                let szBlock = "";
                for (let i = 0; i < 512; i++){
                    if(nOffset >= data.length){
                        break;
                    }
                    let tmp = this.readString(data,nOffset); 
                    chW = iconv.decode(tmp, 'gbk');
                    nOffset += 2;
                    if (chW == '\n'){
                        bEndLine = true;
                        break;
                    }
                    szBlock += chW;
                    ++nCount;
                }
                if (bEndLine)
                    nRet = 2;
                else if (nCount > 0)
                    nRet = 1;
                csRead = szBlock;
            }
            else{
                let szBlock;
                let chA = "";
                for (let i = 0; i < 512; i++){
                    chA = data.readIntLE(nOffset);
                    if (chA == '\n'){
                        bEndLine = TRUE;
                        break;
                    }
                    szBlock[i] = chA;
                    ++nCount;
                }
                if (bEndLine)
                    nRet = 2;
                else if (nCount > 0)
                    nRet = 1;
                csRead = szBlock;
            }
            if (nRet == 0)	//读取失败
                break;
            else if (nRet == 1)
                csLineString += csRead;	//一行还未读完
            else if (nRet == 2){
                csLineString += csRead;	//读完一行
                csLineString = csLineString.toLowerCase();
                number++;
                let csTmp = csLineString.replace(/[\r\n]/g, " ");
                let csName = csTmp.replace(/(^\s*)|(\s*$)/g, "");	
                this.tagnoName[csName] = {tagno:number,name:csName};
                continue;
            }
        }
        return data;
    }

    //异步读取文件
    readIdxData(fileName) {
        return new Promise(function (resolve, reject) {
            fs.readFile(fileName, function(error, data) {
                if (error){
                    console.log("未找到" + fileName + "文件。。。");
                    return reject(error);
                } 
                resolve(data);
            });
        });
    } 

    //从文件中查找数据
    async readListFromFile(readtim, GetArr){
        if (GetArr.length == 0)
            return true;
        let bDealAll = true;
        for (let i = 0; i < GetArr.length; i++){//这个for没意义呀?
            let Get = GetArr[i];                                                                                                                   
            //文件中的数据
            if (this.findHisDataMap(Get.m_nIndex,Get)){
                //Get.m_DataGetFile.RemoveAt(posold);
            }
            else{
                bDealAll = false;
            }
        }
        //处理完全部的数据
        if (bDealAll)
            return true;
        //排序
        GetArr.sort(this.compGet);
        let date = new Date(readtim * 1000);
        let cs = "\\dat\\h" + (date.getFullYear() - 2000)  + ((date.getMonth() + 1) <= 9 ? '0' + (date.getMonth() + 1) : (date.getMonth() + 1)) + (date.getDate() < 10 ? '0' + date.getDate() : date.getDate()) + ".idx";
        let cs1 = "\\dat\\h" + (date.getFullYear() - 2000)  + ((date.getMonth() + 1) <= 9 ? '0' + (date.getMonth() + 1) : (date.getMonth() + 1)) + (date.getDate() < 10 ? '0' + date.getDate() : date.getDate()) + ".dat";
        cs = this.filePath + cs;
        cs1 = this.filePath + cs1;	
        //打开数据索引文件
        let data = await this.readIdxData(cs);
        let nBlockLen = 4 + 12 * this.HISIDXCOUNT;//sizeof(long) + sizeof(MYHISTAGINDEX) * this.HISIDXCOUNT;
        let nBlockLen1 = 4 + 8 * this.BLOCKSIZE;//sizeof(long) + sizeof(HISDATA) * this.BLOCKSIZE;
        let nOldCount = data.length / nBlockLen;
        //读取索引，按照索引的时间，切分数据，合理分配到各个时间区段
        let nRecCount = 0;
        let GetposDataArr = [];       
        for (let i = 0; i < GetArr.length; i++){
            let IndexData = [];
            let Get = GetArr[i];
            // POSITION pos = Get.m_DataGetFile.GetHeadPosition();
            let pos = 0;
            let oldpos = pos;
            let getData = Get.m_DataGetFile[pos];//.m_DataGetFile.GetNext(pos);
            pos++;
            let bHasList = true;			
            let  oldData = {};
            let GetposData = {};		
            GetposData.m_nIndex = i;
            GetposData.m_nPos = -1;
            GetposData.m_nCount = 0;
            GetposData.m_BgnPos = -1;
            //文件大小是否合适
            if (Get.m_nIndex < nOldCount){
                //读取计数
                let nOffset = Get.m_nIndex * nBlockLen;
                nRecCount = data.readInt32LE(nOffset);
                nOffset += 4;
                for (let k = 0; k < nRecCount; k++) {
                    let startTime = {};
                    startTime.milltm = data.readUInt16LE(nOffset) & 0x3FF;// unsigned short milltm:10;
                    startTime.second = data.readUInt16LE(nOffset) >> 10 & 0x3F;// unsigned short second:6;
                    nOffset += 2;
                    startTime.minute = data.readUInt16LE(nOffset) & 0x3F;// unsigned short minute:6;
                    startTime.hour = data.readUInt16LE(nOffset) >> 6 & 0x1F;// unsigned short hour:5;
                    startTime.rsv = data.readUInt16LE(nOffset) >> 11 & 0x1F;// unsigned short rsv:5;
                    nOffset += 2;
                    let Pos = data.readInt32LE(nOffset);
                    nOffset += 8;
                    IndexData.push({startTime:startTime,nPos:Pos});
                }
                //判断数据是否非法
                if ((nRecCount > this.HISIDXCOUNT) || (nRecCount < 0)) nRecCount = 0;
            }
            else{
                nRecCount = 0;
            }	
            for (let j = 0; j < nRecCount; j++){
                //非正常数据
                if (!this.myCheckTime(IndexData[j].startTime) /*|| (IndexData[j].nPos + nBlockLen1 > len1)*/ || (IndexData[j].nPos % nBlockLen1)
                                || ((j != 0) && this.myDifftimeEx(IndexData[j].startTime,oldData.startTime) <= 0)){
                    nRecCount = j;
                    break;
                }
                while(1){
                    //比较数据属于那个区
                    let nComp = this.myDifftimeEx(this.toHisTime(getData.tTime,getData.nMilli),IndexData[j].startTime);
                    if (nComp >= 0){
                        //最后一个索引，把所有数据全部统计为该索引数据
                        if (j + 1 == nRecCount){
                            if (GetposData.m_BgnPos == -1){
                                GetposData.m_BgnPos = oldpos;
                                GetposData.m_nPos = IndexData[j].nPos;
                                GetposData.m_nCount = 1;
                                while (pos >= 0 && pos < nRecCount){
                                    getData = Get.m_DataGetFile[pos];
                                    pos++;
                                    GetposData.m_nCount++;
                                }
                                GetposDataArr.push({m_BgnPos:GetposData.m_BgnPos,m_nCount:GetposData.m_nCount,m_nPos:GetposData.m_nPos,m_nIndex:GetposData.m_nIndex});
                                GetposData.m_nCount = 0;
                                GetposData.m_BgnPos = -1;
                                bHasList = false;
                                break;
                            }
                        }
                        //属于数据范围
                        else if (this.myDifftimeEx(this.toHisTime(getData.tTime,getData.nMilli),IndexData[j + 1].startTime) < 0){
                            if (GetposData.m_BgnPos == -1){
                                GetposData.m_BgnPos = oldpos;
                                GetposData.m_nPos = IndexData[j].nPos;
                            }
                            GetposData.m_nCount++;
                            //继续比较数据
                            if (pos >= 0 && pos < nRecCount && pos < Get.m_DataGetFile.length){
                                oldpos = pos;
                                getData = Get.m_DataGetFile[pos];
                                pos++;
                            }
                            else{
                                GetposDataArr.push({m_BgnPos:GetposData.m_BgnPos,m_nCount:GetposData.m_nCount,m_nPos:GetposData.m_nPos,m_nIndex:GetposData.m_nIndex});
                                GetposData.m_nCount=0;
                                GetposData.m_BgnPos = -1;
                                bHasList = false;
                                break;
                            }
                            continue; // goto Loop;
                        }
                        else if (GetposData.m_nCount){
                            GetposDataArr.push({m_BgnPos:GetposData.m_BgnPos,m_nCount:GetposData.m_nCount,m_nPos:GetposData.m_nPos,m_nIndex:GetposData.m_nIndex});
                            GetposData.m_nCount = 0;
                            GetposData.m_BgnPos = -1;
                        }
                        else{
                                break;
                            }
                    }
                    else{
                        //继续比较数据
                        if (pos >= 0 && pos < nRecCount){
                            oldpos = pos;
                            getData = Get.m_DataGetFile[pos];
                            pos++;
                        }
                        else{
                            bHasList = false;
                            break;
                        }
                    }
                }
                if(!bHasList){
                    break;
                }
                oldData = IndexData[j];
            }
        }
                
        let data1 = await this.readIdxData(cs1);	
        //排序
        GetposDataArr.sort(this.compGetPosData);
        for (let i = 0; i < GetposDataArr.length; i++){
            let HisData = [];
            let GetposData = GetposDataArr[i];
            let Get = GetArr[GetposData.m_nIndex];
            //读取数据
            let nOffset = GetposData.m_nPos;
            nRecCount = data1.readInt32LE(nOffset);
            nOffset += 4;
            for (let k = 0; k < nRecCount; k++) {
                let time = {};
                time.milltm = data1.readUInt16LE(nOffset) & 0x3FF;// unsigned short milltm:10;
                time.second = data1.readUInt16LE(nOffset) >> 10 & 0x3F;// unsigned short second:6;
                nOffset += 2;
                time.minute = data1.readUInt16LE(nOffset) & 0x3F;// unsigned short minute:6;
                time.hour = data1.readUInt16LE(nOffset) >> 6 & 0x1F;// unsigned short hour:5;
                time.rsv = data1.readUInt16LE(nOffset) >> 11 & 0x1F;// unsigned short rsv:5;
                nOffset += 2;
                let fVal = data1.readFloatLE(nOffset);
                nOffset += 4;
                HisData.push({time:time,fVal:fVal});
            }
            if ((nRecCount > this.BLOCKSIZE) || (nRecCount < 0)) nRecCount = 0;
            //读取数据
            if (nRecCount > 0){
                let nFindBgn = 0;
                let pos = GetposData.m_BgnPos;
                for (let j = 0; j < GetposData.m_nCount; j++){
                    let getData = Get.m_DataGetFile[pos];
                    pos++;//Get.m_DataGetFile.GetNext(pos);
                    let RHisData = {};
                    RHisData.time = this.toHisTime(getData.tTime,getData.nMilli);
                    let nIndex = (nRecCount - nFindBgn) ? this.findIndex(HisData,nFindBgn,RHisData,nRecCount-nFindBgn,false) : 0;
                    //找到数据
                    if (nIndex + nFindBgn > 0){
                        getData.fDat = HisData[nIndex + nFindBgn - 1].fVal;
                        let GetDataKey = getData;
                        let milli = this.splitHisTime(readtim,HisData[nIndex + nFindBgn - 1].time,getData.tTime,getData.nMilli);
                        getData.nMilli = milli;
                        //写入历史缓存
                        this.setHisDataMap(Get.m_nIndex,GetDataKey,getData);
                    }
                    nFindBgn = nIndex + nFindBgn;
                }
            }
        }
        return GetArr;
    }

    compare(a,b){
        if(a.lTime == b.lTime){
            return a.iMilli - b.iMilli < 0;
        }
        else {
            return a.lTime - b.lTime < 0;
        }    
    }

    compGet(V1,V2){
        return V1.m_nIndex - V2.m_nIndex; 
    }         
    
    compGetPosData(V1, V2){
        if (V1.m_nPos > V2.m_nPos)
            return 1;
        if (V1.m_nPos < V2.m_nPos)
            return -1;
        return 0;
    }
    
    clearOverData(){
        if (this.myMap.size > 240000){
            let nCount = this.myMap.size - 240000 / 2;
            // this.myMap.forEach(function(value, key) {
            //     let a = this.delete(key);
            //     if(a && (--nCount <= 0)){
            //         break;
            //     }
            // }, this.myMap)
        }
    }
    
    //reftim参考时间
    splitHisTime(reftim, histim, tim, milli){
        let date = new Date(reftim * 1000);
        let t = "" + date.getFullYear() + "-" + ((date.getMonth() + 1) <= 9 ? '0' + (date.getMonth() + 1) : (date.getMonth() + 1)) + "-" + (date.getDate() < 10 ? '0' + date.getDate() : date.getDate()) + " "  + histim.hour  + ":" + histim.minute  + ":" + histim.second + "";
        tim = Date.parse(t) / 1000;
        milli = histim.milltm;
        return milli;
    }
    
    setHisDataMap(nTagID, GetDataKey, getData){
        this.clearOverData();
        let time = new Date(GetDataKey.tTime * 1000).toLocaleString('chinese', { hour12: false });
        time = time + ":" + GetDataKey.nMilli + "";
        let tim = Date.parse(time);
        let key = "" + nTagID + "-" + tim + "";
        //this.myMap.set(key, getData.fDat);
        this.myMap.set(key, getData);
        return this.myMap;
    }
    
    findIndex(V1, findBgn, V2, nSize, bAfter){
        let nBgn = 0;
        let nEnd = nSize-1;
        let nComp = this.myDifftimeEx(V1[nBgn + findBgn].time,V2.time);
        if (nComp > 0)
            return nBgn;
        else if (nComp == 0)
            return bAfter ? nBgn : nBgn + 1;
        nComp = this.myDifftimeEx(V1[nEnd + findBgn].time,V2.time);
        if (nComp < 0)
            return nSize;
        else if (nComp == 0)
            return bAfter ? nEnd : nEnd + 1;
        //二分法进行查找
        let nPos = 0;
        while (nBgn <= nEnd){
            nPos = parseInt((nEnd + nBgn) / 2);
            nComp = this.myDifftimeEx(V1[nPos + findBgn].time,V2.time);
            if (nComp == 0)
                return bAfter ? nPos : nPos + 1;
            else if (nComp > 0)
                nEnd = nPos - 1;
            else
                nBgn = nPos + 1;
            //记录最后一次的数据
            if (!(nBgn <= nEnd))
                return (nComp > 0) ? nPos : nPos + 1;
        }
        return 0;
    }
    
    toHisTime(tim, milli){
        let histim = {};
        let t = new Date(tim * 1000);
        histim.hour = t.getHours();
        histim.minute = t.getMinutes();
        histim.second = t.getSeconds();
        histim.milltm = milli;
        histim.rsv = t.getDate();
        return histim;
    }
    
    myCheckTime(tim){
        if ((tim.hour >= 24) || (tim.minute >= 60) || (tim.second >= 60) || (tim.milltm >= 1000))
            return false;
        return true;
    }
    
    myDifftimeEx(t1, t2){
        if((t1.rsv - t2.rsv) > 0){
            return 1;
        }
        else if((t1.rsv - t2.rsv) < 0){
            return -1;
        }
        else{
            if((t1.hour - t2.hour) > 0){
                return 1;
            }
            else if((t1.hour - t2.hour) < 0){
                return -1;
            }
            else{
                if((t1.minute - t2.minute) > 0){
                    return 1;
                }
                else if((t1.minute - t2.minute) < 0){
                    return -1;
                }
                else{
                    if((t1.second - t2.second) > 0){
                        return 1;
                    }
                    else if((t1.second - t2.second) < 0){
                        return -1;
                    }
                    else{
                        if((t1.milltm - t2.milltm) > 0){
                            return 1;
                        }
                        else if((t1.milltm - t2.milltm) < 0){
                            return -1;
                        }
                        else{
                            return 1;
                        }
                    }
                }
            }
        }
    }
    
    findHisDataMap(nTagID, getData){
        let time = new Date(getData.tTime * 1000).toLocaleString('chinese', { hour12: false });
        time = time + ":" + getData.nMilli + "";
        let tim = Date.parse(time);
        let dbKey = "" + nTagID + "-" + tim + "";
        let dbValue = {};
        if (this.myMap.has(dbKey)){
            getData = dbValue;
            return true;
        }
        return false;
    }

    checkValid(qtim,sum,szTagPar){
        if (qtim <0 || sum < 1) 
            return -1;
        const tagInfo = this.tagnoName[szTagPar];
        if(tagInfo){
            let tagno = tagInfo.tagno;
            return tagno;
        }else{
            return -1;
        }	
    }

    //报警
    parsingAlmChange(almMsg, msgLen){
        let arrAlm = [];
        if (msgLen < 12){
            return;
        }
        let bInit = (this.dbAlmReqCnt == 0);
        let nOffset = 0;
        nOffset += 4;
        this.dbAlmReqCnt = almMsg.readInt32LE(nOffset);
        nOffset += 4;
        let tagCount = almMsg.readInt32LE(nOffset);
        //没有数据变化
        if (tagCount == 0){
            return;
        }
        nOffset += 4;
        let almStruData = [];
        for (let j = 0; j < tagCount; j++) {
            let almStruDataEx = {};
            almStruDataEx.tagId = almMsg.readInt32LE(nOffset);// int    TagNo;	//点
            nOffset += 4;
            //nOffset += 4;
            almStruDataEx.almTime = almMsg.readInt32LE(nOffset);// time_t   lTime;   //时间
            nOffset += 8;
            almStruDataEx.almMilli = almMsg.readUInt16LE(nOffset) & 0x3FF;// unsigned short  iMilli:10;  //毫秒
            almStruDataEx.iackStatu = almMsg.readUInt16LE(nOffset) >> 10 & 0x3F;// unsigned short  iAck:6; 	//确认
            nOffset += 2;
            almStruDataEx.iFormat = almMsg.readInt8(nOffset)// char   iFormat; //格式
            nOffset += 1;
            almStruDataEx.iParNo = almMsg.readInt8(nOffset)// char   iParNo;  //报警类型
            nOffset += 1;
            nOffset += 4;
            almStruDataEx.iackTime = almMsg.readInt32LE(nOffset);// time_t   lTimeAck;   //时间
            nOffset += 8;
            almStruDataEx.iackMilli = almMsg.readUInt16LE(nOffset) & 0x3FF;// unsigned short  iMilliAck:10;  //毫秒
            almStruDataEx.iAckOld = almMsg.readUInt16LE(nOffset) >> 10 & 0x3F;// unsigned short  iAckOld:6; 	//确认
            nOffset += 2;
            almStruDataEx.iPrio = almMsg.readUInt16LE(nOffset);// short  iPrio;   //报警优先级
            nOffset += 2;
            nOffset += 4;
            almStruDataEx.almData = almMsg.readFloatLE(nOffset);// float  fData;	//报警值
            nOffset += 4;
            almStruDataEx.almLimit = almMsg.readFloatLE(nOffset);// float  almLimit;	//报警限值
            nOffset += 4;

            let tmp = this.readStringDescribe(almMsg,nOffset);
            //almStruDataEx.szOper = iconv.decode(tmp, 'UTF-16');// TCHAR   szOper[12]; //确认用户
            nOffset += 24;

            let tmplData = this.readStringDescribe(almMsg,nOffset);
            almStruDataEx.almDecs = iconv.decode(tmplData, 'UTF-16');// TCHAR	szDesc[64];	//报警点描述
            
            nOffset += 128;
            almStruDataEx.dwAlmNo = almMsg.readInt32LE(nOffset);// DWORD	dwAlmNo;	//报警编号
            nOffset += 4;
            nOffset += 4;
            almStruDataEx.szOperation = almMsg.readUInt16LE(nOffset);// TCHAR	szOperation[64];	//报警处理措施
            nOffset += 128;
            nOffset += 4;
            almStruData.push(almStruDataEx);
        }
        let almChangeArr = [];
        let almDataA = [];
        for (let i = 0; i < tagCount; i++){
            let almDataB = almStruData[i];
            let csKey;
            let parno = 0;
            if(almDataB.iParNo == this.PAR_RATE)
                parno = 1;
            else if (almDataB.iParNo == this.PAR_DEV)
                parno = 2;
            csKey = almDataB.tagId + "." + parno;    
            //判断报警是否改变
            almDataA = this.keyToAlmData;
            if(this.keyToAlmData[csKey]){
                //比较时间是否变化,报警类型是否变化,确认标记是否变化
                if ((almDataA.lTime == almDataB.lTime) && (almDataA.iMilli == almDataB.iMilli) && 
                    (almDataA.iParNo == almDataB.iParNo) && (almDataA.iAck == almDataB.iAck))
                    continue;
                almDataA = almDataB;
                almChangeArr.push(almDataA);
            }
            //增加报警
            else{
                almDataA = almDataB;
                this.keyToAlmData[csKey] = almDataA;
                almChangeArr.push(almDataA);
                this.dbAlmArr.push(almDataA);
                this.dbAlmCnt++;
            }
        }
        //按照时间排序
        if (almChangeArr.length){
            almChangeArr.sort(this.compare);
            this.dbAlmArr.sort(this.compare);
            var t = "";
            for(var i = 0;i < this.dbAlmArr.length;i++){
                var obj = this.dbAlmArr[i];
                t += obj.lTime;
                t += "-"
                t += obj.iMilli;
                t += "* "
            }
            //console.log(t);
        }
        let bufInfo = {};
        bufInfo.Type = this.CMD_TYPE_ALM;
        bufInfo.almType = bInit;
        bufInfo.Data = almChangeArr.length;
        bufInfo.almChgData = almChangeArr;
        arrAlm.push(bufInfo);
        this.callbackAlmChange(arrAlm);
    }

    //解析订阅实时数据
    parsingDbChange(recvMsg, recvMsgLen){
        //判断长度
        if (recvMsgLen < 4){
            return;
        }
        let nOffset = 0;
        let tagCount = recvMsg.readInt32LE(nOffset);
        nOffset += 4;
        let lData = 0;
        //没有变化数据
        if (tagCount == 0){
            return;
        }
        //开辟内存
        let dbTagNo = [];
        let dbData = [];
        let btType = 0;
        //将数据压入缓存
        let arrData = [];
        for (let i = 0; i < tagCount; i++){
            //记录点序号
            dbTagNo[i] = recvMsg.readInt32LE(nOffset);
            nOffset += 4;
            let nTagNo = dbTagNo[i] & 0xffffff;
            const element = this.dbTagArr[nTagNo];
            if(!element){
                break
            }
            const nRegInfo = this.regTagNoObj[dbTagNo[i]];
            if(!nRegInfo){
                break
            }
            //按照类型处理
            btType = recvMsg.readInt8(nOffset);
            nOffset += 1;
            if (btType == this.DBCOMM_DBTAGTYPE_LONG){          
                let tmp = recvMsg.readInt8(nOffset);
                nOffset += 1;
                lData = recvMsg.readInt32LE(nOffset);
                nOffset += tmp;
                dbData.push({name:element.TagName,regID:nRegInfo.ragNo,data:lData,time:Date.parse(new Date()),quality:'good'});
            }
            else if (btType == this.DBCOMM_DBTAGTYPE_DOUBLE){
                let tmp = recvMsg.readInt8(nOffset);
                nOffset += 1;
                lData = recvMsg.readDoubleLE(nOffset);
                nOffset += tmp;
                //dbData.push(lData);
                dbData.push({name:element.TagName,regID:nRegInfo.ragNo,data:lData,time:Date.parse(new Date()),quality:'good'});
            }
            else if (btType == this.DBCOMM_DBTAGTYPE_STR){
                let tmp = recvMsg.readInt8(nOffset);
                nOffset += 1;
                lData = this.readString(recvMsg,nOffset);
                let csbuf = iconv.decode(lData, 'gbk');
                nOffset += tmp;
                //dbData.push(csbuf);
                dbData.push({name:element.TagName,regID:nRegInfo.ragNo,data:csbuf,time:Date.parse(new Date()),quality:'good'});
            }
            for(let j = 0; j < DB.regNoInfo.length; j++){
                if(nRegInfo.ragNo == DB.regNoInfo[j].ragNo)
                {
                    arrData.push({name:dbData[i].name,regId:dbData[i].regID,data:dbData[i].data,time:dbData[i].time,quality:dbData[i].quality});
                }
            }
        }
		console.log(arrData);
        this.callbackDataChange(arrData);
    }
}

module.exports = {

    "localMethod":{
        "getPacketType":function(pkage){
            if(pkage.length == 20){
                return pkage.readInt16LE(12);
            }else{
                return pkage.readInt16LE(32 + 16);
            }
            
        },
        //方法必须存在
        "unknownPacket":function(pkage){
            if (pkage.readUInt32LE(12) == DB.PACK_TYPE_STAT){
                let packType = (DB.dbRegTagCnt == 0) ? DB.Node.FUC_HANDLE_EX : DB.Node.FUC_DBCOMM_UPDATE_EX;
                let Len = 0;
                let heartBuf;
                let csHeart = DB.getPackBuf(DB.NET_USER_MANAGER, packType, DB.dbAlmReqCnt, 6, 0,5, null, 0, heartBuf, Len);
                return csHeart;
            }
        },
        "getHisFromFile":async function(arrInfo){
            let arrData =[];
            let startTim = {};
            startTim.tTime = Date.parse(arrInfo.beginTime) / 1000;
            startTim.nMilli = Date.parse(arrInfo.beginTime) - startTim.tTime * 1000;
            //专家报表保持一致的时间切分模式
            let bSplitYear = false;
            let timeSplit = new Date(startTim.tTime * 1000);
            let tmp = "" + (timeSplit.getFullYear() + 1) + "-" + ((timeSplit.getMonth() + 1) <= 9 ? '0' + (timeSplit.getMonth() + 1) : (timeSplit.getMonth() + 1)) + "-" + (timeSplit.getDate() < 10 ? '0' + timeSplit.getDate() : timeSplit.getDate()) + " "  + timeSplit.getHours()  + ":" + timeSplit.getMinutes()  + ":" + timeSplit.getSeconds() + "";
            let tim = Date.parse(tmp) / 1000;
            bSplitYear = (arrInfo.qtim == tim - startTim.tTime);
            bSplitYear = bSplitYear && (arrInfo.sum == 12);
            //定义年和月变量
            let nYear = timeSplit.getFullYear(), nMonth = timeSplit.getMonth(), nDay = timeSplit.getDate();
            //记录各个链表的初始位置
            let datapos = [];
            //将数据设置为-9999
            for (let i = 0;i < arrInfo.szTagPar.length;i++){
                nYear = timeSplit.getFullYear();
                nMonth = (timeSplit.getMonth() + 1) <= 9 ? '0' + (timeSplit.getMonth() + 1) : (timeSplit.getMonth() + 1);
                let dataList = [];
                for (let j = 0; j < arrInfo.sum; j++){
                    let getData = {};
                    getData.fDat = this.BADFLOAT;
                    if (!bSplitYear){
                        let delta = (arrInfo.qtim * j * 1000) / arrInfo.sum + startTim.nMilli;
                        getData.tTime = startTim.tTime + (delta / 1000);
                        getData.nMilli = (delta / 1000 - delta / 1000) * 1000;
                    }
                    else{
                        //如果月份超过了12，那么年份就加1
                        if (nMonth > 12){
                            nYear++;
                            nMonth = 1;
                        }
                        nDay = timeSplit.getDate();
                        switch (nMonth){
                        case 2:{
                                if ((nDay == 30) || (nDay == 31) || (nDay == 29)){
                                    //计算润年
                                    if ((((nYear % 4)==0) && ((nYear % 100) != 0)) || ((nYear % 400) == 0))
                                        nDay = 29;
                                    else
                                        nDay = 28;
                                }
                            }
                            break;
                        case 4:
                        case 6:
                        case 9:
                        case 11:{
                                //小月
                                if (nDay == 31)
                                    nDay = 30;
                            }
                            break;
                        }
                        let t = "" + nYear + "-" + nMonth + "-" + nDay + " "  + timeSplit.getHours()  + ":" + timeSplit.getMinutes()  + ":" + timeSplit.getSeconds() + "";
                        getData.tTime = Date.parse(t) / 1000;			
                        getData.nMilli = 0;
                        //月份加1
                        nMonth++;
                    }		
                    dataList.push(getData);			
                }
                datapos.push(dataList);
            }
            //判断时间有效性
            if(startTim.tTime < 0){
                startTim.tTime = 0;
            }
            //换算点名到ID
            let tagno = [];
            let csErrTag = "";
            for (let i = 0;i < arrInfo.szTagPar.length;i++){
                //获取点名
                let tagpar;
                tagpar = arrInfo.szTagPar[i];
                //获取ID
                let nIndex = DB.checkValid(arrInfo.qtim,arrInfo.sum,tagpar);
                if(nIndex < 0){
                    csErrTag += tagpar;
                    csErrTag += " ";
                }
                tagno.push({index:nIndex,name:tagpar});
            }
            //获取数据
            let GetArr = [];
            let tr = new Date(startTim.tTime * 1000);
            let tmp1 = "" + tr.getFullYear() + "-" + ((tr.getMonth() + 1) <= 9 ? '0' + (tr.getMonth() + 1) : (tr.getMonth() + 1)) + "-" + (tr.getDate() < 10 ? '0' + tr.getDate() : tr.getDate()) + " 00:00:00";
            let nOldDay = Date.parse(tmp1) / 1000;
            let date = new Date();
            let nToDay = date.getTime() / 1000;
            nYear = timeSplit.getFullYear();
            nMonth = (timeSplit.getMonth() + 1) <= 9 ? '0' + (timeSplit.getMonth() + 1) : (timeSplit.getMonth() + 1);
            nDay = timeSplit.getDate();
            for(let i = 0; i < arrInfo.sum; i++){
                let getData = {};
                getData.fDat = DB.BADFLOAT;
                if (!bSplitYear){
                    let delta = (arrInfo.qtim * i * 1000) / arrInfo.sum + startTim.nMilli;
                    getData.tTime = startTim.tTime + (delta / 1000);
                    getData.nMilli = (delta/1000 - delta / 1000) * 1000;
                }
                else{
                    //如果月份超过了12，那么年份就加1
                    if (nMonth > 12){
                        nYear++;
                        nMonth = 1;
                    }
                    nDay = timeSplit.getDate();
                    switch (nMonth){
                    case 2:
                        {
                            if ((nDay == 30) || (nDay == 31) || (nDay == 29)){
                                //计算润年
                                if ((((nYear % 4) == 0) && ((nYear % 100) != 0)) || ((nYear % 400) == 0))
                                    nDay = 29;
                                else
                                    nDay = 28;
                            }
                        }
                        break;
                    case 4:
                    case 6:
                    case 9:
                    case 11:{
                            //小月
                            if (nDay == 31)
                                nDay = 30;
                        }
                        break;
                    }
                    let tmp3 = "" + nYear + "-" + nMonth + "-" + nDay + " "  + timeSplit.getHours()  + ":" + timeSplit.getMinutes()  + ":" + timeSplit.getSeconds() + "";
                    getData.tTime = Date.parse(tmp3) / 1000;	
                    getData.nMilli = 0;
                    //月份加1
                    nMonth++;
                }
                //天数发生变化
                let tn = new Date(getData.tTime * 1000);
                let nDaytmp = "" + tn.getFullYear() + "-" + ((tn.getMonth() + 1) <= 9 ? '0' + (tn.getMonth() + 1) : (tn.getMonth() + 1)) + "-" + (tn.getDate() < 10 ? '0' + tn.getDate() : tn.getDate()) + " 00:00:00";
                let nDay = Date.parse(nDaytmp) / 1000;
                if (nDay != nOldDay){
                    //读取数据
                    arrData = DB.readListFromFile(nOldDay,GetArr);
                    nOldDay = nDay;
                }
                let nDataIndex = 0;
                for (let j = 0; j < arrInfo.szTagPar.length; j++){
                    //点不存在
                    if (tagno[j] < 0)
                        continue;
                    //新建对象
                    let pGet = {};
                    if (GetArr.length < nDataIndex + 1){
                        // pGet = new CHisDataGet;
                        pGet.m_nIndex = tagno[j].index;
                        GetArr.push(pGet);
                    }
                    else{
                        pGet = GetArr[nDataIndex];
                    }
                    nDataIndex++;
                    //CHisDataBuf *pHisDataBuf = m_pHisIndex.m_pBuf + pGet.m_nIndex;
                    ////获取缓存指针
                    let poslist = datapos[j];
                    pGet.m_DataGetFile = poslist;
                }
            }
            //读取
            arrData = await DB.readListFromFile(nOldDay,GetArr);
            let dataRetu = [];
            for (let i = 0; i < tagno.length; i++) {
                let data = [];
                const element1 = arrData[i];
                if(element1.m_nIndex == tagno[i].index){
                    element1.m_nIndex = tagno[i].name;
                }
                dataRetu.push({index:element1.m_nIndex,data:data});
                for (let j = 0; j < arrData[i].m_DataGetFile.length; j++) {
                    const element = arrData[i].m_DataGetFile[j];
                    data.push(element.fDat);    
                }
            }
            return dataRetu;
        },
        "getTagCount":function(){
            // return DB.dbTagCnt;
            return {
                retCode:true,
                count:DB.dbTagCnt
            }
        },
        "getRegCount":function(){
            // return DB.dbRegTagCnt;
            return {
                retCode:true,
                count:DB.dbRegTagCnt
            }
        },
        "isWorking":function(){
            //  return DB.isWork;
            return {
                retCode:true,
                count:DB.dbRegTagCnt
            }
        },
        "getClientID":function(){
            return DB.clientID;
        },
        "getAlmCount":function(){
            // return DB.dbAlmCnt;
            return {
                retCode:true,
                count:DB.dbAlmCnt
            }
        },

        //获取类型个数
        "getTypeCount":function(){
            // return DB.tagTypeArr.length;
            return {
                retCode:true,
                count:DB.tagTypeArr.length
            }
        },

        "getMarkupLayStr":function(){
            return DB.dbXmlInfo;
        },
        //获取层结构数组
        "getLayer": function(){
            let layerArr = [];
            for (let i = 0; i < DB.arrTreeInfo.length; i++) {
                const element = DB.arrTreeInfo[i];     
                let name = element.Parent.length == 0 ? element.Name : element.Parent + "\\" + element.Name;
                layerArr.push({layerName:name,layerId:element.NodeID})
            }
            // return layerArr;
            return {
                retCode:true,
                arrInfo:layerArr
            }
        },

        //获取层结构信息Json
        "getLayerInfo": function(){
            let temp;
            xml2js.parseString(DB.dbXmlInfo, {explicitArray : false}, function (err, result) {
                let strRes = JSON.stringify(result);
                let str1 = strRes.replace(/\"\$\"\:\{([a-zA-Z0-9-\u4e00-\u9fa5\\"\:\,\_]+)\}/g,function(m,g1,g2,g3){//保留字符
                    return g1;
                });
                let layers = str1.replace(/LAYER/g,"children");               
                let rJson = JSON.parse(layers);
                temp =  rJson.DbManger;
                return rJson.DbManger;
            }); 
            return temp;
        },
        "getAllTagType": function(){
            let temp;
            
            return temp;
        },

        //获取点名
        "getTagName":function(arrTagNo){
            let arrName = [];
            for (let i = 0; i < arrTagNo.length;i++) {
                const element = DB.dbTagArr[arrTagNo[i]];
                if(element){
                    arrName.push({tagId:arrTagNo[i],tagName:element.TagName});
                }        
            }
            return arrName;
        },

        //获取点所有信息
        "getTagInfoEx":function(nCount){
            let arrTagInfo = [];
            if(nCount == -1){
                nCount = this.getTagCount();
            }
			
			console.log("ncount=",nCount);
            for (let i = 0; i < nCount.count; i++) {
                const element = DB.dbTagArr[i];
                if(element){
                    arrTagInfo.push({tagId:element.TagNo,tagName:element.TagName,tagLay:element.TagArea,tagType:element.tagKind});
                }
            }
            return arrTagInfo;
        },

        "getAlarmAck":function(jsonInfo){
            console.log("fc系列暂不支持报警确认接口");
            return false;
        },
        "getHisAlarmInfo":function(jsonInfo){
            console.log("fc系列暂不支持历史报警接口");
            return false;
        },
        "getHisReadProcessed":function(jsonInfo){
            console.log("fc系列暂不支持历史统计接口");
            return false;
        },
        //获取点名+参数名
        "getDbTagParName":function(arrTagParNo){
            let arrTagName = [];
            for (let i = 0; i < arrTagParNo.length; i++){
                const tagInfo = DB.dbTagArr[arrTagParNo[i].tagId];
                if (tagInfo) {
                    let arrTypeInfo = DB.tagTypeArr[tagInfo.tagKind]; 
                    let tagParObj = arrTypeInfo.parNoToObj[arrTagParNo[i].parId];
                    if(tagParObj){
                        arrTagName.push({tagId:arrTagParNo[i].tagId, parId:arrTagParNo[i].parId,
                                        dbName:tagInfo.TagName + "." + tagParObj.parName });
                    }
                }
            }
            return arrTagName;
        },

        //
        "getDbTagId":function(arrTagName){
            let arrpParNo = [];
            for (let i = 0; i < arrTagName.length; i++){
                //解析点名，参数名
                const element = DB.dbTagObj[arrTagName[i]];        
                if(element){
                    let csTmpname = element.tagKind + ".PV";
                    if(DB.tagTypeArr[element.tagKind]){
                        let a = DB.tagTypeArr[element.tagKind].tagParToObj[csTmpname].parId;
                        arrpParNo.push({tagName:arrTagName[i],parId:a,tagId:element.TagNo});
                    }   
                }
            }
            return arrpParNo;
        },

        //
        "getDbTagType":function(arrTagName){
            let arrpDbTagType = [];
            for (let i = 0; i < arrTagName.length; i++){
                const element = DB.dbTagObj[arrTagName[i]];
                if(element){
                    let csTmpname = element.tagKind + ".PV";
                    if(DB.tagTypeArr[element.tagKind]){
                        let a = DB.tagTypeArr[element.tagKind].tagParToObj[csTmpname].tagKind;
                        arrpDbTagType.push({tagName:arrTagName[i],dbTagType:a});
                    } 
                }
            }
            return arrpDbTagType;    
        },

        //获取点TagNo数组
        "getTagNo":function(arrTagName){
            let arrpTagNo = [];
            for (let i = 0; i < arrTagName.length; i++){
                const element = DB.dbTagObj[arrTagName[i]];
                if(element){
                    arrpTagNo.push({tagName:arrTagName[i],tagId:element.TagNo});
                }
            }
            return arrpTagNo;  
        },

        //获取m_nTagArea数组
        "getTagLay":function(arrTagNo){
            let arrpTagLay = [];
            for (let i = 0; i < arrTagNo.length; i++){
                arrTagNo[i] = (arrTagNo[i] != undefined) ? arrTagNo[i] : this.parent.nameToTagNo(arrTagNo[i]);
                const element = DB.dbTagArr[arrTagNo[i]];
                if(element){
                    arrpTagLay.push({tagId:arrTagNo[i],tagArea:element.TagArea});
                }        
            }
            return arrpTagLay;  
        },

        //获取m_nTagKind数组
        "getTagType":function(arrTagNo){
            let arrpTypeNo = [];
            for (let i = 0; i < arrTagNo.length; i++){
                arrTagNo[i] = (arrTagNo[i] != undefined) ? arrTagNo[i] : this.parent.nameToTagNo(arrTagNo[i]);
                const element = DB.dbTagArr[arrTagNo[i]];
                if(element){
                    arrpTypeNo.push({tagId:arrTagNo[i],typeId:element.tagKind});
                }
            }
            return arrpTypeNo;
        },

        //获取pParCount数组
        "getParCount":function(typeId){
            let arrParCount = [];
            for (let i = 0; i < typeId.length; i++) {
                const element = DB.tagTypeArr[typeId[i]];
                if(element){
                    arrParCount.push({typeId:typeId[i],parCount:element.arr.length});
                }
            }
            return arrParCount;
        },

        //typeId = [1,[1]]
        "getTypeInfo":function(typeId){
            let arrpParCount = [];
            for (let i = 0; i < typeId.length; i++){
                const element = DB.tagTypeArr[typeId[i]];
                if(element){
                    arrpParCount.push({typeId:typeId[i],arrParCount:element.arr.length});
                }    
            }
            return arrpParCount;
        },

        //let arrtypeparcnt = {typeId:1, parCount:4};
        "getParInfo":function(arrtypeparcnt){
            let arrNoTypeName = [];
            if(DB.tagTypeArr[arrtypeparcnt.typeId]){
                for (let i = 0; i < arrtypeparcnt.parCount; i++){
                    if(i >= this.dbTagCnt){
                        continue;
                    }
                    const element = DB.tagTypeArr[arrtypeparcnt.typeId].arr[i];
                    if(element){
                        arrNoTypeName.push({parName:element.parName,parType:element.tagKind,parId:element.parId});
                    }      
                }
            }
            return arrNoTypeName; 
        },

        //let arrtypename = {typeId:1,parName:["PV","DESC"]}
        "getParNo":function(arrtypename){
            let arrpParNo = [];
            if(DB.tagTypeArr[arrtypename.typeId]){
                for (let i = 0; i < arrtypename.parName.length; i++)
                {
                    const element = DB.tagTypeArr[arrtypename.typeId].parNameToObj[arrtypename.parName[i]];
                    if(element){
                        arrpParNo.push({parName:arrtypename.parName[i],parType:element.parId});
                    }       
                }
            }
            return arrpParNo; 
        },
        
         //let arrtypepar = {typeId:1, parId:[1,2,11]};
        "getParName":function(arrtypepar){
            let arrpParName = [];
            if(DB.tagTypeArr[arrtypepar.typeId]){
                for (let i = 0; i < arrtypepar.parId.length; i++){
                    const element = DB.tagTypeArr[arrtypepar.typeId].parNoToObj[arrtypepar.parId[i]];
                    if(element){
                        arrpParName.push({parId:arrtypepar.parId[i],parName:element.parName});
                    }       
                }
            }
            return arrpParName; 
        },

        //let arrtypepar = {typeId:1,parId:[1,8,6]};
        "getParType":function(arrtypepar){
            let arrpParType = [];
            if(DB.tagTypeArr[arrtypepar.typeId]){
                for (let i = 0; i < arrtypepar.parId.length; i++){
                    const element = DB.tagTypeArr[arrtypepar.typeId].parNoToObj[arrtypepar.parId[i]];
                    if(element){
                        arrpParType.push({parId:arrtypepar.parId[i],parType:element.tagKind});
                    }       
                }
            }
            return arrpParType; 
        },

        //获取报警信息
        "getAlarmByArea":function(areaId){
            let arrAlmBuf = [];
            for (let i = 0; i < DB.dbAlmArr.length; i++){
                let almData = {};
                const dataBuf = DB.dbAlmArr[i];
                const tagInfo = DB.dbAlmArrInfo[dataBuf.tagId];
                if (!tagInfo){
                    continue ;
                }  
                if(!dataBuf){
                    continue ;
                }
                almData.tagId = dataBuf.tagId;
                almData.almTime = dataBuf.almTime;
                almData.iackTime = dataBuf.iackTime;
                almData.almMilli = dataBuf.almMilli;
                almData.iackMilli = dataBuf.iackMilli;
                almData.iackStatu = dataBuf.iackStatu;
                //almData.iAckOld = dataBuf.iAckOld;
                //almData.iParNo = dataBuf.iParNo;
                almData.iPrio = dataBuf.iPrio;
                //almData.fData = dataBuf.fData;
                //almData.fLimit = dataBuf.fLimit;
                //almData.almGroup = tagInfo.cGroup;
                almData.iUnit = tagInfo.nUnit;
                //almData.szOper = dataBuf.szOper;
                almData.tagName = tagInfo.csTagName;
                almData.almDecs = dataBuf.almDecs;
                //almData.szOperation = dataBuf.szOperation;
                let nPos = 0;
                if (tagInfo.cType == 1){
                    almData.almData = tagInfo.arrInfoStr[(dataBuf.almData > 0.5) ? 1 : 0];
                    almData.almLimit = tagInfo.arrInfoStr[2];
                    almData.almType = tagInfo.arrInfoStr[3];
                    nPos = 4;
                }
                else{
                    almData.almData = dataBuf.almData.toFixed(dataBuf.iFormat);
                    almData.almLimit = dataBuf.almLimit.toFixed(dataBuf.iFormat);
                    let maskper = [5,6,7,8,4,3,2,9,10,11];
                    let parId = 0;
                    if(dataBuf.iParNo == DB.PAR_RATE)
                        parId = 1;
                    else if (dataBuf.iParNo == DB.PAR_DEV)
                        parId = 0;
                    else if ((dataBuf.iParNo >= DB.PAR_LL) && (dataBuf.iParNo <= DB.PAR_HH))
                        parId = maskper[dataBuf.iParNo - DB.PAR_LL];
                    else if ((dataBuf.iParNo >= DB.PAR_L3) && (dataBuf.iParNo <= DB.PAR_L5))
                        parId = maskper[dataBuf.iParNo - DB.PAR_L3 + 4];
                    else if ((dataBuf.iParNo >= DB.PAR_H3) && (dataBuf.iParNo <= DB.PAR_H5))
                        parId = maskper[dataBuf.iParNo - DB.PAR_H3 + 7];
                        almData.almType = tagInfo.arrInfoStr[parId];
                    nPos = 12;
                }
                almData.almInof = almData.almType + ":" + "限值:" + almData.almLimit + "测量值:" + almData.almData;
                for (let i = 0; i < 10; i++){
                    almData.szInfo = [];
                    almData.szInfo.push(tagInfo.arrInfoStr[nPos + i]);
                } 	

                let tagName = [];
                for (let j = 0; j < areaId.length; j++) {
                    for(let i = 0; i < DB.arrData.length; i++){
                        if(areaId[j] ==  DB.arrData[i].nodeId){
                            tagName.push({tagId:DB.arrData[i].tagId});
                        }
                    }
                }
                for(let j = 0; j < tagName.length; j++){
                    if(tagName[j].tagId == almData.tagId){
                        arrAlmBuf.push(almData);
                    }
                }
            }
            return arrAlmBuf; 
        },

        "nameToTagNo":function(name){
            let tmp = [];
            tmp.push(name);
            let tmp2 = this.getTagNo(tmp);
            if (!tmp2.length) {
                return undefined;
            }
            return tmp2[0].tagId;
        },
    
        "getTagInfo":function(arrId){
            let tagName = [];
            for(let i = 0; i < arrId.length; i++){
                for (let j = 0; j < DB.arrData.length; j++) {
                    if(arrId[i] ==  DB.arrData[j].nodeId){
                        tagName.push({tagId:DB.arrData[j].tagId,tagName:DB.arrData[j].tagName,tagShortName:DB.arrData[j].tagShortName});
                    }
                }
            }
            return tagName;
        },
        "login":async function(){
            await this.login1();
            await this.heartBeat();
            return true;
        },
    },
    "remoteMethod":{
        "login1":class{
            constructor(){
                this.packetType = 6;
            };
            serilize(jsonObj){
                if(!DB){
                    return;
                }
                let sendMsg = DB.getPackBuf(DB.NET_USER_MANAGER, DB.Node.FUC_TAG_INI, -2000, 16, 0, 3, "", 0, "", 0);
                return sendMsg;
            };
            unserilize(data){
                if(data.readInt16LE(16 + 6) > 0){
                    DB.clientID =  data.readInt16LE(16 + 6);
                    //是否工作
                    DB.setWorking(data.readInt16LE(16 + 34) != 0);
                    //初始化数据库映射
                    let Package = data.slice(16 + 64);
                    let buffer = zlib.unzipSync(Package.slice(4));            
                    return DB.initDbMap(buffer,this.parent);
                }//未授权
                else if(data.readInt16LE(16 + 6) == this.REGISTER_ERR_NOAUTH){
                    console.log("未授权。。。。");
                }
            };
        },
        "getHisAlarmInfo":class{
            constructor(){
                this.packetType = [4,2];
            };
            serilize(jsonObj){
                let nPos = 0;
                let t1 = Date.parse(jsonObj.beginTime) / 1000;
                let t2 = Date.parse(jsonObj.endTime) / 1000;
                let dataBuf = Buffer.alloc(24 + jsonObj.tagIds.length * 500 * 2);
                let hisValueBuf = Buffer.alloc(24);
                hisValueBuf.writeInt32LE(t1,0);//time_t lBeginTime;//开始时间
                hisValueBuf.writeInt32LE(t2 - t1,8);//time_t lSpan;//时间长度
                hisValueBuf.writeInt32LE(jsonObj.count,16);//long lCount;//请求的数据个数
                nPos = 24;
                for (let i = 0; i < jsonObj.tagIds.length; i++){
                    jsonObj.tagIds[i].tagId = (jsonObj.tagIds[i].tagId != undefined) ? jsonObj.tagIds[i].tagId : this.parent.nameToTagNo(jsonObj.tagIds[i].tagName);
                    jsonObj.tagIds[i].parId = (jsonObj.tagIds[i].parId != undefined) ? jsonObj.tagIds[i].parId : 13;
                    if(jsonObj.tagIds[i].tagId == undefined){
                        continue;
                    }
                    const element = DB.dbTagArr[jsonObj.tagIds[i].tagId];
                    let par;
                    if(!element){
                        continue;
                    }
                    if(DB.tagTypeArr[element.tagKind]){
                        par = DB.tagTypeArr[element.tagKind].parNoToObj[jsonObj.tagIds[i].parId];
                        if(!par){
                            continue;
                        }
                    }
                    let csTmpAdd = element.TagName + "." + par.parName;
                    //记录点名称
                    dataBuf.write(csTmpAdd,nPos);
                    nPos += element.TagName.length + par.parName.length + 2;
                    this.hisSend.push({count:jsonObj.count,name:element.TagName,tagId:jsonObj.tagIds[i].tagId});
                }
                hisValueBuf.writeInt32LE(this.hisSend.length,20);//long lTagCount;//点个数
                hisValueBuf.copy(dataBuf, 0);
                //调用发送函数
                let sendBuf;
                let Len = 0;
                let csBuf = DB.getPackBuf(DB.NET_ALM_REQ, 2, 0, this.parent.getClientID(), 3, 31, dataBuf, nPos, sendBuf, Len);
                dataBuf.copy(csBuf, 80);
                return sendMsg;
            };
            unserilize(data){
            };
        }, 
        "getHisData":class{
            constructor(){
                this.hisSend = [];
                this.packetType = 12;
            };
            serilize(jsonObj){
                this.hisSend = [];
                let nPos = 0;
                let t1 = Date.parse(jsonObj.beginTime) / 1000;
                let t2 = Date.parse(jsonObj.endTime) / 1000;
                let dataBuf = Buffer.alloc(24 + jsonObj.tagIds.length * 500 * 2);
                dataBuf.writeInt32LE(t1,nPos);//time_t lBeginTime;//开始时间
                nPos += 8;
                dataBuf.writeInt32LE(t2 - t1,nPos);//time_t lSpan;//时间长度
                nPos += 8;
                dataBuf.writeInt32LE(jsonObj.count,nPos);//long lCount;//请求的数据个数
                nPos += 8;
                for (let i = 0; i < jsonObj.tagIds.length; i++){
                    jsonObj.tagIds[i].tagId = (jsonObj.tagIds[i].tagId != undefined) ? jsonObj.tagIds[i].tagId : this.parent.nameToTagNo(jsonObj.tagIds[i].tagName);
                    jsonObj.tagIds[i].parId = (jsonObj.tagIds[i].parId != undefined) ? jsonObj.tagIds[i].parId : 13;
                    if(jsonObj.tagIds[i].tagId == undefined){
                        continue;
                    }
                    const element = DB.dbTagArr[jsonObj.tagIds[i].tagId];
                    let par;
                    if(!element){
                        continue;
                    }
                    if(DB.tagTypeArr[element.tagKind]){
                        par = DB.tagTypeArr[element.tagKind].parNoToObj[jsonObj.tagIds[i].parId];
                        if(!par){
                            continue;
                        }
                    }
                    let csTmpAdd = element.TagName + "." + par.parName;
                    //记录点名称
                    dataBuf.write(csTmpAdd,nPos);
                    nPos += element.TagName.length + par.parName.length + 2;
                    this.hisSend.push({count:jsonObj.count,name:element.TagName,tagId:jsonObj.tagIds[i].tagId});
                }
                dataBuf.writeInt32LE(this.hisSend.length,20);//long lTagCount;//点个数
                //调用发送函数
                let sendBuf;
                let Len = 0;
                let csBuf = DB.getPackBuf(DB.NET_USER_MANAGER, DB.Node.FUC_GETHISDATA, 0, this.parent.getClientID(), 3, 31, dataBuf, nPos, sendBuf, Len);
                dataBuf.copy(csBuf, 80);
                return csBuf;
            };
            unserilize(data){
                let hisValue = [];
                let nOffset = 16 + 64;
                let DataBuf = data.slice(nOffset);
                //解析数据
                for (let i = 0; i < this.hisSend.length; i++) {
                    const element = this.hisSend[i];
                    hisValue.push({name:element.name,values:[]}); 
                }
                for (let i = 0; i < DataBuf.length / 4; i++){
                    let dataGet = data.readFloatLE(nOffset);
                    nOffset += 4;
                    let a = parseInt(i / this.hisSend[0].count);
                    hisValue[a].values.push(dataGet);        
                }
                return hisValue;
            };
        },
       
        "getData":class{
            constructor(){
                this.realDataSend = [];
                this.packetType = 17;
            };
            serilize(jsonObj){
                this.realDataSend = [];		
                let nCount = 0;
                let nPos = 0;
                let dataBuf = Buffer.alloc(4 + jsonObj.length * 4 * 2);
                nPos += 4;
                for(let i = 0; i < jsonObj.length; i++){
                    if (jsonObj[i].tagId == undefined) {
                        jsonObj[i].tagId = this.parent.nameToTagNo(jsonObj[i].tagName);
                        if(!jsonObj[i].tagId){
                            continue;
                        }
                    }
                    const element = DB.dbTagArr[jsonObj[i].tagId];
                    if(!element){
                        continue;
                    }
                    if(DB.tagTypeArr[element.tagKind]){
                        if (jsonObj[i].parId == undefined) {
                            jsonObj[i].parId = 13;//默认查pv
                        }
                        const par = DB.tagTypeArr[element.tagKind].parNoToObj[jsonObj[i].parId];
                        if(!par){
                            continue;
                        }
                    }
                    dataBuf.writeInt32LE(jsonObj[i].tagId,nPos);
                    nPos += 4;
                    dataBuf.writeInt32LE(jsonObj[i].parId,nPos);
                    nPos += 4;
                    nCount++;
                    this.realDataSend.push({name:element.TagName,tagno:element.TagNo});
                }
                dataBuf.writeInt32LE(nCount,0);
                let sendBuf;
                let Len = 0;			
                let cstmp = DB.getPackBuf(DB.NET_USER_MANAGER, DB.Node.FUC_DBCOMM_GETDATA, 1, this.parent.getClientID(), 2, 7, dataBuf,nPos, sendBuf, Len);			
                dataBuf.copy(cstmp, 80);
                return cstmp;
            };
            unserilize(data){
                if (data.length <= 80) {
                    return;
                }
                let nOffset = 16 + 64;
                let nCount = data.readInt32LE(nOffset);
                nOffset += 4;
                let arrRealData = [];
                let lData = 0;
                let t1 = Date.parse(new Date());
                for (let i = 0; i < nCount; i++) {
                    let btType = data.readInt8(nOffset);
                    nOffset += 1;
                    if (btType == DB.DBCOMM_DBTAGTYPE_LONG){
						console.log("read long");
                        let tmp = data.readInt8(nOffset);
                        nOffset += 1;
                        lData = data.readInt32LE(nOffset);
                        nOffset += tmp;
                        arrRealData.push({tagname:this.realDataSend[i].name,value:lData,time:t1,quality:"good"});
                    }
                    else if (btType == DB.DBCOMM_DBTAGTYPE_DOUBLE){
						console.log("read double");
                        let tmp = data.readInt8(nOffset);
                        nOffset += 1;
                        lData = data.readDoubleLE(nOffset);
                        nOffset += tmp;
                        arrRealData.push({tagname:this.realDataSend[i].name,value:lData,time:t1,quality:"good"});              
                    }
                    else if (btType == DB.DBCOMM_DBTAGTYPE_STR){
						console.log("read string");
                        let tmp = data.readInt8(nOffset);
                        nOffset += 1;
                        lData = DB.readString(data,nOffset);
                        let csbuf = iconv.decode(lData, 'gbk');
                        nOffset += tmp;
                        arrRealData.push({tagname:this.realDataSend[i].name,value:csbuf,time:t1,quality:"good"});              
                    }      
                }
                return arrRealData;
            };
        },

        "getHisTrace":class{
            constructor(){
                this.packetType = 23;
            };
            serilize(jsonObj){
                let nPos = 0;
                let t1 = Date.parse(jsonObj.beginTime) / 1000;
                let t2 = Date.parse(jsonObj.endTime) / 1000;
                let dataBuf = Buffer.alloc(24 + 500);
                dataBuf.writeInt32LE(t1,nPos);//time_t lBeginTime;//开始时间
                nPos += 8;
                dataBuf.writeInt32LE(t2 - t1,nPos);//time_t lSpan;//时间长度
                nPos += 8;
                dataBuf.writeInt32LE(jsonObj.count,nPos);//long lCount;//请求的数据个数
                nPos += 4;
                dataBuf.writeInt32LE(1,20);//long lTagCount;//点个数
                nPos += 4;
                jsonObj.tagId = (jsonObj.tagId != undefined) ? jsonObj.tagId : this.parent.nameToTagNo(jsonObj.tagName);
                jsonObj.parId = (jsonObj.parId != undefined) ? jsonObj.parId : 13; 
                const element = DB.dbTagArr[jsonObj.tagId];
                let par;
                if(!element){
                    return;
                }
                if(DB.tagTypeArr[element.tagKind]){
                    par = DB.tagTypeArr[element.tagKind].parNoToObj[jsonObj.parId];
                    if(!par){
                        return;
                    }
                }
                let csTmpAdd = element.TagName + "." + par.parName;
                //记录点名称,长点名最多500字节(组点时已经限制)
                dataBuf.write(csTmpAdd,nPos);
                nPos += element.TagName.length + par.parName.length + 2;
                //调用发送函数
                let sendBuf;
                let Len = 0;
                let csBuff = DB.getPackBuf(DB.NET_USER_MANAGER, DB.Node.FUC_GETHISDATATRACE, 0, this.parent.getClientID(),3, 32, dataBuf, nPos, sendBuf, Len);
                dataBuf.copy(csBuff, 80);
                return csBuff;
            };
            unserilize(data){
                let arrHisTrace = [];
                //解析取得的数据
                let nOffset = 16 + 64;
                let nCount = data.readInt32LE(nOffset);
                nOffset += 4;
                let dataGet = {};
                //解析数据
                for (let i = 0; i < nCount; i++){
                    let a = data.readInt32LE(nOffset);
                    dataGet.values = new Date(a * 1000).toLocaleString('chinese', { hour12: false });
                    nOffset += 8;
                    dataGet.milli = data.readInt16LE(nOffset);
                    nOffset += 4;
                    dataGet.hisData = data.readFloatLE(nOffset);
                    nOffset += 4;
                    arrHisTrace.push({value:dataGet.values,milli:dataGet.milli,data:dataGet.hisData});
                }
                return arrHisTrace;
            };
        },

        "setData":class{
            constructor(){
                this.packetType = 16;
            };
            serilize(jsonObj){
                let nPos = 0;
                //缓冲区的长度: 点个数[long]+ 点个数 * (点序号[long] + 参数序号[long] + 参数类型[char] + 65[包括结束符]*sizeof(TCHAR))
                let dataBuf = Buffer.alloc(4 + jsonObj.length * (4 * 2 + 1 + 65 * 2));
                let chData = 0;
                let lData = 0;
                let dbData = 0;
                nPos += 4;
                for (let i = 0; i < jsonObj.length; i++){
                    if (!jsonObj[i].tagId) {
                        jsonObj[i].tagId = this.parent.nameToTagNo(jsonObj[i].tagName);
                    }
                    const element = DB.dbTagArr[jsonObj[i].tagId];
                    if(jsonObj[i].parId == undefined){
                        jsonObj[i].parId = 13;
                    }
                    let par;
                    if(!element){
                        break
                    }
                    if(DB.tagTypeArr[element.tagKind]){
                        par = DB.tagTypeArr[element.tagKind].parNoToObj[jsonObj[i].parId];
                        if(!par){
                            break;
                        }
                    }
                    //记录序号
                    dataBuf.writeInt32LE(jsonObj[i].tagId,nPos);
                    nPos += 4;
                    dataBuf.writeInt32LE(jsonObj[i].parId,nPos);
                    nPos += 4;
                    dataBuf.writeInt8(par.tagKind,nPos);
                    nPos += 1;
                    //记录数据
                    if (par.tagKind == DB.DBCOMM_DBTAGTYPE_LONG){
						console.log("datatype == long");
                        lData = jsonObj[i].value;
                        dataBuf.writeInt8(4,nPos);
                        nPos ++; 
                        dataBuf.writeInt32LE(lData,nPos);
                        nPos += 4;
                    }
                    else if (par.tagKind == DB.DBCOMM_DBTAGTYPE_DOUBLE){
						console.log("datatype == double");
                        dbData = jsonObj[i].value;
                        dataBuf.writeInt8(8,nPos); 
                        nPos ++; 
                        dataBuf.writeDoubleLE(dbData,nPos);
                        nPos += 8;
                    }
                    else if (par.tagKind == DB.DBCOMM_DBTAGTYPE_STR){
						console.log("datatype == string");
                        let chBuf = jsonObj[i].value;
                        chData = chBuf.length + 1;
                        dataBuf.writeInt8(chData,nPos);
                        nPos++;
                        dataBuf.write(chBuf,nPos);
                        nPos += chBuf.length;
                    }
                }
                //写入个数
                dataBuf.writeInt32LE(jsonObj.length,0);
                //调用发送函数
                let sendBuf;
                let Len = 0;
                //let bRet = getPackBuf(DB.NET_USER_MANAGER, FUC_DBCOMM_SETDATA, 1,getClientID(), GetPackNo(true), GetPackSNo(true), dataBuf, nPos, sendBuf, Len);
                let csBuff = DB.getPackBuf(DB.NET_USER_MANAGER, DB.Node.FUC_DBCOMM_SETDATA, 1,this.parent.getClientID(), 3, 20, dataBuf, nPos, sendBuf, Len);
                dataBuf.copy(csBuff, 80);
                return csBuff;
            };
            unserilize(data){
		        return true;
            };
        },

        "insertHisData":class{
            constructor(){
                this.packetType = 13;
            };
            serilize(jsonObj){
                let dataBuf = Buffer.alloc(500 + 16 * jsonObj.datas.length);
                let nPos = 0;
                jsonObj.tagId = (jsonObj.tagId != undefined) ? jsonObj.tagId : this.parent.nameToTagNo(jsonObj.tagName);
                jsonObj.parId = (jsonObj.parId != undefined) ? jsonObj.parId : 13;   
                const element = DB.dbTagArr[jsonObj.tagId];
                let par;
                if(!element){
                    return;
                }
                if(DB.tagTypeArr[element.tagKind]){
                    par = DB.tagTypeArr[element.tagKind].parNoToObj[jsonObj.parId];
                    if(!par){
                        return;
                    }
                }
                let csTmpAdd = element.TagName + "." + par.parName;
                dataBuf.write(csTmpAdd,nPos);
                nPos += element.TagName.length + par.parName.length + 2;
                for (let i = 0; i < jsonObj.datas.length; i++){
                    let time = Date.parse(jsonObj.datas[i].insertDate) / 1000;
                    dataBuf.writeInt32LE(time,nPos);
                    nPos += 8;
                    dataBuf.writeInt16LE(jsonObj.datas[i].milli,nPos);
                    nPos += 4;
                    dataBuf.writeInt32LE(jsonObj.datas[i].value,nPos);
                    nPos += 4
                }
                //调用发送函数
                let sendBuf;
                let Len = 0;
                //let csBuff = getPackBuf(DB.NET_USER_MANAGER, FUC_INSERTHISDATA, short(jsonObj.count), getClientID(),GetPackNo(true), GetPackSNo(true), dataBuf, nPos, sendBuf, Len);
                let csBuff = DB.getPackBuf(DB.NET_USER_MANAGER, DB.Node.FUC_INSERTHISDATA, (jsonObj.count & 0xFFFF), this.parent.getClientID(),3, 20, dataBuf, nPos, sendBuf, Len);
                dataBuf.copy(csBuff, 80);
                return csBuff;
            };
            unserilize(data){
                return 1;
            };
        },
      
        "subRealData":class{
            constructor(){
                this.regArr = [];
                this.packetType = 18;
            };
            serilize(jsonObj){
                this.regArr = [];
                //申请注册控件，并填充点id和点参数id
                let dataBuf = Buffer.alloc(4 + jsonObj.length * 4 * 2);
                let nPos = 4;
                let regCnt = 0;
                for (let i = 0; i < jsonObj.length; i++) {
                    const regInfo = jsonObj[i];
                    regInfo.tagId = (regInfo.tagId != undefined) ? regInfo.tagId : this.parent.nameToTagNo(regInfo.tagName);
                    regInfo.parId = (regInfo.parId != undefined) ? regInfo.parId : 13;
                    const tagInfo = DB.dbTagArr[regInfo.tagId];
                    let key = regInfo.tagId | (regInfo.parId << 24);
                    if(DB.regTagNoObj[key]){
                        DB.regTagNoObj[key].nCount += 1;
                        let RegNo = DB.regTagNoObj[key].ragNo;
                        DB.regNoInfo[RegNo].nCount += 1;
                        continue;
                    }
                    
                    if(!tagInfo){
                        continue
                    }
                    if(DB.tagTypeArr[tagInfo.tagKind]){
                        if(!DB.tagTypeArr[tagInfo.tagKind].parNoToObj[regInfo.parId]){
                            continue;
                        }
                    }
                    //记录序号
                    dataBuf.writeInt32LE(regInfo.tagId,nPos);
                    nPos += 4;
                    dataBuf.writeInt32LE(regInfo.parId,nPos);
                    nPos += 4; 
                    regCnt++;   
                    this.regArr.push(jsonObj[i])    
                }
                //包头填充个数
                dataBuf.writeInt32LE(regCnt,0);
                let sendBuf;
                let Len = 0;
                let csBuff = DB.getPackBuf(DB.NET_USER_MANAGER, DB.Node.FUC_DBCOMM_REGTAG, 1,this.parent.getClientID(), 3, 20, dataBuf, nPos, sendBuf, Len);
                dataBuf.copy(csBuff, 80);
                return csBuff;
            };
            unserilize(data){
                let tagData = [];
                let nOffset = 16 + 64;
                if (data.length <= 80) {
                    return DB.regNoInfo;
                }
                //解析取得的数据
                let nCount = data.readInt32LE(nOffset);
                nOffset += 4;
                let btType = 0;
                let lData = 0;
                for (let i = 0; i < nCount; i++){
                    btType = data.readInt8(nOffset);
                    nOffset += 1;
                    if (btType == DB.DBCOMM_DBTAGTYPE_LONG){
                        let tmp = data.readInt8(nOffset);
                        nOffset += 1;
                        lData = data.readInt32LE(nOffset);
                        nOffset += tmp;
                        //tagData.push({type:btType,data:lData});
                        tagData.push(lData);
                    }
                    else if (btType == DB.DBCOMM_DBTAGTYPE_DOUBLE){
                        let tmp = data.readInt8(nOffset);
                        nOffset += 1;
                        lData = data.readDoubleLE(nOffset);
                        nOffset += tmp;
                        //tagData.push({type:btType,data:lData});
                        tagData.push(lData);
                    }
                    else if (btType == DB.DBCOMM_DBTAGTYPE_STR){
                        let tmp = data.readInt8(nOffset);
                        nOffset += 1;
                        lData = DB.readString(data,nOffset);
                        let csbuf = iconv.decode(lData, 'gbk');
                        nOffset += tmp;
                        // tagData.push({type:btType,data:csbuf});
                        tagData.push(csbuf);
                    } 
                }
                //注册数据点
                let tmpregno = this.addRegTag(this.regArr, tagData);
                return tmpregno;
            };
            addRegTag(regArr, tagData){
                let keyTagNoAndParNo;
                let RegNo = 0;
                let nCnt = 0;
                for (let i = 0; i < regArr.length; i++) {
                    const regInfo = regArr[i];
                    const tagInfo = DB.dbTagArr[regInfo.tagId];
                    keyTagNoAndParNo = regInfo.tagId | (regInfo.parId << 24);
                    if(DB.regTagNoObj[keyTagNoAndParNo]){
                        nCnt = DB.regTagNoObj[keyTagNoAndParNo].nCount + 1;
                        RegNo = DB.regTagNoObj[keyTagNoAndParNo].ragNo;
                        DB.regTagNoObj[keyTagNoAndParNo] = {ragNo:RegNo,nCount:nCnt,DbTagNo:keyTagNoAndParNo,Data:tagData[i]};
                    }
                    else{
                        //增加注册点序号
                        RegNo = this.getRegNo ();
                        DB.dbRegTagCnt++;
                        nCnt = 1;
                        DB.regTagNoObj[keyTagNoAndParNo] = {ragNo:RegNo,nCount:nCnt,/*DbTagNo:keyTagNoAndParNo,*/Data:tagData[i]}; 
                    }
                    DB.regNoInfo[RegNo] = {regName:tagInfo.TagName,ragNo:RegNo,nCount:nCnt,Data:tagData[i]};
                }
                return DB.regNoInfo;
            }
        
            getRegNo(){
                return DB.regNoID++;
            }
        },
    
        "unSubRealData":class{
            constructor(){
                this.unRegTagArr = [];
                this.packetType = 19;
            };
            serilize(jsonObj){
                let dataBuf = Buffer.alloc(4 + jsonObj.length * 4 * 2);//sizeof(long) + TagCount * sizeof(long) * 2
                let nPos = 4;
                let nRegCount = 0;
                for (let i = 0; i < jsonObj.length; i++){
                    const regTagInfo = DB.regNoInfo[jsonObj[i]];
                    if (!regTagInfo) {
                        continue;
                    }
                    let tmpArrName = [];
                    tmpArrName.push(regTagInfo.regName);
                    let tmp  = this.parent.getDbTagId(tmpArrName);
                    
                    //记录序号
                    dataBuf.writeInt32LE(tmp.tagId,nPos);//let lData = regTagInfo.ragNo & 0xffffff;
                    nPos += 4;
                    dataBuf.writeInt32LE(tmp.parId,nPos);//lData = regTagInfo.ragNo >> 24 & 0xff;
                    nPos += 4;
                    nRegCount++;
                    this.unRegTagArr.push(jsonObj[i]);
                }
                //this.unRegTagArr = jsonObj;
                dataBuf.writeInt32LE(nRegCount,0);
                //调用发送函数
                let sendBuf;
                let Len = 0;
                //let csBuff = getPackBuf(DB.NET_USER_MANAGER, FUC_DBCOMM_UNREGTAG, 1,getClientID(), GetPackNo(true), GetPackSNo(true), dataBuf,nPos, sendBuf, Len);
                let csBuff = DB.getPackBuf(DB.NET_USER_MANAGER, DB.Node.FUC_DBCOMM_UNREGTAG, 1,this.parent.getClientID(), 3, 20, dataBuf,nPos, sendBuf, Len);
                return csBuff;
            };    

            contains(a, obj) { 
                var i = a.length; 
                while (i--) { 
                    if (a[i] === obj) { 
                    return i; 
                    } 
                } 
                return false; 
            }

            unserilize(data){
                if(data == null){
                    return;
                }
                let nRegCount = this.unRegTagArr.length;
                for (let i = 0; i < nRegCount; i++){
                    //查找是否注册点
                    if(!DB.regNoInfo[this.unRegTagArr[i]]){
                        continue;
                    }
                    //计数=1直接删掉
                    if(DB.regNoInfo[this.unRegTagArr[i]].nCount == 1){ 
                        let a = DB.regNoInfo[this.unRegTagArr[i]];
                        if(DB.regTagNoObj[a.ragNo]){
                            //delete DB.regTagNoObj[a];
                            DB.regTagNoObj.splice(a,1);
                        }
                        if(DB.regNoInfo[a.ragNo]){
                            //delete DB.regNoInfo[a.ragNo];
                            DB.regNoInfo.splice(this.contains(DB.regNoInfo,a),1);
                        }
                        
                        DB.dbRegTagCnt --;
                    }
                    else{
                        //计数减1
                        if(DB.regTagNoObj[DB.regNoInfo[this.unRegTagArr[i]].DbTagNo]){
                            DB.regTagNoObj[DB.regNoInfo[this.unRegTagArr[i]].DbTagNo].nCount--;
                        }
                        DB.regNoInfo[this.unRegTagArr[i]].nCount--;
                    }
                }
                return DB.regNoInfo;
            };
        },
      
        "unSubRealDataAll":class{
            constructor(){
                this.packetType = 22;
            };
            serilize(jsonObj){
                let sendBuf = null;
                let Len = 0;
                //let csBuff = getPackBuf(DB.NET_USER_MANAGER, DB.Node.FUC_DBCOMM_AllUNREGTAG, 0,getClientID(), GetPackNo(true), GetPackSNo(true), NULL, 0,sendBuf, Len);
                let csBuff = DB.getPackBuf(DB.NET_USER_MANAGER, DB.Node.FUC_DBCOMM_AllUNREGTAG, 0,this.parent.getClientID(), 3, 7, " ", 0,sendBuf, Len);
                return csBuff;
            };

            unserilize(data){
                if(data == null){
                    return;
                }
                //各种清理注册点序号映射
                DB.regNoInfo = [];
                DB.regTagNoObj = {};
                DB.dbRegTagCnt = 0;
                return DB.regNoInfo;
            };
        },
        "heartBeat":class{
            constructor(){
                this.packetType = [2,20,24,25,7];
            };
            serilize(jsonObj){
                if(!DB){
                    return;
                }
                let buf;
                let Len = 0;
                let packType = (this.parent.getRegCount() == 0) ? DB.Node.FUC_HANDLE_EX : DB.Node.FUC_DBCOMM_UPDATE_EX;
                let almBuf = DB.getPackBuf(DB.NET_USER_MANAGER, packType, DB.dbAlmReqCnt, this.parent.getClientID(), 0, 2, " ", 0, buf, Len);
                return almBuf;
            };
            unserilize(pkage){
                // let pkagetype = pkage.readUInt32LE(12);//没必要判断网络标识
                let type;
                if(pkage.length > 20){
                    type = pkage.readInt16LE(48);
                }
                // if(pkagetype == DB.PACK_TYPE_DATA){
                    if(type == DB.Node.FUC_DBCOMM_UPDATE_EX || type == DB.Node.FUC_DBCOMM_UPDATE){//20 25
                        DB.setWorking(pkage.readInt16LE(16 + 34) != 0);
                        if (pkage.readInt16LE(16 + 28) >= 16){								
                            let  nPos = pkage.readUInt32LE(16 + 64);									
                            //解析变化通知
                            DB.parsingDbChange(pkage.slice(16 + 64 + nPos), pkage.readInt32LE(16 + 28) - nPos);
                            DB.parsingAlmChange(pkage.slice(16 + 64), nPos);                    
                        }
                    }else if(type == DB.Node.FUC_HANDLE_EX || type == DB.Node.FUC_HANDLE){//解析第一包回来的报警数据
                        DB.setWorking(pkage.readInt16LE(16 + 34) != 0);	
                        DB.parsingAlmChange(pkage.slice(16 + 64), pkage.readInt16LE(16 + 28));                    
                    }
                // }
            };
        }
    }
};

var init = function(FRtdb,dataChange,almChange) {
    DB = new fc7();
    DB.callbackDataChange = dataChange;
    DB.callbackAlmChange = almChange;
    //设置报头
    FRtdb.conn.setHeader(16,8,4);

    //本地历史文件加载
    if(FRtdb.options.path.length > 0){//传入路径
        if((FRtdb.options.path.indexOf('\\',0)) == 0){//查找第一个字符是不是“\\”
            var smb2Client = new SMB2({
                share:FRtdb.options.path,
                domain:'DOMAIN',
                username:FRtdb.options.username,
                password:FRtdb.options.password
            });
            DB.filePath = smb2Client.fullPath;
        }else{
            DB.filePath = FRtdb.options.path;
        }
        DB.load("tagparhi.idx");      
    }

    //处理心跳
     let heart = async function(){
        FRtdb.heartBeat();
        let tmpTime = setTimeout(heart,FRtdb.options.heartBeat);
        //console.log(tmpTime.Symbol);
        // if(tmpTime){
        //     clearTimeout(tmpTime)
        // }
    }
    setTimeout(heart,FRtdb.options.heartBeat);   
};

module.exports.init = init;