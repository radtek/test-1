var iconv = require('iconv-lite');//编码
let handle = Buffer.alloc(2);
let realSubCount = 0;
let realSubCountTmp = 0;
var DB;
var isWork = false;


class ps6{
    constructor(){        
    }
}

module.exports = {
    "localMethod":{
		"getPacketType":function(pkage){
			if(this.loginPhase == 0){
                this.loginPhase = 1;
				return 2000;//虚拟功能号
			}else if(this.loginPhase == 1){
                this.loginPhase = 2;
				return 2001;
			}
			
            return pkage.readInt16LE(6,8);
        },
        "login":async function(){
            let ret;
            this.loginPhase = 0;
            ret = await this.login1();
            ret = await this.login2();
            ret = await this.login3();
            return ret; 
        },
        "loginOut":async function(){
            isWork = false;
            this.conn.socket.end();
        },
        "getRegCount":async function()
        {
            let retJson = {};
            retJson.retCode = 0;
            retJson.count = realSubCount;
            return retJson;
        },
        "isWorking":async function()
        {
            return isWork;
        },
        "getTagCount":async function(){
            let retIdsJson = await this.getTagQueryIds({'tagId':0,'queryLevel':0});
            let retLongNameJson = await this.getTagListProps({'tagIds':retIdsJson.ids,'propIds':[3]});
            let retJson = {};
            retJson.retCode = 0;
            retJson.count = retLongNameJson.tagPropList.length;
            return retJson;
        },
        "getLayer":async function(){
            let retIdsJson = await this.getTagQueryIds({'tagId':0,'queryLevel':0});
            let retJson = [];
	        let retLongNameJson = await this.getTagListProps({'tagIds':retIdsJson.ids,'propIds':[3]});
            for(let i=0; i<retLongNameJson.tagPropList.length;i++){
                let item = {};
                item.layerId = retIdsJson.ids[i];
                item.layerName = retLongNameJson.tagPropList[i][0].data;
                retJson.push(item);
	        }
            return retJson;
        },
        "getTagId":async function(arrJson){
            let retJson = await this.getIdsByLongName(arrJson);
            let retJson_ = {};
            retJson_.retCode = retJson.retCode;
            retJson_.data = [];
            if(retJson.retCode !=0){
                return retJson;
            }
            for(let i=0; i<arrJson.length;i++){
                retJson_.data[i] = {};
                retJson_.data[i].tagName = arrJson[i];
                retJson_.data[i].tagId = retJson.tagIds[i];
            }
            return retJson_;
        },
        "getLayerInfo":async function(tagId){
                let tagId_ = tagId || 0;
                getSubNodeIds = async function(db,tagId){
                return new Promise((resolve, reject) =>{
                    let run =(async function(){
                        let tagIds = [];
                        let retJson = {};
                        retJson.layerId = tagId;
                        tagIds.push(tagId);
                        let retJson_ = await db.getTagListProps({'tagIds':tagIds,'propIds':[2,11]});//短名、是否为节点
                        retJson.layerName = retJson_.tagPropList[0][0].data;
                        if(retJson_.tagPropList[0][1].data != 0){//为节点
                            retJson_ = await db.getTagQueryIds({'tagId':tagId,'queryLevel':1});//查询下面子节点
                            if(retJson_.ids.length>0){
                                retJson.childern = [];
                                for(let i=0; i<retJson_.ids.length;i++){
                                    retJson.childern[i] = await getSubNodeIds(db,retJson_.ids[i]);
                                }
                            }
                        }
                    resolve(retJson);	
                    });
                    run();
                }); 
            }

            return await getSubNodeIds(this,tagId_);
        },
        "getTagInfo":async function(tagId){
			if(tagId.length != 1){//只能获取一个节点的子节点
				return {"retCode":-1};
			}
			
            let retJson = [];
            let tagIds = [];
            tagIds.push(tagId[0]);

            if(tagId != undefined){
                let retJson_ = await this.getTagQueryIds({'tagId':tagId,'queryLevel':1});//查询下面子节点
                if(retJson_.ids.length>0){
                    let retJson__ = await this.getTagListProps({'tagIds':retJson_.ids,'propIds':[2,3,11]});//短名、长名,是否为节点
                    for(let i=0; i<retJson__.tagPropList.length;i++){
                        if(retJson__.tagPropList[i][2].data == 0){//为测点节点
                            retJson[i] = {};
                            retJson[i].tagId = retJson_.ids[i];
                            retJson[i].tagShortName = retJson__.tagPropList[i][0].data;
                            retJson[i].tagName = retJson__.tagPropList[i][1].data;
                        }
                    }

                }
            }
            return retJson;
        },
        "getHisAlarmInfo":async function(arrJson){
            let retJson = await this.getHisAlarmInfo_(arrJson);
			if(retJson.retCode !=0){
				return retJson;				
			}
			
			if(retJson.alarms == undefined){
				retJson.alarms = [];
				return retJson;
			}
			
            let tagDescriptionMap = new Map();
            for(let i=0; i<retJson.alarms.length;i++){
                if(tagDescriptionMap.get(retJson.alarms[i].tagId) == undefined){
                    let tagIds = [];
                    tagIds.push(retJson.alarms[i].tagId);
                    let retJsonDesc = await this.getTagListProps({'tagIds':tagIds,'propIds':[5]}); 
                    tagDescriptionMap.set(retJson.alarms[i].tagId,retJsonDesc.tagPropList[0][0].data);
                    retJson.alarms[i].almDesc = retJsonDesc.tagPropList[0][0].data;
                }else{
                    retJson.alarms[i].almDesc = tagDescriptionMap.get(retJson.alarms[i].tagId);
                }
            }
            return retJson;
        },
 
        "getAlarmByArea":async function(tagId){
            let tagId_ = tagId || 0;
            let tagIds = [];//子测点数组
            let retAlarms = [];//报警结果
            let retJson_ = await this.getTagQueryIds({'tagId':tagId_,'queryLevel':1});//查询下面子节点
            if(retJson_.ids.length>0){
                let retJson__ = await this.getTagListProps({'tagIds':retJson_.ids,'propIds':[11]});//是否为节点
                for(let i=0; i<retJson__.tagPropList.length;i++){
                    if(retJson__.tagPropList[i][0].data == 0){//为测点节点
                        tagIds.push(retJson_.ids[i]);
                    }
                }
            }
            for(let i=0; i<tagIds.length;i++){
                retJson__ = await this.getAlarmRealQuery({'alarmFilterField':{'tagId':1},'alarmFilter':{"tagId":tagIds[i]}});
                if(retJson__.retCode == 0){
                    if(retJson__.alarms != undefined){
                        for(let j=0; j<retJson__.alarms.length; j++){
                            retAlarms.push(retJson__.alarms[j]);
                        }
                    }
                }
            }

            let retJson = {};
            retJson.retCode = 0;
            retJson.alarmDatas = retAlarms;
            return retJson;
        },
        "getData":async function(arrJson){
            let tagIds = [];
            let tagId;
            for(let i=0; i<arrJson.length; i++){
                if(arrJson[i].tagId != undefined){
                    tagIds.push(arrJson[i].tagId);
                }else{
                    tagId = await this.getIdByLongName(arrJson[i]);
                    if(tagId.retCode !=0){
                        return tagId;
                    }
                    tagIds.push(tagId.id);
                }
            }

            let retRes = await this.getRealReadList(tagIds);
            let retJson = [];
            if(retRes.retCode !=0){

                return retRes;
            }
            for(let i=0; i<retRes.dataList.length;i++){
                retJson[i] = {};
                retJson[i].value = retRes.dataList[i].psvalue.value;
                retJson[i].time = retRes.dataList[i].time;
                retJson[i].quality = retRes.dataList[i].quality;
            }

            let retTagNames = await this.getTagListProps({'tagIds':tagIds,'propIds':[3]});
            if(retTagNames.retCode !=0){
                return retTagNames;
            }
            
            for(let i=0; i<retTagNames.tagPropList.length; i++){
                retJson[i].tagName = retTagNames.tagPropList[i][0].data;
            }

            let retJson_ = {};
            retJson_.retCode = 0;
            retJson_.data = retJson;
            return retJson_;
        },
	"unknownPacket":function(data){
		if(data){
            let type = data.readInt16LE(6,8);
            if(type == 62){//订阅返回包
                let retJson = {};
                retJson.tagCount = data.slice(17,21).readInt32LE(0);
                retJson.subscribeId = data.slice(21,25).readInt32LE(0);
                retJson.tagDataList = [];
                let pos = 25;
                let sec32 = 0;
                let mill16 = 0;
                let type = undefined;
                for(let i=0; i<retJson.tagCount; i++){
                    retJson.tagDataList[i] = {};
                    retJson.tagDataList[i].id = data.slice(pos,pos+4).readInt32LE(0);
                    pos += 5;
                    sec32 = data.slice(pos,pos+4).readInt32LE(0);
                    pos += 4;
                    mill16 = data.slice(pos,pos+2).readInt16LE(0);
                    pos += 2;
                        
                    let t = new Date(sec32*1000 + mill16);
                    retJson.tagDataList[i].pstime = t.toLocaleString();
                    type = data.slice(pos,pos+1).readInt8(0);
                    retJson.tagDataList[i].type = type;
                    pos += 1;
                    let tmp;
                    switch(type){
                        case 0:
                            retJson.tagDataList[i].value = 'null';
                            break;
                        case 1:
                            tmp = data.slice(pos,pos+1);
                            pos = pos+1;
                            retJson.tagDataList[i].value = tmp.readInt8(0);
                            break;
                        case 2:
                            tmp = data.slice(pos,pos+1);
                            pos = pos+1;
                            retJson.tagDataList[i].value = tmp.readInt8(0);
                            break;
                        case 3:
                            tmp = data.slice(pos,pos+1);
                            pos = pos+1;
                            retJson.tagDataList[i].value = tmp.readUInt8(0);
                            break;
                        case 4:
                            tmp = data.slice(pos,pos+2);
                            pos = pos+2;
                            retJson.tagDataList[i].value = tmp.readInt16LE(0);
                            break;
                        case 5:
                            tmp = data.slice(pos,pos+2);
                            pos = pos+2;
                            retJson.tagDataList[i].value = tmp.readUInt16LE(0);
                            break;
                        case 6:
                            tmp = data.slice(pos,pos+4);
                            pos = pos+4;
                            retJson.tagDataList[i].value = tmp.readInt32LE(0);
                            break;
                        case 7:
                            tmp = data.slice(pos,pos+4);
                            pos = pos+4;
                            retJson.tagDataList[i].value = tmp.readUInt32LE(0);
                            break;
                        case 8:
                            tmp = data.slice(pos,pos+8);
                            pos = pos+8;
                            retJson.tagDataList[i].value = tmp.readIntLE(0, 8);
                            break;
                        case 9:
                            tmp = data.slice(pos,pos+8);
                            pos = pos+8;
                            retJson.tagDataList[i].value = tmp.readUIntLE(0, 8);
                            break;
                        case 10:
                            tmp = data.slice(pos,pos+4);
                            pos = pos+4;
                            retJson.tagDataList[i].value = tmp.readFloatLE(0);
                            break;
                        case 11:
                            tmp = data.slice(pos,pos+8);
                            pos = pos+8;
                            retJson.tagDataList[i].value = tmp.readDoubleLE(0);
                            break;
                        case 12:
                            tmp = data.slice(pos,pos+4);
                            let tmpv1 = tmp.readInt32LE(0);
                            pos = pos+4;
                            tmp = data.slice(pos,pos+2);
                            pos = pos+2;
                            let tmpv2 = tmp.readInt16LE(0);
                            retJson.tagDataList[i].value = tmpv1*1000+tmpv2;
                            break;
                        case 13:
                            tmp = data.slice(pos,pos+4)
                            len = tmp.readInt32LE(0);
                            pos = pos+4;
                            tmp = data.slice(pos,pos+len);
                            pos = pos+len;
                            retJson.tagDataList[i].value = /*tmp.toString('utf8', 0, len)*/iconv.decode(tmp, 'gbk');
                            break;
                        case 14:
                            tmp = data.slice(pos,pos+4);
                            len = tmp.readInt32LE(0);
                            pos = pos+4;
                            tmp = data.slice(pos,pos+len*2);
                            pos = pos+len*2;
                            retJson.tagDataList[i].value = /*tmp.toString('utf8', 0, len)*/iconv.decode(tmp, 'UTF-16');
                            break;
                        case 15:
                            tmp = data.slice(pos,pos+4);
                            len = tmp.readInt32LE(0);
                            pos = pos+4;
                            tmp = Buffer.from(data.slice(pos,pos+len));
                            pos = pos+len;
                            retJson.tagDataList[i].value = tmp;
                            break;
                        default:
                            break;
                    }
                    retJson.tagDataList[i].quality = data.slice(pos,pos+2).readInt16LE(0);
                    pos+=2;
                }
                DB.callbackDataChange(retJson);
            }
		}
	},
   "setData":async function(arrJson){
    let tagIds = [];
    let tagId;
    for(let i=0; i<arrJson.length; i++){
        if(arrJson[i].tagId != undefined){
            tagIds.push(arrJson[i].tagId);
        }else{
            tagId = await this.getIdByLongName(arrJson[i]);
            if(tagId.retCode !=0){
                return {retCode:-1};
            }
           
            tagIds.push(tagId.id);
        }
    }

    let arrJson_ = {};
    arrJson_.tagIds = tagIds;
    arrJson_.dataValues = [];
    arrJson_.timeStamps = [];
    arrJson_.qualities = [];
    let retJson;
    let tagTypes = [];
    retJson = await this.getTagListProps({'tagIds':tagIds,'propIds':[13]});
    for(let i=0; i<retJson.tagPropList.length;i++){
        tagTypes[i] = retJson.tagPropList[i][0].data;
    }

    for(let i=0; i<arrJson.length; i++){
        arrJson_.dataValues[i] = {};
        arrJson_.dataValues[i].type = tagTypes[i];
        arrJson_.dataValues[i].data = arrJson[i].value;
        arrJson_.timeStamps[i] = arrJson[i].time;
        arrJson_.qualities[i] = arrJson[i].quality;
    }
    retJson = await this.getRealWriteList(arrJson_);
    if(retJson.retCode ==0 || retJson.retCode == -19997){
        return true;
    }else{
        return false;
    }
},
    "getHisData":async function(arrJson){
        if(arrJson.type == "raw"){
            let tagIds = [];
            let tagId;
            for(let i=0; i<arrJson.tagIds.length; i++){
                if(arrJson.tagIds[i].tagId != undefined){
                    tagIds.push(arrJson.tagIds[i].tagId);
                }else{
                    tagId = await this.getIdByLongName(arrJson.tagIds[i]);
                    if(tagId.retCode !=0){
                        return tagId;
                    }
                    tagIds.push(tagId.id);
                }
            }
    
            let retRes = await this.getHisReadRaw({'startTime':arrJson.beginTime,'endTime':arrJson.endTime,'maxReturn':10000,'bounds':0,'tagIds':tagIds});
    
            if(retRes.retCode !=0){
                return retRes;
            }
    
            let retTagNames = await this.getTagListProps({'tagIds':tagIds,'propIds':[3]});
            if(retTagNames.retCode !=0){
                return retTagNames;
            }
    
            let retJson = [];
            let json_ = {};
            for(let i=0; i<retRes.tagHisDatas.length; i++){
                json_ = {};
                json_.values = [];
                json_.name = retTagNames.tagPropList[i][0].data;
                for(let j=0; j<retRes.tagHisDatas[i].dataSet.length; j++){
                    let json = {};
                    json.value = retRes.tagHisDatas[i].dataSet[j].value;
                    json.time = retRes.tagHisDatas[i].dataSet[j].time;
                    json.quality = retRes.tagHisDatas[i].dataSet[j].quality;
                    json_.values.push(json);
                }
    
                retJson[i] = json_;
            }
			let retJson_ = {};
			retJson_.retCode = 0;
			retJson_.data = retJson;
            return retJson_;
        }else if(arrJson.type == "process"){
            let arrJson_ = {};
            arrJson_.beginTime = arrJson.beginTime;
            arrJson_.endTime = arrJson.endTime;
            arrJson_.count = arrJson.count;
            arrJson_.intervalTime = arrJson_.sampleInterval;
            arrJson_.aggregateList = arrJson.aggregateList;
            arrJson_.tagIds = [];
            for(let k=0; k<arrJson.count; k++){
                if(arrJson.tagIds[k].tagId != undefined){
                    arrJson_.tagIds.push(arrJson.tagIds[k].tagId);

                }else{
                    let resId = await this.getIdByLongName({'tagName':arrJson.tagIds[k].tagName});
                    if(resId.retCode != 0){
                        return resId;
                    }
                    arrJson_.tagIds.push(resId.id);
                }
            }
            let retRes = await this.getHisReadProcessed(arrJson_);
            if(retRes.retCode != 0){
                return retRes;
            }else{
                let retRes_ = [];
                for(let j=0; j<retRes.tagHisData.length;j++){
                    let tagIds = [];
                    tagIds.push(retRes.tagHisData[j].tagId);
                    let tagName = await this.getTagListProps({'tagIds':tagIds,'propIds':[3]});
					if(tagName.retCode !=0){
						return tagName;
					}
					
                    retRes_[j] = {};
                    retRes_[j].name = tagName.tagPropList[0][0].data;
                    retRes_[j].values = [];
                    for(let t=0; t<retRes.tagHisData[j].tagDatas.length;t++){
                        let jtmp = {};
                        jtmp.data = retRes.tagHisData[j].tagDatas[t].value.data;
                        jtmp.time = retRes.tagHisData[j].tagDatas[t].time;
                        jtmp.quality = retRes.tagHisData[j].tagDatas[t].quality;
                        retRes_[j].values.push(jtmp);
                    }
                }
				let ret = {};
				ret.retCode = 0;
				ret.data = retRes_;
                return ret;
            }
        }else{
            let startTime = new Date(arrJson.beginTime).getTime();
            let endTime = new Date(arrJson.endTime).getTime();
            let gap = parseInt((endTime-startTime)/arrJson.count);
            let arrJson_ = {};
            arrJson_.timeStamps = [];
            for(let k=0;k<arrJson.count;k++){
                arrJson_.timeStamps.push(new Date(startTime+gap*k));
            }

            if((startTime+(gap*arrJson.count)) != endTime){
                arrJson_.timeStamps.push(new Date(endTime));
            }

            arrJson_.tags = [];
            for(let k =0; k<arrJson.tagIds.length;k++){
                if(arrJson.tagIds[k].tagId != undefined){
                    arrJson_.tags.push(arrJson.tagIds[k].tagId);
                }else{
                    let resId = await this.getIdByLongName({'tagName':arrJson.tagIds[k].tagName});
                    if(resId.retCode != 0){
                        return resId;
                    }   
                    arrJson_.tags.push(resId.id);             
                }
            }

            let retRes = await this.getHisReadAtTime(arrJson_);
            if(retRes.retCode != 0){
                return retRes;
            }else{
                let retRes_ = [];
                for(let j=0; j<retRes.tagHisData.length;j++){
                    let tagIds = [];
                    tagIds.push(retRes.tagHisData[j].tagId);
                    let tagName = await this.getTagListProps({'tagIds':tagIds,'propIds':[3]});
					if(tagName.retCode!=0){
						return tagName;
					}
					
                    retRes_[j] = {};
                    retRes_[j].name = tagName.tagPropList[0][0].data;
                    retRes_[j].values = [];
                    for(let t=0; t<retRes.tagHisData[j].tagDatas.length;t++){
                        let jtmp = {};
                        jtmp.data = retRes.tagHisData[j].tagDatas[t].value.data;
                        jtmp.time = retRes.tagHisData[j].tagDatas[t].time;
                        jtmp.quality = retRes.tagHisData[j].tagDatas[t].quality;
                        retRes_[j].values.push(jtmp);
                    }
                }
				
				let ret = {};
				ret.retCode = 0;
				ret.data = retRes_;
                return ret;
            }
        }
    },

        "getHisData_":async function(arrJson){
            let tagIds = [];
            let tagId;
            for(let i=0; i<arrJson.tagIds.length; i++){
                if(arrJson.tagIds[i].tagId != undefined){
                    tagIds.push(arrJson.tagIds[i].tagId);
                }else{
                    tagId = await this.getIdByLongName(arrJson.tagIds[i]);
                    if(tagId.retCode !=0){
                        return {retCode:-1};
                    }
                    tagIds.push(tagId.id);
                }
            }

            let retRes = await this.getHisReadRaw({'startTime':arrJson.beginTime,'endTime':arrJson.endTime,'maxReturn':arrJson.maxNum||10000,'bounds':arrJson.bounds||0,'tagIds':tagIds});
    
            if(retRes.retCode !=0){
                return retRes;
            }

            let retTagNames = await this.getTagListProps({'tagIds':tagIds,'propIds':[3]});
            if(retTagNames.retCode !=0){
                return retTagNames;
            }

            let retJson = [];
            let json_ = {};
            for(let i=0; i<retRes.tagHisDatas.length; i++){
                json_ = {};
                json_.values = [];
                json_.tagName = retTagNames.tagPropList[i][0].data;
                for(let j=0; j<retRes.tagHisDatas[i].dataSet.length; j++){
					let json = {};
                    json.value = retRes.tagHisDatas[i].dataSet[j].value;
                    json.time = retRes.tagHisDatas[i].dataSet[j].time;
                    json.quality = retRes.tagHisDatas[i].dataSet[j].quality;
                    json_.values.push(json);
                }

                retJson[i] = json_;
            }

            return retJson;
        }
    },
    "remoteMethod":{
        "login1":class{
            constructor(){
				this.packetType = 2000;
            };
            serilize(){
                module.exports.options = this.parent.options;
                let msg = Buffer.from([0x4b,0xb5,0x32,0x01]);//20100427
                this.parent.conn.setHeader(4,-1,0);
			    return msg;
            };
            unserilize(data){
                return data;
                

            };
        },
        "login2":class{
            constructor(){
				this.packetType = 2001;
            };
            serilize(jsonObj){
                let msg = Buffer.from([0x01,0x00,0x00,0x00]);
			    return msg;
            };
            unserilize(data){
                return data;
            };
        },
        "login3":class{
            constructor(){
				this.packetType = 5;
            };
            serilize(jsonObj){
                let msgHeader = Buffer.alloc(17);
                msgHeader.writeInt16LE(0x5a5a,0);
                msgHeader.writeUInt32LE(0,2);
                msgHeader.writeInt16LE(5,6);
                msgHeader.writeUInt32LE(1,8);
                msgHeader.writeInt16LE(0,12);
                msgHeader.writeUInt8(0,14);
                msgHeader.writeInt16LE(10,15);
            
                let serverPort = Buffer.alloc(4);
                serverPort.writeUInt32LE(this.parent.baseConfig.port);
                let username = Buffer.from(this.parent.options.username);
                let userNameLen = Buffer.alloc(4);
                userNameLen.writeUInt32LE(username.length,0);
                let passWd = Buffer.from(this.parent.options.password);
                let passWdLen = Buffer.alloc(4);
                passWdLen.writeUInt32LE(passWd.length,0);
                let appName = Buffer.from("nodeJs");
                let appNameLen = Buffer.alloc(4);
                appNameLen.writeUInt32LE(appName.length,0);
                let appType = Buffer.alloc(4);
                appType.writeUInt32LE(0,0);
                let userProxy = Buffer.alloc(1);

                if(this.parent.options.useProxy!=undefined && (this.parent.options.useProxy==1||this.parent.options.useProxy==0)){
                    userProxy.writeUInt8(this.parent.options.useProxy);
                }

                let conTimeout = Buffer.alloc(2);
            
                if(this.parent.options.connTimeout != undefined && this.parent.options.connTimeoutt>0){
                    conTimeout.writeInt16LE(this.parent.options.connTimeout,0);
                }else{
                    conTimeout.writeInt16LE(10,0);
                }

                let exeTimeOut = Buffer.alloc(2);
                
                if(this.parent.options.exeTimeout != undefined && this.parent.options.exeTimeout>0){
                    exeTimeOut.writeInt16LE(this.parent.options.exeTimeout,0);
                }else{
                    exeTimeOut.writeInt16LE(60,0);
                }
                
                let serverName = Buffer.from(this.parent.baseConfig.ip);
                let serverLen = Buffer.alloc(4);
                serverLen.writeUInt32LE(serverName.length,0);
                let endTag = Buffer.from(['0x6a','0x6a']);
                let sendMsg = Buffer.concat([msgHeader,serverLen,serverName,serverPort,userNameLen,username,passWdLen,passWd,appNameLen,appName,appType,userProxy,conTimeout,exeTimeOut,endTag]);
                sendMsg.writeUInt32LE(sendMsg.length,2);
                this.parent.conn.setHeader(17,2,4);
                
                return sendMsg;
            };
            unserilize(data){
				    if(data == null){
					    return {};
                    }
                    let retJson = {};
                    let apiStatus=data.slice(17,21);
                    if(apiStatus.readInt32LE(0) !== 0){
                        retJson.retCode = apiStatus.readInt32LE(0);
                        //return retJson;
                        return false;
                    }
                    
                    retJson.retCode = apiStatus.readInt32LE(0);
                    retJson.version = Buffer.from(data.slice(21,23));
                    retJson.subVersion = Buffer.from(data.slice(23,25));
                    retJson.handle = data.slice(25,27).readInt16LE(0);
                    retJson.localHandle = data.slice(27,29).readInt16LE(0);
                    retJson.connId = Buffer.from(data.slice(29,31));
                    retJson.priLimit = Buffer.from(data.slice(31,35));
                    retJson.areaSecurit = Buffer.from(data.slice(35,43));
                    retJson.exeTimeout = Buffer.from(data.slice(43,47));
                    this.parent.options.loginInfos = retJson;
					handle = data.slice(27,29).readInt16LE(0);
                    isWork = true;
                    retJson.retCode = 0;
                    return true;
            };
        },
        "getHisReadRaw":class{
            constructor(){
				this.packetType = 64;
            };
            serilize(arrJson){
                let msgHeader = Buffer.alloc(17);
                msgHeader.writeInt16LE(0x5a5a,0);
                msgHeader.writeUInt32LE(0,2);
                msgHeader.writeInt16LE(64,6);
                msgHeader.writeUInt32LE(1,8);
                msgHeader.writeInt16LE(handle,12);
                msgHeader.writeUInt8(0,14);
                msgHeader.writeInt16LE(10,15);
                
                let tb = new Date(arrJson.startTime);
                let tbv = tb.getTime();
                let te = new Date(arrJson.endTime);
                let tev = te.getTime()
                let timeStartsec32Buf = Buffer.alloc(4);
                let timeStartMillsec16Buf = Buffer.alloc(2);
                let timeEndsec32Buf = Buffer.alloc(4);
                let timeEndMillsec16Buf = Buffer.alloc(2);
                let timeStartsec32 = parseInt(tbv/1000);
                let timeStartMillsec = tbv - timeStartsec32*1000;
                timeStartsec32Buf.writeUInt32LE(timeStartsec32,0);
                timeStartMillsec16Buf.writeInt16LE(timeStartMillsec,0);
                let timeEndsec32 = parseInt(tev/1000);
                let timeEndMillsec = tev - timeEndsec32*1000;
                timeEndsec32Buf.writeUInt32LE(timeEndsec32,0);
                timeEndMillsec16Buf.writeInt16LE(timeEndMillsec,0);

                let maxOfReturn32Buf = Buffer.alloc(4);
                let maxReturn = arrJson.maxReturn || 10000;
                maxOfReturn32Buf.writeUInt32LE(maxReturn,0);
                let bounds8Buf = Buffer.alloc(1);
                let bounds = arrJson.bounds || 0;
                bounds8Buf.writeUInt8(arrJson.bounds,0);
                let count32Buf = Buffer.alloc(4);
                let count32 = arrJson.tagIds.length;
                count32Buf.writeUInt8(count32,0);

                let i = 0;
                let tagIdsBufArray = [];
                for(i=0;i<count32;i++){
                    let tagIdBuf = Buffer.alloc(4);
                    tagIdBuf.writeUInt32LE(arrJson.tagIds[i]);
                    tagIdsBufArray.push(tagIdBuf);
                }
                    
                let tagIdsBuf = Buffer.concat(tagIdsBufArray);
                let tagTypeBuf = Buffer.alloc(1);
                tagTypeBuf.writeUInt8(0,0);
                let tagFieldBuf = Buffer.alloc(1);
                tagFieldBuf.writeUInt8(255,0);
                    
                let msgEnd = Buffer.from(['0x6a','0x6a']);
                let sendMsg = Buffer.concat([msgHeader,timeStartsec32Buf,timeStartMillsec16Buf,timeEndsec32Buf,timeEndMillsec16Buf,maxOfReturn32Buf,bounds8Buf,count32Buf,tagIdsBuf,tagTypeBuf,tagFieldBuf,msgEnd]);
                sendMsg.writeUInt32LE(sendMsg.length,2);
                return sendMsg;		
            };
            unserilize(data){
                    if(data == null){
                        return {};	
                    }
                    
                    let arrJson = {};
                    let apiStatus=data.slice(17,21);
                    arrJson.retCode = apiStatus.readInt32LE(0);
                    if(apiStatus.compare(Buffer.from([0x00,0x00,0x00,0x00]))!=0){
                        if(apiStatus.compare(Buffer.from([0xe3,0xb1,0xff,0xff]))!=0){
                            return arrJson;
                        }
                    }

                    let tagCount32Buf = data.slice(21,25);
                    let tagCount32 = tagCount32Buf.readInt32LE(0);
                    arrJson.tagHisDatas = [];
                    let i = 0;
                    let pos = 25;

                    for(i = 0;i < tagCount32;i++){
                    arrJson.tagHisDatas[i] = {};
                    let tagID32Buf = data.slice(pos,pos+4);
                    let tagID32 = tagID32Buf.readInt32LE(0);
                    arrJson.tagHisDatas[i].tagId = tagID32;
                    pos = pos+4;
                    let aggregate32Buf = data.slice(pos,pos+4);
                    let aggregate32 = aggregate32Buf.readInt32LE(0);
                    arrJson.tagHisDatas[i].aggregate = aggregate32;
                    pos=pos+4;
                    let dataCount32Buf=data.slice(pos,pos+4);
                    let dataCount32=dataCount32Buf.readInt32LE(0);
                    arrJson.tagHisDatas[i].dataSet = [];
                    pos = pos+4;
                    let tmp;
                    let j = 0;
                    
                    for(j = 0;j < dataCount32;j++){   
                        let psTimeSecBuf = data.slice(pos,pos+4);
                        let psTimeSec32 = psTimeSecBuf.readInt32LE(0);
                        pos = pos + 4;
                        let psTimeMillSecBuf = data.slice(pos,pos+2);
                        let psTimeMillSec16 = psTimeMillSecBuf.readInt16LE(0);
                        pos = pos + 2;
                        arrJson.tagHisDatas[i].dataSet[j] = {};
                        arrJson.tagHisDatas[i].dataSet[j].time = psTimeSec32*1000 + psTimeMillSec16;
                            
                        let psValueType8Buf = data.slice(pos,pos+1);
                        pos = pos +1;
                        let psValueType = psValueType8Buf.readUInt8(0);
                        arrJson.tagHisDatas[i].dataSet[j].dataType = psValueType;
                            
                        let tmpData;
                        switch(psValueType){
                            case 0:
                                break;
                            case 1:
                                tmpData = data.slice(pos,pos+1);
                                pos = pos+1;
                                arrJson.tagHisDatas[i].dataSet[j].value = tmpData.readUInt8(0);
                                break;
                            case 2:
                                tmpData = data.slice(pos,pos+1);
                                arrJson.tagHisDatas[i].dataSet[j].value = tmpData.readInt8(0);
                                pos = pos+1;
                                break;
                            case 3:
                                tmpData = data.slice(pos,pos+1);
                                arrJson.tagHisDatas[i].dataSet[j].value = tmpData.readUInt8(0);
                                pos = pos+1;
                                break;
                            case 4:
                                tmpData = data.slice(pos,pos+2);
                                arrJson.tagHisDatas[i].dataSet[j].value = tmpData.readInt16LE(0);
                                pos = pos+2;
                                break;
                            case 5:
                                tmpData = data.slice(pos,pos+2);
                                arrJson.tagHisDatas[i].dataSet[j].value = tmpData.readUInt16LE(0);
                                pos = pos + 2;
                                break;
                            case 6:
                                tmpData = data.slice(pos,pos+4);
                                arrJson.tagHisDatas[i].dataSet[j].value = tmpData.readInt32LE(0);
                                pos = pos+4;
                                break;
                            case 7:
                                tmpData = data.slice(pos,pos+4);
                                arrJson.tagHisDatas[i].dataSet[j].value = tmpData.readUInt32LE(0);
                                pos = pos+4;
                                break;
                            case 8:
                                tmpData = data.slice(pos,pos+8);
                                arrJson.tagHisDatas[i].dataSet[j].value = tmpData.readIntLE(0,8);
                                pos = pos+8;
                                break;
                            case 9:
                                tmpData = data.slice(pos,pos+8);
                                arrJson.tagHisDatas[i].dataSet[j].value = tmpData.readUIntLE(0,8);
                                pos = pos+8;
                                break;
                            case 10:
                                tmpData = data.slice(pos,pos+4);
                                arrJson.tagHisDatas[i].dataSet[j].value = tmpData.readFloatLE(0);
                                pos = pos+4;
                                break;;
                            case 11:
                                tmpData = data.slice(pos,pos+8);
                                arrJson.tagHisDatas[i].dataSet[j].value = tmpData.readDoubleLE(0);
                                pos = pos+8;
                                break;
                            case 12:
                                tmp = data.slice(pos,pos+4);
                                let tmpv1 = tmp.readInt32LE(0);
                                pos = pos+4;
                                tmp = Buffer.from(data.slice(pos,pos+2));
                                pos = pos+2;
                                let tmpv2 = tmp.readInt16LE(0);
                                arrJson.tagHisDatas[i].dataSet[j].value = tmpv1*1000+tmpv2;
                                break;
                            case 13:
                                tmp = data.slice(pos,pos+4);
                                len = tmp.readInt32LE(0);
                                pos = pos+4;
                                tmp = data.slice(pos,pos+len);
                                pos = pos+len;
                                arrJson.tagHisDatas[i].dataSet[j].value = /*tmp.toString('utf8', 0, len);*/iconv.decode(tmp,'gbk');
                                break;
                            case 14:
                                tmp = data.slice(pos,pos+4);
                                len = tmp.readInt32LE(0);
                                pos = pos+4;
                                tmp = data.slice(pos,pos+len);
                                pos = pos+len;
                                arrJson.tagHisDatas[i].dataSet[j].value = /*tmp.toString('utf8', 0, len)*/iconv.decode(tmp,'UTF-16');
                                break;
                            case 15:
                                tmp = data.slice(pos,pos+4);
                                len = tmp.readInt32LE(0);
                                pos = pos+4;
                                tmp = data.slice(pos,pos+len);
                                pos = pos+len;
                                arrJson.tagHisDatas[i].dataSet[j].value = tmp.toString('utf8', 0, len);
                                break;
                            default:
                                break;
                        }	
                            
                        let quality32Buf = data.slice(pos,pos+4);
                        let quality32 = quality32Buf.readInt16LE(0);
                        arrJson.tagHisDatas[i].dataSet[j].quality = quality32;
                        pos = pos + 4;   
                        }	
                    }

                    
                    arrJson.status = [];
                    if(apiStatus.compare(Buffer.from([0xe3,0xb1,0xff,0xff]))==0){
                        let statusBadCountBuf = data.slice(pos,pos+4);
                        pos = pos + 4;
                        let statusBadCount32 = statusBadCountBuf.readInt32LE(0);
                        for(let t=0; t<statusBadCount32; t++){
                            let badstatusBuf = data.slice(pos,pos+4);
                            pos = pos + 4;
                            let badstatus32 = badstatusBuf.readInt32LE(0);
                            arrJson.status[t] = badstatus32;
                        }
                    }

                    return arrJson;
            };
        },
        "getHisAlarmInfo_":class{
            constructor(){
				this.packetType = 86;
            };
            serilize(arrJson){
                let msgHeader = Buffer.alloc(17);
                msgHeader.writeInt16LE(0x5a5a,0);
                msgHeader.writeUInt32LE(0,2);
                msgHeader.writeInt16LE(86,6);
                msgHeader.writeUInt32LE(1,8);
                msgHeader.writeInt16LE(handle,12);
                msgHeader.writeUInt8(0,14);
                msgHeader.writeInt16LE(10,15);
                

                let params = [];
                let alarmFilterFieldBuf16 = Buffer.alloc(2);
                let alarmFilterField = 0;
                if(arrJson.alarmId != undefined){
                    alarmFilterField |= 0x01;
                    let alarmIdBuf32 = Buffer.alloc(4);
                    alarmIdBuf32.writeUInt32LE(arrJson.alarmId);
                    params.push(Buffer.from(alarmIdBuf32));
                }
                if(arrJson.tagId != undefined){
                    alarmFilterField |= 0x02;
                    let tagIdBuf32 = Buffer.alloc(4);
                    tagIdBuf32.writeUInt32LE(arrJson.tagId);
                    params.push(Buffer.from(tagIdBuf32));
                }
                if(arrJson.userId != undefined){
                    alarmFilterField |= 0x04;
                    let userIdBuf16 = Buffer.alloc(2);
                    userIdBuf16.writeInt16LE(arrJson.userId);
                    params.push(Buffer.from(userIdBuf16));
                }
                if(arrJson.startTime != undefined){
                    alarmFilterField |= 0x08;
                    let t = new Date(arrJson.startTime);
                    let timeBuf48 = Buffer.alloc(6);
                    timeBuf48.writeUInt32LE(t.getTime()/1000,0);
                    timeBuf48.writeInt16LE(0,4);
                    params.push(Buffer.from(timeBuf48));
                }
                if(arrJson.endTime != undefined){
                    alarmFilterField |= 0x10;
                    let t = new Date(arrJson.endTime);
                    let timeBuf48 = Buffer.alloc(6);
                    timeBuf48.writeUInt32LE(t.getTime()/1000,0);
                    timeBuf48.writeInt16LE(0,4);
                    params.push(Buffer.from(timeBuf48));
                }
                if(arrJson.topic != undefined){
                    alarmFilterField |= 0x20;
                    let topicBuf8 = Buffer.allo(1);
                    topicBuf8.writeUInt8(arrJson.topic);
                    params.push(Buffer.from(topicBuf8));
                }
                if(arrJson.haveAcked != undefined){
                    alarmFilterField |= 0x40;
                    let haveAckedBuf8 = Buffer.allo(1);
                    haveAckedBuf8.writeUInt8(arrJson.haveAcked);
                    params.push(Buffer.from(haveAckedBuf8));
                }
                if(arrJson.ackUserId != undefined){
                    alarmFilterField |= 0x100;
                    let ackUserIdBuf16 = Buffer.allo(2);
                    ackUserIdBuf16.writeUInt8(arrJson.ackUserId);
                    params.push(Buffer.from(ackUserIdBuf16));
                }
                if(arrJson.lowLevel != undefined){
                    alarmFilterField |= 0x200;
                    let lowLevelBuf16 = Buffer.allo(2);
                    lowLevelBuf16.writeUInt8(arrJson.lowLevel);
                    params.push(Buffer.from(lowLevelBuf16));
                }
                if(arrJson.highLevel != undefined){
                    alarmFilterField |= 0x400;
                    let highLevelBuf16 = Buffer.allo(2);
                    highLevelBuf16.writeUInt8(arrJson.highLevel);
                    params.push(Buffer.from(highLevelBuf16));
                }
                if(arrJson.isQueryOneLevel != undefined){
                    alarmFilterField |= 0x800;
                    let isQueryOneLevelBuf8 = Buffer.allo(1);
                    isQueryOneLevelBuf8.writeUInt8(arrJson.isQueryOneLevel);
                    params.push(Buffer.from(isQueryOneLevelBuf8));
                }
                if(arrJson.contentStr != undefined){
                    alarmFilterField |= 0x1000;
                    let strLenBuf32 = Buffer.alloc(4);
                    strLenBuf32.writeUInt32LE(arrJson.contentStr.length);
                    params.push(Buffer.from(strLenBuf32));
                    //params.push(Buffer.from(arrJson.contentStr)); //修改于3-26日 用于支持中文
                    params.push(iconv.encode(arrJson.contentStr,'gbk')); //修改于3-26日 用于支持中文

                }
                
                alarmFilterFieldBuf16.writeInt16LE(alarmFilterField);
                let paramBuf = Buffer.concat(params);
                let alarmFieldBuf16 = Buffer.alloc(2);
                alarmFieldBuf16.writeUInt16LE(0xffff,0);
                    
                let msgEnd = Buffer.from(['0x6a','0x6a']);
                let sendMsg = Buffer.concat([msgHeader,alarmFilterFieldBuf16,paramBuf,alarmFieldBuf16,msgEnd]);
                sendMsg.writeUInt32LE(sendMsg.length,2);
                return sendMsg;		
            };
            async unserilize(data){
                    if(data == null){
                        return {};
                    }
                    
                    let arrJson = {};
                    let apiStatus=data.slice(17,21);
                    arrJson.retCode = apiStatus.readInt32LE(0);
                    if(apiStatus.compare(Buffer.from([0x00,0x00,0x00,0x00]))!=0){
                        if(apiStatus.compare(Buffer.from([0xe3,0xb1,0xff,0xff]))!=0){
                            return arrJson;
                        }
                    }
    
                    let alarmCount32Buf = data.slice(21,25);
                    let alarmCount32 = alarmCount32Buf.readInt32LE(0);
                    if(alarmCount32 == 0){
                        return arrJson;
                    }
                    arrJson.alarms = [];
                    let pos = 25;
                    
                    for(let i=0; i<alarmCount32; i++){
                        arrJson.alarms[i] = {};
                        arrJson.alarms[i].alarmId = data.readInt32LE(pos);
                        pos += 4;
                        arrJson.alarms[i].tagId = data.readInt32LE(pos);
                        pos += 4;
                        arrJson.alarms[i].userId = data.readInt16LE(pos);
                        pos += 2;
                        arrJson.alarms[i].appType = data.readInt8(pos);
                        pos += 1;
                        arrJson.alarms[i].level = data.readInt8(pos);
                        pos += 1;
                        arrJson.alarms[i].topic = data.readInt8(pos);
                        pos += 1;
                        arrJson.alarms[i].needAck = data.readInt8(pos);
                        pos += 1;
                        arrJson.alarms[i].haveAcked = data.readInt8(pos);
                        pos += 1;
                        let timeSec = data.readInt32LE(pos);
                        pos += 4;
                        let timemills = data.readInt16LE(pos);
                        pos += 2;
                        //let t = new Date(timeSec*1000+timemills);
                        //arrJson.alarms[i].startTime = t.toLocaleString();
                        arrJson.alarms[i].startTime = timeSec*1000+timemills;
                        timeSec = data.readInt32LE(pos);
                        pos += 4;
                        timemills = data.readInt16LE(pos);
                        pos += 2;
                        //t = new Date(timeSec*1000+timemills);
                        //arrJson.alarms[i].endTime = t.toLocaleString();
                        arrJson.alarms[i].endTime = timeSec*1000+timemills;
                        let strLen = data.readInt32LE(pos);
                        pos += 4;
                        arrJson.alarms[i].valueStr = data.toString('ascii',pos,pos+strLen);
                        pos += strLen;
                        strLen = data.readInt32LE(pos);
                        pos += 4;
                        //arrJson.alarms[i].contentStr = data.toString('ascii',pos,pos+strLen); 修改于3-26 用于支持中文
                        let tmp = data.slice(pos,pos+strLen);//修改于3-26 用于支持中文
                        arrJson.alarms[i].contentStr = iconv.decode(tmp,'gbk'); //修改于3-26 用于支持中文
                        pos += strLen;
                        arrJson.alarms[i].ackUserId = data.readInt16LE(pos);
                        pos += 2;
                        timeSec = data.readInt32LE(pos);
                        pos += 4;
                        timemills = data.readInt16LE(pos);
                        pos += 2;
                        //t = new Date(timeSec*1000+timemills);
                        //arrJson.alarms[i].ackTime = t.toLocaleString();
                        arrJson.alarms[i].ackTime = timeSec*1000+timemills;
                        strLen = data.readInt32LE(pos);
                        pos += 4;
                        arrJson.alarms[i].ackContentStr = data.toString('ascii',pos,pos+strLen);
                        pos += strLen;
    
                    }
                    return arrJson;
            };
        },
        "getRealRead":class{
            constructor(){
				this.packetType = 54;
            };
            serilize(arrJson){
                if(arrJson.length != 1){
                    throw new Error("getRealRead param error!");
                }
                
                let msgHeader = Buffer.alloc(17);
                msgHeader.writeInt16LE(0x5a5a,0);
                msgHeader.writeUInt32LE(0,2);
                msgHeader.writeInt16LE(54,6);
                msgHeader.writeUInt32LE(1,8);
                msgHeader.writeInt16LE(handle,12);
                msgHeader.writeUInt8(0,14);
                msgHeader.writeInt16LE(10,15);
                         
                let tagId = Buffer.alloc(4);
                tagId.writeUInt32LE(arrJson[0],0);
                let tagIdFiled = Buffer.alloc(1);
                tagIdFiled.writeUInt8(255,0);
                let msgEnd = Buffer.from(['0x6a','0x6a']);
                let sendMsg = Buffer.concat([msgHeader,tagId,tagIdFiled,msgEnd]);
                sendMsg.writeUInt32LE(sendMsg.length,2);
                return sendMsg;
            };
            unserilize(data){
                    if(data == null){
                        return {};
                    }
                    
                    let apiStatus = data.slice(17,21);
                    let arrJson = {};
                    arrJson.retCode = apiStatus.readInt32LE(0);
                    if(apiStatus.compare(Buffer.from([0,0,0,0]))==0){
                        let second = data.slice(21,25);
                        let millsec = data.slice(25,27);
                        let dataType = data.readInt8(27);
                        let secNum = second.readInt32LE();
                        let millsecNum = millsec.readInt16LE();
                        arrJson.pstime = secNum*1000 + millsecNum;
                        arrJson.psvalue = {};
                        arrJson.psvalue.type = dataType;
                        let pos = 28;
                        let tmp;
                        let len = 0;  
                        switch(dataType){
                            case 0:
                                arrJson.psvalue.value = 'null';
                                break;
                            case 1:
                                tmp = data.slice(pos,pos+1);
                                pos = pos+1;
                                arrJson.psvalue.value = tmp.readInt8(0);
                                break;
                            case 2:
                                tmp = data.slice(pos,pos+1);
                                pos = pos+1;
                                arrJson.psvalue.value = tmp.readInt8(0);
                                break;
                            case 3:
                                tmp = data.slice(pos,pos+1);
                                pos = pos+1;
                                arrJson.psvalue.value = tmp.readUInt8(0);
                                break;
                            case 4:
                                tmp = data.slice(pos,pos+2);
                                pos = pos+2;
                                arrJson.psvalue.value = tmp.readInt16LE(0);
                                break;
                            case 5:
                                tmp = data.slice(pos,pos+2);
                                pos = pos+2;
                                arrJson.psvalue.value = tmp.readUInt16LE(0);
                                break;
                            case 6:
                                tmp = data.slice(pos,pos+4);
                                pos = pos+4;
                                arrJson.psvalue.value = tmp.readInt32LE(0);
                                break;
                            case 7:
                                tmp = data.slice(pos,pos+4);
                                pos = pos+4;
                                arrJson.psvalue.value = tmp.readUInt32LE(0);
                                break;
                            case 8:
                                tmp = data.slice(pos,pos+8);
                                pos = pos+8;
                                arrJson.psvalue.value = tmp.readIntLE(0, 8);
                                break;
                            case 9:
                                tmp = data.slice(pos,pos+8);
                                pos = pos+8;
                                arrJson.psvalue.value = tmp.readUIntLE(0, 8);
                                break;
                            case 10:
                                tmp = data.slice(pos,pos+4);
                                pos = pos+4;
                                arrJson.psvalue.value = tmp.readFloatLE(0);
                                break;
                            case 11:
                                tmp = data.slice(pos,pos+8);
                                pos = pos+8;
                                arrJson.psvalue.value = tmp.readDoubleLE(0);
                                break;
                            case 12:
                                tmp = data.slice(pos,pos+4);
                                let tmpv1 = tmp.readInt32LE(0);
                                pos = pos+4;
                                tmp = data.slice(pos,pos+2);
                                pos = pos+2;
                                let tmpv2 = tmp.readInt16LE(0);
                                arrJson.psvalue.value = tmpv1*1000+tmpv2;
                                break;
                            case 13:
                                tmp = data.slice(pos,pos+4)
                                len = tmp.readInt32LE(0);
                                pos = pos+4;
                                tmp = data.slice(pos,pos+len);
                                pos = pos+len;
                                arrJson.psvalue.value = /*tmp.toString('utf8', 0, len);*/iconv.decode(tmp, 'gbk');
                                break;
                            case 14:
                                tmp = data.slice(pos,pos+4);
                                len = tmp.readInt32LE(0);
                                pos = pos+4;
                                tmp = data.slice(pos,pos+len*2);
                                pos = pos+len*2;
                                arrJson.psvalue.value = /*tmp.toString('utf8', 0, len);*/iconv.decode(tmp, 'UTF-16');
                                break;
                            case 15:
                                tmp = data.slice(pos,pos+4);
                                len = tmp.readInt32LE(0);
                                pos = pos+4;
                                tmp = Buffer.from(data.slice(pos,pos+len));
                                pos = pos+len;
                                arrJson.psvalue.value = tmp;
                                break;
                            default:
                                break;
                        }
                                    
                            let psQualityBuf16 = data.slice(pos,pos+2);
                            let psQuality16 = psQualityBuf16.readInt16LE(0);
                            arrJson.quality = psQuality16;
                    }  
                    return arrJson;
            };
        }, 
"getHisReadAtTime":class{
            constructor(){
				this.packetType = 65;
            };
            unserializeVar(msg, pos)
            {
                let res = {};
                res.variable = {};
                res.pos = 0;
                let type8Buf = msg.slice(pos,pos+1);
                pos += 1; 
                res.variable.dataType = type8Buf.readUInt8(0);
                let tmpData;
                let tmp;
                let len;
                switch(res.variable.dataType)
                {
                    case 0:	
                        break;
                    case 1:
                        tmpData = msg.slice(pos,pos+1);
                        pos = pos+1;
                        res.variable.data = tmpData.readUInt8(0);
                        break;
                    case 2:
                        tmpData = msg.slice(pos,pos+1);
                        res.variable.data = tmpData.readInt8(0);
                        pos = pos+1;
                        break;
                    case 3:
                        tmpData = msg.slice(pos,pos+1);
                        res.variable.data = tmpData.readUInt8(0);
                        pos = pos+1;
                        break;
                    case 4:
                        tmpData = msg.slice(pos,pos+2);
                        res.variable.data = tmpData.readInt16LE(0);
                        pos = pos+2;
                        break;
                    case 5:
                        tmpData = msg.slice(pos,pos+2);
                        res.variable.data = tmpData.readUInt16LE(0);
                        pos = pos + 2;
                        break;
                    case 6:
                        tmpData = msg.slice(pos,pos+4);
                        res.variable.data = tmpData.readInt32LE(0);
                        pos = pos+4;
                        break;
                    case 7:
                        tmpData = msg.slice(pos,pos+4);
                        res.variable.data = tmpData.readUInt32LE(0);
                        pos = pos+4;
                        break;
                    case 8:
                        tmpData = msg.slice(pos,pos+8);
                        res.variable.data = tmpData.readIntLE(0,8);
                        pos = pos+8;
                        break;
                    case 9:
                        tmpData = msg.slice(pos,pos+8);
                        res.variable.data = tmpData.readUIntLE(0,8);
                        pos = pos+8;
                        break;
                    case 10:
                        tmpData = msg.slice(pos,pos+4);
                        res.variable.data = tmpData.readFloatLE(0);
                        pos = pos+4;
                        break;;
                    case 11:
                        tmpData = msg.slice(pos,pos+8);
                        res.variable.data = tmpData.readDoubleLE(0);
                        pos = pos+8;
                        break;
                    case 12:
                        tmp = msg.slice(pos,pos+4);
                        let tmpv1 = tmp.readInt32LE(0);
                        pos = pos+4;
                        tmp = msg.slice(pos,pos+2);
                        pos = pos+2;
                        let tmpv2 = tmp.readInt16LE(0);
                        res.variable.data = tmpv1*1000+tmpv2;
                        break;
                    case 13:
                        tmp = msg.slice(pos,pos+4);
                        len = tmp.readInt32LE(0);
                        pos = pos+4;
                        tmp = msg.slice(pos,pos+len);
                        pos = pos+len;
                        res.variable.data = /*tmp.toString('utf8', 0, len);*/iconv.decode(tmp, 'gbk');
                        break;
                    case 14:
                        tmp = msg.slice(pos,pos+4);
                        len = tmp.readInt32LE(0);
                        pos = pos+4;
                        tmp = msg.slice(pos,pos+len*2);
                        pos = pos+len*2;
                        res.variable.data = /*tmp.toString('utf8', 0, len);*/iconv.decode(tmp, 'UTF-16');
                        break;
                    case 15 :
                        tmp = msg.slice(pos,pos+4);
                        len = tmp.readInt32LE(0);
                        pos = pos+4;
                        tmp = msg.slice(pos,pos+len);
                        pos = pos+len;
                        res.variable.data = tmp.toString('utf8', 0, len);
                        break;
                    default:
                        break;   
                    }

                res.pos = pos;
                return res;
            
            };
            serilize(arrJson){
                let msgHeader = Buffer.alloc(17);
                msgHeader.writeInt16LE(0x5a5a,0);
                msgHeader.writeUInt32LE(0,2);
                msgHeader.writeInt16LE(65,6);
                msgHeader.writeUInt32LE(1,8);
                msgHeader.writeInt16LE(handle,12); 
                msgHeader.writeUInt8(0,14);
                msgHeader.writeInt16LE(10,15);
                
                let timeCount32Buf = Buffer.alloc(4);
                timeCount32Buf.writeUInt32LE(arrJson.timeStamps.length,0);
                let times48Buf = Buffer.alloc(6*arrJson.timeStamps.length);
                let pos = 0;
                for(let i=0; i<arrJson.timeStamps.length;i++){
                    let timeTmp = (new Date(arrJson.timeStamps[i])).getTime();
                    let second32 = parseInt(timeTmp/1000);
                    let millsec16 = timeTmp - second32*1000;
                    times48Buf.writeUInt32LE(second32,pos);
                    pos += 4;
                    times48Buf.writeInt16LE(millsec16,pos);
                    pos += 2;
                }

                let tagCount32Buf = Buffer.alloc(4);
                tagCount32Buf.writeUInt32LE(arrJson.tags.length,0);
                let tags32Buf = Buffer.alloc(4*arrJson.tags.length);
                pos = 0;
                for(let i=0; i<arrJson.tags.length; i++){
                    tags32Buf.writeUInt32LE(arrJson.tags[i],pos);
                    pos += 4;
                }

                let tagIdType8Buf = Buffer.alloc(1);
                tagIdType8Buf.writeInt8(0);
                let field8Buf = Buffer.alloc(1);
                field8Buf.writeUInt8(255,0);

                let msgEnd = Buffer.from(['0x6a','0x6a']);
                let sendMsg = Buffer.concat([msgHeader,timeCount32Buf,times48Buf,tagCount32Buf,tags32Buf,tagIdType8Buf,field8Buf,msgEnd]);
                sendMsg.writeUInt32LE(sendMsg.length,2);
                return sendMsg;
            };
            unserializeVar(msg, pos)
            {
                let res = {};
                res.variable = {};
                res.pos = 0;
                let type8Buf = msg.slice(pos,pos+1);
                pos += 1; 
                res.variable.dataType = type8Buf.readUInt8(0);
                let tmpData;
                let tmp;
                let len;
                switch(res.variable.dataType)
                {
                    case 0:	
                        break;
                    case 1:
                        tmpData = msg.slice(pos,pos+1);
                        pos = pos+1;
                        res.variable.data = tmpData.readUInt8(0);
                        break;
                    case 2:
                        tmpData = msg.slice(pos,pos+1);
                        res.variable.data = tmpData.readInt8(0);
                        pos = pos+1;
                        break;
                    case 3:
                        tmpData = msg.slice(pos,pos+1);
                        res.variable.data = tmpData.readUInt8(0);
                        pos = pos+1;
                        break;
                    case 4:
                        tmpData = msg.slice(pos,pos+2);
                        res.variable.data = tmpData.readInt16LE(0);
                        pos = pos+2;
                        break;
                    case 5:
                        tmpData = msg.slice(pos,pos+2);
                        res.variable.data = tmpData.readUInt16LE(0);
                        pos = pos + 2;
                        break;
                    case 6:
                        tmpData = msg.slice(pos,pos+4);
                        res.variable.data = tmpData.readInt32LE(0);
                        pos = pos+4;
                        break;
                    case 7:
                        tmpData = msg.slice(pos,pos+4);
                        res.variable.data = tmpData.readUInt32LE(0);
                        pos = pos+4;
                        break;
                    case 8:
                        tmpData = msg.slice(pos,pos+8);
                        res.variable.data = tmpData.readIntLE(0,8);
                        pos = pos+8;
                        break;
                    case 9:
                        tmpData = msg.slice(pos,pos+8);
                        res.variable.data = tmpData.readUIntLE(0,8);
                        pos = pos+8;
                        break;
                    case 10:
                        tmpData = msg.slice(pos,pos+4);
                        res.variable.data = tmpData.readFloatLE(0);
                        pos = pos+4;
                        break;;
                    case 11:
                        tmpData = msg.slice(pos,pos+8);
                        res.variable.data = tmpData.readDoubleLE(0);
                        pos = pos+8;
                        break;
                    case 12:
                        tmp = msg.slice(pos,pos+4);
                        let tmpv1 = tmp.readInt32LE(0);
                        pos = pos+4;
                        tmp = msg.slice(pos,pos+2);
                        pos = pos+2;
                        let tmpv2 = tmp.readInt16LE(0);
                        res.variable.data = tmpv1*1000+tmpv2;
                        break;
                    case 13:
                        tmp = msg.slice(pos,pos+4);
                        len = tmp.readInt32LE(0);
                        pos = pos+4;
                        tmp = msg.slice(pos,pos+len);
                        pos = pos+len;
                        res.variable.data = /*tmp.toString('utf8', 0, len);*/iconv.decode(tmp, 'gbk');
                        break;
                    case 14:
                        tmp = msg.slice(pos,pos+4);
                        len = tmp.readInt32LE(0);
                        pos = pos+4;
                        tmp = msg.slice(pos,pos+len*2);
                        pos = pos+len*2;
                        res.variable.data = /*tmp.toString('utf8', 0, len);*/iconv.decode(tmp, 'UTF-16');
                        break;
                    case 15 :
                        tmp = msg.slice(pos,pos+4);
                        len = tmp.readInt32LE(0);
                        pos = pos+4;
                        tmp = msg.slice(pos,pos+len);
                        pos = pos+len;
                        res.variable.data = tmp.toString('utf8', 0, len);
                        break;
                    default:
                        break;   
                    }

                res.pos = pos;
                return res;
            
            };
            unserilize(data){
				if(data == null){
					return {};
				}
				
                let arrJson = {};
         
                let apiStatus=data.slice(17,21);
                arrJson.retCode = apiStatus.readInt32LE(0);
                if(apiStatus.compare(Buffer.from([0x00,0x00,0x00,0x00]))!=0){
                    if(apiStatus.compare(Buffer.from([0xe3,0xb1,0xff,0xff]))!=0){
                        return arrJson;
                    }
                }

                let pos = 21;
                let tagsCount = data.readInt32LE(pos);
                pos += 4;
                

                arrJson.tagHisData = [];
                for(let i=0; i<tagsCount; i++){
                    arrJson.tagHisData[i] = {};
                    arrJson.tagHisData[i].tagId = data.readInt32LE(pos);
                    pos += 4;
                    arrJson.tagHisData[i].aggregate = data.readInt32LE(pos);
                    pos += 4;
                    let dataCount = data.readInt32LE(pos);
                    pos += 4;
                    arrJson.tagHisData[i].tagDatas = [];
                    let sec32;
                    let milc16;
                    let t;
                    let retVar;
                    for(let j=0; j<dataCount;j++){
                        arrJson.tagHisData[i].tagDatas[j] = {};
                        sec32 = data.readInt32LE(pos);
                        pos += 4;
                        milc16 = data.readInt16LE(pos);
                        pos += 2;
                        t = (new Date(sec32*1000+milc16)).toLocaleString();
                        arrJson.tagHisData[i].tagDatas[j].time = t;
                        arrJson.tagHisData[i].tagDatas[j].value = {};
                        retVar = this.unserializeVar(data,pos);
                        pos = retVar.pos;
                        arrJson.tagHisData[i].tagDatas[j].value.dataType = retVar.variable.dataType
                        arrJson.tagHisData[i].tagDatas[j].value.data = retVar.variable.data;
                        arrJson.tagHisData[i].tagDatas[j].quality = data.readInt32LE(pos);
                        pos += 4;
                    }

                    if(apiStatus.compare(Buffer.from([0xe3,0xb1,0xff,0xff]))==0){
							arrJson.status = [];
                            let statusBadCountBuf = data.slice(pos,pos+4);
                            pos = pos + 4;
                            let statusBadCount32 = statusBadCountBuf.readInt32LE(0);
                            for(let t=0; t<statusBadCount32; t++){
                            let badstatusBuf = data.slice(pos,pos+4);
                            pos = pos + 4;
                            let badstatus32 = badstatusBuf.readInt32LE(0);
                            arrJson.status[t] = badstatus32;
                        }
                    }
                }

                return arrJson;
            };
        },
        "setHisData":class{
            constructor(){
				this.packetType = 67;
            };
            serilize(arrJson){
                let msgHeader = Buffer.alloc(17);
                msgHeader.writeInt16LE(0x5a5a,0);
                msgHeader.writeUInt32LE(0,2);
                msgHeader.writeInt16LE(67,6);
                msgHeader.writeUInt32LE(1,8);
                msgHeader.writeInt16LE(handle,12);
                msgHeader.writeUInt8(0,14);
                msgHeader.writeInt16LE(10,15);

                let count32 = arrJson.tagIds.length;
                let tagIdCount32Buf = Buffer.alloc(4);
                tagIdCount32Buf.writeUInt32LE(count32);
                let tagIds32Buf;
                if(count32 >0){
                    tagIds32Buf = Buffer.alloc(4*count32);
                    let pos = 0;
                    for(let i=0;i<count32;i++){
                        tagIds32Buf.writeUInt32LE(arrJson.tagIds[i],pos);
                        pos += 4;
                    }
                }

                let field8Buf = Buffer.alloc(1);
                let field8 = 0;
                if(arrJson.field.time!=undefined && arrJson.field.time==1){
                    field8 |= 0b00000001;
                }
                
                if(arrJson.field.time!=undefined && arrJson.field.value==1){
                    field8 |= 0b00000010;
                }

                if(arrJson.field.time!=undefined && arrJson.field.quality==1){
                    field8 |= 0b00000100;
                }

                field8Buf.writeInt8(0x07);
                let dataCount32Buf = Buffer.alloc(4);
                dataCount32Buf.writeUInt32LE(arrJson.datas.length);
                let dataBufs = [];
            
                for(let i=0;i<count32;i++){
                    if(field8 & 0x01){
                        let time48Buf = Buffer.alloc(6);
                        time48Buf.writeUInt32LE(parseInt(arrJson.datas[i].timeStamps/1000),0);
                        time48Buf.writeInt16LE(arrJson.datas[i].timeStamps-(parseInt(arrJson.datas[i].timeStamps/1000))*1000,4);
                        dataBufs.push(time48Buf);
                    }else{
                        let time48Buf = Buffer.alloc(6);
                        let tnow = (new Date()).getTime();
                        time48Buf.writeUInt32LE(parseInt(tnow/1000),0);
                        time48Buf.writeInt16LE(0,4);
                        dataBufs.push(time48Buf);
                    }
    
                    if(field8 & 0x02){
                        let dataType8Buf = Buffer.alloc(1);
                        dataType8Buf.writeUInt8(arrJson.datas[i].dataValue.type);
                        dataBufs.push(dataType8Buf);
                        let dateValueBuf;
                        let strBuf;
                        let lenBuf32; 
                        switch(arrJson.datas[i].dataValue.type){
                            case 0:	
                                break;
                            case 1:
                                dateValueBuf = Buffer.alloc(1);
                                dateValueBuf.writeUInt8(arrJson.datas[i].dataValue.data,0);
                                break;
                            case 2:
                                dateValueBuf = Buffer.alloc(1);
                                dateValueBuf.writeInt8(arrJson.datas[i].dataValue.data,0);
                                break;
                            case 3:
                                dateValueBuf = Buffer.alloc(1);
                                dateValueBuf.writeUInt8(arrJson.datas[i].dataValue.data,0);
                                break;
                            case 4:
                                dateValueBuf = Buffer.alloc(2);
                                dateValueBuf.writeInt16LE(arrJson.datas[i].dataValue.data,0);
                                break;
                            case 5:
                                dateValueBuf = Buffer.alloc(2);
                                dateValueBuf.writeUInt16LE(arrJson.datas[i].dataValue.data,0);
                                break;
                            case 6:
                                dateValueBuf = Buffer.alloc(4);
                                dateValueBuf.writeUInt32LE(arrJson.datas[i].dataValue.data,0);
                                break;
                            case 7:
                                dateValueBuf = Buffer.alloc(4);
                                dateValueBuf.writeUInt32LE(arrJson.datas[i].dataValue.data,0);
                                break;
                            case 8:
                                dateValueBuf = Buffer.alloc(8);
                                dateValueBuf.writeIntLE(arrJson.datas[i].dataValue.data,0,8);
                                break;
                            case 9:
                                dateValueBuf = Buffer.alloc(8);
                                dateValueBuf.writeUIntLE(arrJson.datas[i].dataValue.data,0,8);
                                break;
                            case 10:
                                dateValueBuf = Buffer.alloc(4);
                                dateValueBuf.writeFloatLE(arrJson.datas[i].dataValue.data,0);
                                break;
                            case 11:
                                dateValueBuf = Buffer.alloc(8);
                                dateValueBuf.writeDoubleLE(arrJson.datas[i].dataValue.data,0);
                                break;
                            case 12: 
                                tmpsec32Buf = Buffer.alloc(4);
                                tmpmilldec16Buf = Buffer.alloc(2);
                                tmpsec32Buf.writeUInt32LE(parseInt(arrJson.datas[i].dataValue.data/1000),0);
                                timemill16 = arrJson.dataValues[i].data - parseInt((arrJson.datas[i].dataValue.data)/1000)*1000;
                                tmpmilldec16Buf.writeInt16LE(timemill16,0);
                                dateValueBuf = Buffer.concat([tmpsec32Buf,tmpmilldec16Buf]);
                                break;
                            case 13:
                                //strBuf = Buffer.from(arrJson.dataValues[i].data); 修改于3-26 用于支持中文
                                strBuf = iconv.encode(arrJson.datas[i].dataValue.data,'gbk');//修改于3-26 用于支持中文
                                lenBuf32 = Buffer.alloc(4);
                                lenBuf32.writeUInt32LE(strBuf.length,0);
                                dateValueBuf = Buffer.concat([lenBuf32,strBuf]);
                                break;
                            case 14:
                                //strBuf = Buffer.from(arrJson.dataValues[i].data);//修改于3-26 用于支持中文
                                strBuf = iconv.encode(arrJson.datas[i].dataValue.data,'UTF-16');//修改于3-26 用于支持中文
                                lenBuf32 = Buffer.alloc(4);
                                lenBuf32.writeUInt32LE(strBuf.length,0);
                                dateValueBuf = Buffer.concat([lenBuf32,strBuf]);
                                break;
                            case 15:
                                strBuf = Buffer.from(arrJson.datas[i].dataValue.data);
                                lenBuf32 = Buffer.alloc(4);
                                lenBuf32.writeUInt32LE(strBuf.length,0);
                                dateValueBuf = Buffer.concat([lenBuf32,strBuf]);
                                break;
                            default:
                                break;
        
                        }
                        
                        dataBufs.push(dateValueBuf);
                    }else{
                        let dataType8Buf = Buffer.alloc(1);
                        dataType8Buf.writeUInt8(11);
                        dataBufs.push(dataType8Buf);
                        let dateValueBuf;
                        dateValueBuf = Buffer.alloc(8);
                        dateValueBuf.writeDoubleLE(0,0);
                        dataBufs.push(dateValueBuf);
                    }
    
                    if(field8 &0x04){
                        let qualities16Buf = Buffer.alloc(2);
                        qualities16Buf.writeInt16LE(arrJson.datas[i].quality);
                        dataBufs.push(qualities16Buf);
                    }else{
                        let qualities16Buf = Buffer.alloc(2);
                        qualities16Buf.writeInt16LE(192);
                        dataBufs.push(qualities16Buf);
                    }
                }
                let dataValues32Buf = Buffer.concat(dataBufs);
                let msgEnd = Buffer.from(['0x6a','0x6a']);
                let sendMsg = Buffer.concat([msgHeader,tagIdCount32Buf,tagIds32Buf,field8Buf,dataCount32Buf,dataValues32Buf,msgEnd]);
                sendMsg.writeUInt32LE(sendMsg.length,2);
                return sendMsg;    
            }
            unserilize(data){


                if(data == null){
                    return {retCode:-1}
                }

                let arrJson = {};
                let apiStatus=data.slice(17,21);
                arrJson.retCode = apiStatus.readInt32LE(0);
                
                if(apiStatus.compare(Buffer.from([0x00,0x00,0x00,0x00]))!=0){
                    if(apiStatus.compare(Buffer.from([0xe3,0xb1,0xff,0xff]))!=0){
                        return arrJson;
                    }
                }
                
                let pos = 21;
                if(apiStatus.compare(Buffer.from([0xe3,0xb1,0xff,0xff]))==0){
                    let statusBadCountBuf = data.slice(pos,pos+4);
                    pos = pos + 4;
                    let statusBadCount32 = statusBadCountBuf.readInt32LE(0);
                    arrJson.status = [];
                    for(let t=0; t<statusBadCount32; t++){
                        let badstatusBuf = data.slice(pos,pos+4);
                        pos = pos + 4;
                        let badstatus32 = badstatusBuf.readInt32LE(0);
                        arrJson.status[t] = badstatus32;
                    }
                }
                return arrJson;
            }
        },
        "getHisReadProcessed":class{
            constructor(){
				this.packetType = 66;
            };
            unserializeVar(msg, pos)
            {
                let res = {};
                res.variable = {};
                res.pos = 0;
                let type8Buf = msg.slice(pos,pos+1);
                pos += 1; 
                res.variable.dataType = type8Buf.readUInt8(0);
                let tmpData;
                let tmp;
                let len;
                switch(res.variable.dataType)
                {
                    case 0:	
                        break;
                    case 1:
                        tmpData = msg.slice(pos,pos+1);
                        pos = pos+1;
                        res.variable.data = tmpData.readUInt8(0);
                        break;
                    case 2:
                        tmpData = msg.slice(pos,pos+1);
                        res.variable.data = tmpData.readInt8(0);
                        pos = pos+1;
                        break;
                    case 3:
                        tmpData = msg.slice(pos,pos+1);
                        res.variable.data = tmpData.readUInt8(0);
                        pos = pos+1;
                        break;
                    case 4:
                        tmpData = msg.slice(pos,pos+2);
                        res.variable.data = tmpData.readInt16LE(0);
                        pos = pos+2;
                        break;
                    case 5:
                        tmpData = msg.slice(pos,pos+2);
                        res.variable.data = tmpData.readUInt16LE(0);
                        pos = pos + 2;
                        break;
                    case 6:
                        tmpData = msg.slice(pos,pos+4);
                        res.variable.data = tmpData.readInt32LE(0);
                        pos = pos+4;
                        break;
                    case 7:
                        tmpData = msg.slice(pos,pos+4);
                        res.variable.data = tmpData.readUInt32LE(0);
                        pos = pos+4;
                        break;
                    case 8:
                        tmpData = msg.slice(pos,pos+8);
                        res.variable.data = tmpData.readIntLE(0,8);
                        pos = pos+8;
                        break;
                    case 9:
                        tmpData = msg.slice(pos,pos+8);
                        res.variable.data = tmpData.readUIntLE(0,8);
                        pos = pos+8;
                        break;
                    case 10:
                        tmpData = msg.slice(pos,pos+4);
                        res.variable.data = tmpData.readFloatLE(0);
                        pos = pos+4;
                        break;;
                    case 11:
                        tmpData = msg.slice(pos,pos+8);
                        res.variable.data = tmpData.readDoubleLE(0);
                        pos = pos+8;
                        break;
                    case 12:
                        tmp = msg.slice(pos,pos+4);
                        let tmpv1 = tmp.readInt32LE(0);
                        pos = pos+4;
                        tmp = msg.slice(pos,pos+2);
                        pos = pos+2;
                        let tmpv2 = tmp.readInt16LE(0);
                        res.variable.data = tmpv1*1000+tmpv2;
                        break;
                    case 13:
                        tmp = msg.slice(pos,pos+4);
                        len = tmp.readInt32LE(0);
                        pos = pos+4;
                        tmp = msg.slice(pos,pos+len);
                        pos = pos+len;
                        res.variable.data = /*tmp.toString('utf8', 0, len);*/iconv.decode(tmp, 'gbk');
                        break;
                    case 14:
                        tmp = msg.slice(pos,pos+4);
                        len = tmp.readInt32LE(0);
                        pos = pos+4;
                        tmp = msg.slice(pos,pos+len*2);
                        pos = pos+len*2;
                        res.variable.data = /*tmp.toString('utf8', 0, len);*/iconv.decode(tmp, 'UTF-16');
                        break;
                    case 15 :
                        tmp = msg.slice(pos,pos+4);
                        len = tmp.readInt32LE(0);
                        pos = pos+4;
                        tmp = msg.slice(pos,pos+len);
                        pos = pos+len;
                        res.variable.data = tmp.toString('utf8', 0, len);
                        break;
                    default:
                        break;   
                    }

                res.pos = pos;
                return res;
            
            };
            serilize(arrJson){
                let msgHeader = Buffer.alloc(17);
                msgHeader.writeInt16LE(0x5a5a,0);
                msgHeader.writeUInt32LE(0,2);
                msgHeader.writeInt16LE(66,6);
                msgHeader.writeUInt32LE(1,8);
                msgHeader.writeInt16LE(handle,12);
                msgHeader.writeUInt8(0,14);
                msgHeader.writeInt16LE(10,15);

                let startTime48Buf = Buffer.alloc(6);
               
                let stime = (new Date(arrJson.startTime)).getTime();
                let sec32 = parseInt(stime/1000);
                let milc16 = stime - 1000*sec32;
                startTime48Buf.writeUInt32LE(sec32,0);
                startTime48Buf.writeInt16LE(milc16,4);

                let endTime48Buf = Buffer.alloc(6);
                let etime = (new Date(arrJson.endTime)).getTime();
                sec32 = parseInt(etime/1000);
                milc16 = etime - 1000*sec32;
                endTime48Buf.writeUInt32LE(sec32,0);
                endTime48Buf.writeInt16LE(milc16,4);

                let intervalTime48Buf = Buffer.alloc(6);
                intervalTime48Buf.writeUInt32LE(arrJson.intervalTime,0);
                intervalTime48Buf.writeInt16LE(0,4);

                let count = arrJson.count;
                let aggregateCount32Buf = Buffer.alloc(2);
                aggregateCount32Buf.writeInt16LE(count);
                let aggregateBuf = Buffer.alloc(4*count);
                let pos = 0;
                for(let i=0; i<count; i++){
                    aggregateBuf.writeUInt32LE(arrJson.aggregateList[i],pos);
                    pos += 4;
                }

                let tagCount32Buf = Buffer.alloc(4);
                tagCount32Buf.writeUInt32LE(count,0);
                let tags32Buf = Buffer.alloc(count*4);
                pos = 0;
                for(let i=0; i<count; i++){
                    tags32Buf.writeUInt32LE(arrJson.tagIds[i],pos);
                    pos += 4;
                }

                let tagIdType8Buf = Buffer.alloc(1);
                tagIdType8Buf.writeInt8(0);
                let field8Buf = Buffer.alloc(1);
                field8Buf.writeUInt8(7,0);

                let msgEnd = Buffer.from(['0x6a','0x6a']);
                let sendMsg = Buffer.concat([msgHeader,startTime48Buf,endTime48Buf,intervalTime48Buf,aggregateCount32Buf,aggregateBuf,tagCount32Buf,tags32Buf,tagIdType8Buf,field8Buf,msgEnd]);
                sendMsg.writeUInt32LE(sendMsg.length,2);
                return sendMsg;		
            };
            unserilize(data){


				if(data == null){
					return {retCode:-1};
				}
                let arrJson = {};
                let apiStatus=data.slice(17,21);
                arrJson.retCode = apiStatus.readInt32LE(0);
                
                if(apiStatus.compare(Buffer.from([0x00,0x00,0x00,0x00]))!=0){
                    if(apiStatus.compare(Buffer.from([0xe3,0xb1,0xff,0xff]))!=0){
                        return arrJson;
                    }
                }

                let pos = 21;

                let tagsCount = data.readInt32LE(pos);
                pos += 4;
                

                arrJson.tagHisData = [];
                for(let i=0; i<tagsCount; i++){
                    arrJson.tagHisData[i] = {};
                    arrJson.tagHisData[i].tagId = data.readInt32LE(pos);
                    pos += 4;
                    arrJson.tagHisData[i].aggregate = data.readInt32LE(pos);
                    pos += 4;
                    let dataCount = data.readInt32LE(pos);
                    pos += 4;
                    arrJson.tagHisData[i].tagDatas = [];
                    let sec32;
                    let milc16;
                    let t;
                    let retVar;
                    for(let j=0; j<dataCount;j++){
                        arrJson.tagHisData[i].tagDatas[j] = {};
                        sec32 = data.readInt32LE(pos);
                        pos += 4;
                        milc16 = data.readInt16LE(pos);
                        pos += 2;
                        t = (new Date(sec32*1000+milc16)).toLocaleString();
                        arrJson.tagHisData[i].tagDatas[j].time = t;
                        arrJson.tagHisData[i].tagDatas[j].value = {};
                        retVar = this.unserializeVar(data,pos);
                        pos = retVar.pos;
                        arrJson.tagHisData[i].tagDatas[j].value.dataType = retVar.variable.dataType
                        arrJson.tagHisData[i].tagDatas[j].value.data = retVar.variable.data;
                        arrJson.tagHisData[i].tagDatas[j].quality = data.readInt32LE(pos);
                        pos += 4;
                    }

                    if(apiStatus.compare(Buffer.from([0xe3,0xb1,0xff,0xff]))==0){
                            let statusBadCountBuf = data.slice(pos,pos+4);
                            pos = pos + 4;
                            let statusBadCount32 = statusBadCountBuf.readInt32LE(0);
                            for(let t=0; t<statusBadCount32; t++){
                            let badstatusBuf = data.slice(pos,pos+4);
                            pos = pos + 4;
                            let badstatus32 = badstatusBuf.readInt32LE(0);
                            arrJson.status[t] = badstatus32;
                        }
                    }
                }

                return arrJson;
            };
        }, 		
        "getServerTime":class{
            constructor(){
				this.packetType = 10;
            };
            serilize(jsonObj){
                this.parent.options.getServerTime = true;
                let msgHeader = Buffer.alloc(17);
                msgHeader.writeInt16LE(0x5a5a,0);
                msgHeader.writeUInt32LE(0,2);
                msgHeader.writeInt16LE(10,6);
                msgHeader.writeUInt32LE(1,8);
                msgHeader.writeInt16LE(handle,12);
                msgHeader.writeUInt8(0,14);
                msgHeader.writeInt16LE(10,15);
                let msgEnd = Buffer.from(['0x6a','0x6a']);
                let sendMsg = Buffer.concat([msgHeader,msgEnd]);
                sendMsg.writeUInt32LE(sendMsg.length,2);
                return sendMsg;		
            };
            unserilize(data){
				if(data == null){
					return {};
				}
				
                let arrJson = {};
                let apiStatus=data.slice(17,21);
                arrJson.retCode = apiStatus.readInt32LE(0);
                
                if(arrJson.retCode!=0){
                    return arrJson;
                }
                
                let secondBuf32 = Buffer.from(data.slice(21,25));
                let millisSecBuf16 = Buffer.from(data.slice(25,27));
                let d = new Date(secondBuf32.readInt32LE(0)*1000+millisSecBuf16.readInt16LE(0));
                arrJson.time =  d.toLocaleString();
                return arrJson;
            };
        }, 
        "getAlarmAck":class{
            constructor(){
				this.packetType = 84;
            };
            serilize(arrJson){
                let msgHeader = Buffer.alloc(17);
                msgHeader.writeInt16LE(0x5a5a,0);
                msgHeader.writeUInt32LE(0,2);
                msgHeader.writeInt16LE(84,6);
                msgHeader.writeUInt32LE(1,8);
                msgHeader.writeInt16LE(handle,12); 
                msgHeader.writeUInt8(0,14);
                msgHeader.writeInt16LE(10,15);
                
                
                let t = new Date(arrJson.ackTime);
                let tv = t.getTime();
                let ackUserId16Buf = Buffer.alloc(2);
                ackUserId16Buf.writeInt16LE(arrJson.ackUserId,0);
                let ackTime48Buf = Buffer.alloc(6);
                ackTime48Buf.writeUInt32LE(parseInt(tv/1000),0);
                ackTime48Buf.writeInt16LE(tv-1000*parseInt(tv/1000),4);
                let ackContentBuf = [];
                
                if(arrJson.ackContent != undefined){
                    //ackContentBuf = Buffer.from(arrJson.ackContent); 修改于3-26 用于支持中文
                    ackContentBuf = iconv.encode(arrJson.ackContent,'gbk');//修改于3-26 用于支持中文
                }
                
                let ackContentLen = ackContentBuf.length;
                if(ackContentLen == 0){
                    ackContentLen = 0xffffffff;
                }
                let ackContentLen32Buf = Buffer.alloc(4);
                ackContentLen32Buf.writeUInt32LE(ackContentLen,0);
                let alarmCount32Buf = Buffer.alloc(4);
                alarmCount32Buf.writeUInt32LE(arrJson.alarmIds.length,0);
                let pos = 0;
                let alarmIds32Buf = Buffer.alloc(4*arrJson.alarmIds.length);
                for(let i=0;i<arrJson.alarmIds.length;i++){
                    alarmIds32Buf.writeUInt32LE(arrJson.alarmIds[i],pos);
                    pos += 4;
                }

                let msgEnd = Buffer.from(['0x6a','0x6a']);
                if(ackContentBuf.length != 0){
                    let sendMsg = Buffer.concat([msgHeader,ackUserId16Buf,ackTime48Buf,ackContentLen32Buf,ackContentBuf,alarmCount32Buf,alarmIds32Buf,msgEnd]);
                    sendMsg.writeUInt32LE(sendMsg.length,2);
                    return sendMsg;
                }else{
                    let sendMsg = Buffer.concat([msgHeader,ackUserId16Buf,ackTime48Buf,ackContentLen32Buf,alarmCount32Buf,alarmIds32Buf,msgEnd]);
                    sendMsg.writeUInt32LE(sendMsg.length,2);
                    return sendMsg;
                }
            };
            unserilize(data){
				if(data == null){
					return {};
				}
				
                let arrJson = {};
                let apiStatus=data.slice(17,21);
                arrJson.retCode = apiStatus.readInt32LE(0);
                return arrJson;
            };
        },
        "getAlarmRealQuery":class{
            constructor(){
				this.packetType = 85;
            };
            serilize(arrJson){
                let msgHeader = Buffer.alloc(17);
                msgHeader.writeInt16LE(0x5a5a,0);
                msgHeader.writeUInt32LE(0,2);
                msgHeader.writeInt16LE(85,6);
                msgHeader.writeUInt32LE(1,8);
                msgHeader.writeInt16LE(handle,12);
                msgHeader.writeUInt8(0,14);
                msgHeader.writeInt16LE(10,15);
                
                let alarmFilterField16Buf = Buffer.alloc(2);
                let alarmFilterField16 = 0;
                    
                let alarmId32Buf = Buffer.alloc(4);
                let tagId32Buf = Buffer.alloc(4);
                let userId16Buf = Buffer.alloc(2);
                let topic8Buf = Buffer.alloc(1);
                let haveAcked8Buf = Buffer.alloc(1);
                let ackUserId16Buf = Buffer.alloc(2);
                let lowlevel16Buf = Buffer.alloc(2);
                let highLevel16Buf = Buffer.alloc(2);
                let isQueryOneLevel8Buf = Buffer.alloc(1);
                let strLen32Buf = Buffer.alloc(4);
                let conStrBuf = undefined;
                let msgFilterBody = [];
                if(arrJson.alarmFilterField.alarmId == 1){
                    alarmFilterField16 |= 0b0000000000000001;
                    alarmId32Buf.writeUInt32LE(arrJson.alarmFilter.alarmId);
                    msgFilterBody.push(alarmId32Buf);
                }
            
                if(arrJson.alarmFilterField.tagId == 1){
                    alarmFilterField16 |= 0b0000000000000010;
                    tagId32Buf.writeUInt32LE(arrJson.alarmFilter.tagId);
                    msgFilterBody.push(tagId32Buf);
                }
            
                if(arrJson.alarmFilterField.userId == 1){
                    alarmFilterField16 |= 0b0000000000000100;
                    userId16Buf.writeInt16LE(arrJson.alarmFilter.userId);
                    msgFilterBody.push(userId16Buf);
                }
                   
                if(arrJson.alarmFilterField.topic == 1){
                    alarmFilterField16 |= 0b0000000000100000;
                    topic8Buf.writeUInt8(arrJson.alarmFilter.topic);
                    msgFilterBody.push(topic8Buf);
                }
            
                if(arrJson.alarmFilterField.haveAcked == 1){
                    alarmFilterField16 |= 0b0000000001000000;
                    haveAcked8Buf.writeUInt8(arrJson.alarmFilter.haveAcked);
                    msgFilterBody.push(haveAcked8Buf);
                }
            
            
                if(arrJson.alarmFilterField.ackUserId == 1){
                    alarmFilterField16 |= 0b0000000010000000;
                    ackUserId16Buf.writeInt16LE(arrJson.alarmFilter.ackUserId);
                    msgFilterBody.push(ackUserId16Buf);
                }
            
                if(arrJson.alarmFilterField.lowLevel == 1){
                    alarmFilterField16 |= 0b0000000100000000;
                    lowlevel16Buf.writeInt16LE(arrJson.alarmFilter.lowLevel);
                    msgFilterBody.push(lowlevel16Buf);
                }
            
                if(arrJson.alarmFilterField.highLevel == 1){
                    alarmFilterField16 |= 0b0000001000000000;
                    highLevel16Buf.writeInt16LE(arrJson.alarmFilter.highLevel);
                    msgFilterBody.push(highLevel16Buf);
                }
            
                if(arrJson.alarmFilterField.isQueryOneLevel == 1){
                    alarmFilterField16 |= 0b0000010000000000;
                    isQueryOneLevel8Buf.writeUInt8(arrJson.alarmFilter.isQueryOneLevel);
                    msgFilterBody.push(isQueryOneLevel8Buf);
                }
            
                if(arrJson.alarmFilterField.contentStr == 1){
                    alarmFilterField16 |= 0b0000100000000000;
                    //conStrBuf.Buffer.from(arrJson.alarmFilter.contentStr.data); 修改于3-26 用于支持中文
                    conStrBuf = iconv.encode(arrJson.alarmFilter.contentStr.data,'gbk'); //修改于3-26 用于支持中文
                    strLen32Buf.writeUInt32LE(conStrBuf.length);
                    msgFilterBody.push(strLen32Buf);
                    msgFilterBody.push(conStrBuf);
                }
            
            
                alarmFilterField16Buf.writeInt16LE(alarmFilterField16);
                let alarmField16Buf = Buffer.from(['0xff','0xff']);
                let msgEnd = Buffer.from(['0x6a','0x6a']);
                let msgFilterBodyBuf = Buffer.concat(msgFilterBody);
                let sendMsg = Buffer.concat([msgHeader,alarmFilterField16Buf,msgFilterBodyBuf,alarmField16Buf,msgEnd]);
                sendMsg.writeUInt32LE(sendMsg.length,2);
                return sendMsg;   
            };
            unserilize(data){
				if(data == null){
					return {};
				}
				
                let arrJson = {};
                let apiStatus=data.slice(17,21);
                arrJson.retCode = apiStatus.readInt32LE(0);
                if(apiStatus.compare(Buffer.from([0x00,0x00,0x00,0x00]))!=0){
                    if(apiStatus.compare(Buffer.from([0xe3,0xb1,0xff,0xff]))!=0){            
                        return arrJson;
                    }  
                }        
                        
                let nCount32Buf = data.slice(21,25);
                let nCount32 = nCount32Buf.readInt32LE(0);
                let pos = 25;
                        
                if(nCount32 > 0){
                    arrJson.alarms = [];
                }
            
                for(let i=0;i<nCount32;i++){
                    arrJson.alarms[i] = {};
                    let alarmId32Buf = data.slice(pos,pos+4);
                    pos += 4;
                    arrJson.alarms[i].alarmId = alarmId32Buf.readInt32LE(0);
            
                    let tagId32Buf = data.slice(pos,pos+4);
                    pos +=4;
                    arrJson.alarms[i].tagId = tagId32Buf.readInt32LE(0);
            
                    let userId16Buf = data.slice(pos,pos+2);
                    pos += 2;
                    arrJson.alarms[i].userId = userId16Buf.readInt16LE(0);
            
                    let apptype8Buf = data.slice(pos,pos+1);
                    pos += 1;
                    arrJson.alarms[i].appType = apptype8Buf.readUInt8(0);
            
                    let level8Buf = data.slice(pos,pos+1);
                    pos += 1;
                    arrJson.alarms[i].level = level8Buf.readUInt8(0);
            
                    let topic8Buf = data.slice(pos,pos+1);
                    pos += 1;
                    arrJson.alarms[i].topic = topic8Buf.readUInt8(0);
            
                    let needAck8Buf = data.slice(pos,pos+1);
                    pos += 1;
                    arrJson.alarms[i].needAck = needAck8Buf.readUInt8(0);
            
                    let haveAcked8Buf = data.slice(pos,pos+1);
                    pos += 1;
                    arrJson.alarms[i].haveAcked = haveAcked8Buf.readUInt8(0);
            
                    let startTimeSec32Buf = data.slice(pos,pos+4);
                    pos += 4;
                    let startTimeMillsec16Buf = data.slice(pos,pos+2);
                    pos += 2;
                    arrJson.alarms[i].startTime = startTimeSec32Buf.readUInt32LE(0)*1000+startTimeMillsec16Buf.readUInt16LE(0);
            
                    let endTimeSec32Buf = data.slice(pos,pos+4);
                    pos += 4;
                    let endTimeMillsec16Buf = data.slice(pos,pos+2);
                    pos += 2;
                    arrJson.alarms[i].endTime = endTimeSec32Buf.readUInt32LE(0)*1000+endTimeMillsec16Buf.readUInt16LE(0);
            
                    let strLen32Buf = data.slice(pos,pos+4);
                    pos += 4;
                    let strLen32 = strLen32Buf.readUInt32LE(0);
                    //arrJson.alarms[i].valueStr = data.slice(pos,pos+strLen32).toString(); 修改于3-26 用于支持中文
                    arrJson.alarms[i].valueStr = iconv.decode(data.slice(pos,pos+strLen32), 'gbk');//修改于3-26 用于支持中文
                    pos += strLen32;
            
                    strLen32Buf = data.slice(pos,pos+4);
                    pos += 4;
                    strLen32 = strLen32Buf.readUInt32LE(0);
                    //arrJson.alarms[i].contentStr = data.slice(pos,pos+strLen32).toString(); 修改于3-26 用于支持中文
                    arrJson.alarms[i].contentStr = iconv.decode(data.slice(pos,pos+strLen32),'gbk'); //修改于3-26 用于支持中文
                    pos += strLen32;
            
                    let ackUserId16Buf = data.slice(pos,pos+2);
                    pos += 2;
                    arrJson.alarms[i].ackUserId = ackUserId16Buf.readUInt16LE(0);
            
                    let timeSec32Buf = data.slice(pos,pos+4);
                    pos += 4;
                    let timeMillsec16Buf = data.slice(pos,pos+2);
                    pos += 2;
                    arrJson.alarms[i].ackTime = timeSec32Buf.readUInt32LE(0)*1000+timeMillsec16Buf.readUInt16LE(0);
            
                    strLen32Buf = data.slice(pos,pos+4);
                    pos += 4;
                    strLen32 = strLen32Buf.readUInt32LE(0);
                    //arrJson.alarms[i].ackContentStr = data.slice(pos,pos+strLen32).toString(); 修改于3-26 用于支持中文
                    arrJson.alarms[i].ackContentStr = iconv.decode(data.slice(pos,pos+strLen32),'gbk'); //修改于3-26 用于支持中文
                    pos += strLen32;
                }
                
                return arrJson;    
            };
        },
        "getRealWrite":class{
            constructor(){
				this.packetType = 55;
            };
            serilize(arrJson){
                let msgHeader = Buffer.alloc(17);
                msgHeader.writeInt16LE(0x5a5a,0);
                msgHeader.writeUInt32LE(0,2);
                msgHeader.writeInt16LE(55,6);
                msgHeader.writeUInt32LE(1,8);
                msgHeader.writeInt16LE(handle,12); 
                msgHeader.writeUInt8(0,14);
                msgHeader.writeInt16LE(10,15);
                
                let t = new Date(arrJson.time);
                let tv = t.getTime();
                
                let tagIdFiled8Buf = Buffer.alloc(1);
                tagIdFiled8Buf.writeUInt8(255);
                let msgEnd = Buffer.from(['0x6a','0x6a']);
                let iTagId32Buf = Buffer.alloc(4);
                iTagId32Buf.writeUInt32LE(arrJson.id);
                let psTimeSec32Buf = Buffer.alloc(4);
                let psTimeMillSec16Buf = Buffer.alloc(2);
                let psTimeSec32 = parseInt(tv/1000);
                let psTimeMillSec16 = tv - psTimeSec32*1000;
                psTimeSec32Buf.writeUInt32LE(psTimeSec32,0)
                psTimeMillSec16Buf.writeUInt16LE(psTimeMillSec16,0);
                let psQuality16Buf = Buffer.alloc(2);
                psQuality16Buf.writeInt16LE(arrJson.quality,0);
                let dateValueBuf = Buffer.alloc(1);
                let dataType = arrJson.data.dataType;
                let dataTypeBuf = Buffer.alloc(1);
                let tmpsec32Buf;
                let tmpmilldec16Buf;
                let timemill16 = 0;
                let len = 0;
                let lenBuf32;
                let strBuf;
                dataTypeBuf.writeInt8(dataType,0);
                switch(dataType){
                    case 0:	
                        break;
                    case 1:
                        dateValueBuf = Buffer.alloc(1);
                        dateValueBuf.writeUInt8(arrJson.data.value);
                        break;
                    case 2:
                        dateValueBuf = Buffer.alloc(1);
                        dateValueBuf.writeInt8(arrJson.data.value);
                        break;
                    case 3:
                        dateValueBuf = Buffer.alloc(1);
                        dateValueBuf.writeUInt8(arrJson.data.value);
                        break;
                    case 4:
                        dateValueBuf = Buffer.alloc(2);
                        dateValueBuf.writeInt16LE(arrJson.data.value);
                        break;
                    case 5:
                        dateValueBuf = Buffer.alloc(2);
                        dateValueBuf.writeUInt16LE(arrJson.data.value);
                        break;
                    case 6:
                        dateValueBuf = Buffer.alloc(4);
                        dateValueBuf.writeUInt32LE(arrJson.data.value);
                        break;
                    case 7:
                        dateValueBuf = Buffer.alloc(4);
                        dateValueBuf.writeUInt32LE(arrJson.data.value);
                        break;
                    case 8:
                        dateValueBuf = Buffer.alloc(8);
                        dateValueBuf.writeIntLE(arrJson.data.value,0,8);
                        break;
                    case 9:
                        dateValueBuf = Buffer.alloc(8);
                        dateValueBuf.writeUIntLE(arrJson.data.value,0,8);
                        break;
                    case 10:
                        dateValueBuf = Buffer.alloc(4);
                        dateValueBuf.writeFloatLE(arrJson.data.value,0);
                        break;
                    case 11:
                        dateValueBuf = Buffer.alloc(8);
                        dateValueBuf.writeDoubleLE(arrJson.data.value,0);
                        break;
                    case 12: 
                        tmpsec32Buf = Buffer.alloc(4);
                        tmpmilldec16Buf = Buffer.alloc(2);
                        tmpsec32Buf.writeUInt32LE(parseInt((arrJson.data.value)/1000),0);
                        timemill16 = arrJson.data.value - parseInt((arrJson.data.value)/1000)*1000;
                        tmpmilldec16Buf.writeInt16LE(timemill16,0);
                        dateValueBuf = Buffer.concat([tmpsec32Buf,tmpmilldec16Buf]);
                        break;
                    case 13:
                        //strBuf = Buffer.from(arrJson.data.value); 修改于3-26 用于支持中文
                        strBuf = iconv.encode(arrJson.data.value,'gbk');//修改于3-26 用于支持中文
                        lenBuf32 = Buffer.alloc(4);
                        lenBuf32.writeUInt32LE(strBuf.length,0);
                        dateValueBuf = Buffer.concat([lenBuf32,strBuf]);
                        break;
                    case 14:
                        strBuf = Buffer.from(arrJson.data.value);
                        lenBuf32 = Buffer.alloc(4);
                        lenBuf32.writeUInt32LE(strBuf.length,0);
                        dateValueBuf = Buffer.concat([lenBuf32,strBuf]);
                        break;
                    case 15 :
                        strBuf = Buffer.from(arrJson.data.value);
                        lenBuf32 = Buffer.alloc(4);
                        lenBuf32.writeUInt32LE(strBuf.length,0);
                        dateValueBuf = Buffer.concat([lenBuf32,strBuf]);
                        break;
                    default:
                        break;
                }
                    
                let sendMsg = Buffer.concat([msgHeader,iTagId32Buf,tagIdFiled8Buf,psTimeSec32Buf,psTimeMillSec16Buf,dataTypeBuf,dateValueBuf,psQuality16Buf,msgEnd]);
                sendMsg.writeUInt32LE(sendMsg.length,2);
                return sendMsg;
            };
            unserilize(data){
				if(data == null){
					return {};
				}
				
                let apiStatus = data.slice(17,21);
                let apiCode = apiStatus.readInt32LE(0);
                let arrJson = {};
                arrJson.retCode = apiCode;
                return arrJson;
            };
        },  
        "getIdsByLongName":class{
            constructor(){
                this.packetType = 38;
            };
            serilize(arrJson){
                let msgHeader = Buffer.alloc(17);
                msgHeader.writeInt16LE(0x5a5a,0);
                msgHeader.writeUInt32LE(0,2);
                msgHeader.writeInt16LE(38,6);
                msgHeader.writeUInt32LE(1,8);
                msgHeader.writeInt16LE(handle,12);
                msgHeader.writeUInt8(0,14);
                msgHeader.writeInt16LE(10,15);
                    
               //let bufTagLongName = Buffer.from(strTagName);
               let tagNameLen = arrJson.length;
               let tagNameLen32Buf =  Buffer.alloc(4);
               tagNameLen32Buf.writeUInt32LE(tagNameLen);
               let tagNamesBufs = [];
               for(let i=0; i<tagNameLen;i++){
                    let bufTagLongName = iconv.encode(arrJson[i],'gbk');
                    let len = bufTagLongName.length;
                    let len32Buf = Buffer.alloc(4);
                    len32Buf.writeUInt32LE(len);
                    tagNamesBufs.push(len32Buf);
                    tagNamesBufs.push(bufTagLongName);
               }

               let tagNamesBuf = Buffer.concat(tagNamesBufs);
               let msgEnd = Buffer.from(['0x6a','0x6a']);
               let sendMsg = Buffer.concat([msgHeader,tagNameLen32Buf,tagNamesBuf,msgEnd]);
               sendMsg.writeUInt32LE(sendMsg.length,2);
               return sendMsg;
            };
            unserilize(data){
                if(data == null){
                    return {};
                }
                let arrJson = {};
                let apiStatus= data.slice(17,21);
                arrJson.retCode = apiStatus.readInt32LE(0);

                if(apiStatus.compare(Buffer.from([0x00,0x00,0x00,0x00]))!=0){
                    if(apiStatus.compare(Buffer.from([0xe3,0xb1,0xff,0xff]))!=0){
                        return arrJson;
                    }
                }
       
                let tagIdCountBuf = data.slice(21,25);
                let tagIdCount = tagIdCountBuf.readInt32LE();
                let pos = 25;
                if(tagIdCount>0){
                    arrJson.tagIds = [];
                }
                for(let i=0; i<tagIdCount; i++){
                    let tagId = (data.slice(pos,pos+4)).readInt32LE();
                    pos = pos + 4;
                    arrJson.tagIds.push(tagId);
                }
                return arrJson;
        };
    },   
    "getIdByLongName":class{
        constructor(){
			this.packetType = 37;
        };
        serilize(arrJson){
            let strTagName = arrJson.tagName;
            let msgHeader = Buffer.alloc(17);
            msgHeader.writeInt16LE(0x5a5a,0);
            msgHeader.writeUInt32LE(0,2);
            msgHeader.writeInt16LE(37,6);
            msgHeader.writeUInt32LE(1,8);
            msgHeader.writeInt16LE(handle,12);
            msgHeader.writeUInt8(0,14);
            msgHeader.writeInt16LE(10,15);
                
           //let bufTagLongName = Buffer.from(strTagName);
		   let bufTagLongName = iconv.encode(strTagName,'gbk');
           let bufTagLongNameLen = Buffer.alloc(4);
           bufTagLongNameLen.writeUInt32LE(bufTagLongName.length,0);
           let msgEnd = Buffer.from(['0x6a','0x6a']);
           let sendMsg = Buffer.concat([msgHeader,bufTagLongNameLen,bufTagLongName,msgEnd]);
           sendMsg.writeUInt32LE(sendMsg.length,2);
           return sendMsg;
        };
        unserilize(data){
			if(data == null){
				return {};
			}
			
            let arrJson = {};
            let apiStatus= data.slice(17,21);
            arrJson.retCode = apiStatus.readInt32LE(0);
            if(arrJson.retCode != 0){
                return arrJson;
            }
                
            let tagIdBuf = data.slice(21,25);
            let tagId = tagIdBuf.readInt32LE();
            arrJson.id = tagId;
            return arrJson;
        };
    },
        "getTagListProps":class{
            constructor(){
				this.packetType = 45;
            };
            unserializeVar(msg, pos)
            {
                let res = {};
                res.variable = {};
                res.pos = 0;
                let type8Buf = msg.slice(pos,pos+1);
                pos += 1; 
                res.variable.dataType = type8Buf.readUInt8(0);
                let tmpData;
                let tmp;
                let len;
                switch(res.variable.dataType)
                {
                    case 0:	
                        break;
                    case 1:
                        tmpData = msg.slice(pos,pos+1);
                        pos = pos+1;
                        res.variable.data = tmpData.readUInt8(0);
                        break;
                    case 2:
                        tmpData = msg.slice(pos,pos+1);
                        res.variable.data = tmpData.readInt8(0);
                        pos = pos+1;
                        break;
                    case 3:
                        tmpData = msg.slice(pos,pos+1);
                        res.variable.data = tmpData.readUInt8(0);
                        pos = pos+1;
                        break;
                    case 4:
                        tmpData = msg.slice(pos,pos+2);
                        res.variable.data = tmpData.readInt16LE(0);
                        pos = pos+2;
                        break;
                    case 5:
                        tmpData = msg.slice(pos,pos+2);
                        res.variable.data = tmpData.readUInt16LE(0);
                        pos = pos + 2;
                        break;
                    case 6:
                        tmpData = msg.slice(pos,pos+4);
                        res.variable.data = tmpData.readInt32LE(0);
                        pos = pos+4;
                        break;
                    case 7:
                        tmpData = msg.slice(pos,pos+4);
                        res.variable.data = tmpData.readUInt32LE(0);
                        pos = pos+4;
                        break;
                    case 8:
                        tmpData = msg.slice(pos,pos+8);
                        res.variable.data = tmpData.readIntLE(0,8);
                        pos = pos+8;
                        break;
                    case 9:
                        tmpData = msg.slice(pos,pos+8);
                        res.variable.data = tmpData.readUIntLE(0,8);
                        pos = pos+8;
                        break;
                    case 10:
                        tmpData = msg.slice(pos,pos+4);
                        res.variable.data = tmpData.readFloatLE(0);
                        pos = pos+4;
                        break;;
                    case 11:
                        tmpData = msg.slice(pos,pos+8);
                        res.variable.data = tmpData.readDoubleLE(0);
                        pos = pos+8;
                        break;
                    case 12:
                        tmp = msg.slice(pos,pos+4);
                        let tmpv1 = tmp.readInt32LE(0);
                        pos = pos+4;
                        tmp = msg.slice(pos,pos+2);
                        pos = pos+2;
                        let tmpv2 = tmp.readInt16LE(0);
                        res.variable.data = tmpv1*1000+tmpv2;
                        break;
                    case 13:
                        tmp = msg.slice(pos,pos+4);
                        len = tmp.readInt32LE(0);
                        pos = pos+4;
                        tmp = msg.slice(pos,pos+len);
                        pos = pos+len;
                        res.variable.data = /*tmp.toString('utf8', 0, len);*/iconv.decode(tmp, 'gbk');
                        break;
                    case 14:
                        tmp = msg.slice(pos,pos+4);
                        len = tmp.readInt32LE(0);
                        pos = pos+4;
                        tmp = msg.slice(pos,pos+len*2);
                        pos = pos+len*2;
                        res.variable.data = tmp.toString('utf8', 0, len);
                        break;
                    case 15 :
                        tmp = msg.slice(pos,pos+4);
                        len = tmp.readInt32LE(0);
                        pos = pos+4;
                        tmp = msg.slice(pos,pos+len);
                        pos = pos+len;
                        res.variable.data = tmp.toString('utf8', 0, len);
                        break;
                    default:
                        break;   
                    }

                res.pos = pos;
                return res;
            
            };
            serializeVar(type,data)
            {
                let retBuf;
                let dataBuf;
                let lenBuf32;
                let strBuf;
                
                let type8Buf = Buffer.alloc(1);
                type8Buf.writeUInt8(type);
                switch(type){
                    case 0:	
                        break;
                    case 1:
                        dataBuf = Buffer.alloc(1);
                        dataBuf.writeUInt8(data);
                        break;
                    case 2:
                        dataBuf = Buffer.alloc(1);
                        dataBuf.writeInt8(data);
                        break;
                    case 3:
                        dataBuf = Buffer.alloc(1);
                        dataBuf.writeUInt8(data);
                        break;
                    case 4:
                        dataBuf = Buffer.alloc(2);
                        dataBuf.writeInt16LE(data);
                        break;
                    case 5:
                        dataBuf = Buffer.alloc(2);
                        dataBuf.writeUInt16LE(data);
                        break;
                    case 6:
                        dataBuf = Buffer.alloc(4);
                        dataBuf.writeUInt32LE(data);
                        break;
                    case 7:
                        dataBuf = Buffer.alloc(4);
                        dataBuf.writeUInt32LE(data);
                        break;
                    case 8:
                        dataBuf = Buffer.alloc(8);
                        dataBuf.writeIntLE(data,0,8);
                        break;
                    case 9:
                        dataBuf = Buffer.alloc(8);
                        dataBuf.writeUIntLE(data,0,8);
                        break;
                    case 10:
                        dataBuf = Buffer.alloc(4);
                        dataBuf.writeFloatLE(data,0);
                        break;
                    case 11:
                        dataBuf = Buffer.alloc(8);
                        dataBuf.writeDoubleLE(data,0);
                        break;
                    case 12: 
                        let tmpsec32Buf = Buffer.alloc(4);
                        let tmpmilldec16Buf = Buffer.alloc(2);
                        tmpsec32Buf.writeUInt32LE(parseInt(data/1000),0);
                        let timemill16 = data - parseInt(data/1000)*1000;
                        tmpmilldec16Buf.writeInt16LE(timemill16,0);
                        dataBuf = Buffer.concat([tmpsec32Buf,tmpmilldec16Buf]);
                        break;
                    case 13:
                        strBuf = /*Buffer.from(data)*/iconv.encode(data,'gbk'); //
                        lenBuf32 = Buffer.alloc(4);
                        lenBuf32.writeUInt32LE(strBuf.length,0);
                        dataBuf = Buffer.concat([lenBuf32,strBuf]);
                        break;
                    case 14:
                        strBuf = Buffer.from(data);
                        lenBuf32 = Buffer.alloc(4);
                        lenBuf32.writeUInt32LE(strBuf.length,0);
                        dataBuf = Buffer.concat([lenBuf32,strBuf]);
                        break;
                    case 15:
                        strBuf = Buffer.from(data);
                        lenBuf32 = Buffer.alloc(4);
                        lenBuf32.writeUInt32LE(strBuf.length,0);
                        dataBuf = Buffer.concat([lenBuf32,strBuf]);
                        break;
                    default:
                        break;
                }
                
                retBuf = Buffer.concat([type8Buf,dataBuf]);
                return retBuf;
            };
            serilize(arrJson){
                let msgHeader = Buffer.alloc(17);
                msgHeader.writeInt16LE(0x5a5a,0);
                msgHeader.writeUInt32LE(0,2);
                msgHeader.writeInt16LE(45,6);
                msgHeader.writeUInt32LE(1,8);
                msgHeader.writeInt16LE(handle,12);
                msgHeader.writeUInt8(0,14);
                msgHeader.writeInt16LE(10,15);
                
                let tagCount32Buf = Buffer.alloc(4);
                let tagCount32 = arrJson.tagIds.length;
                tagCount32Buf.writeUInt32LE(tagCount32);
                if(tagCount32 >0){
                    let tagIds32Buf = Buffer.alloc(tagCount32*4);
                    let pos = 0;
                    for(let i=0;i<tagCount32;i++){
                        tagIds32Buf.writeUInt32LE(arrJson.tagIds[i],pos);
                        pos += 4;
                    }
        
                    let propCount16Buf = Buffer.alloc(2);
                    let propCount16 = arrJson.propIds.length;
                    propCount16Buf.writeInt16LE(propCount16,0);
                    let propIds16Buf = Buffer.alloc(propCount16*2);
                    pos = 0;
                    for(let i=0;i<propCount16;i++){
                        propIds16Buf.writeInt16LE(arrJson.propIds[i],pos);
                        pos += 2;
                    }
        
                    let msgEnd = Buffer.from(['0x6a','0x6a']);
                    let sendMsg = Buffer.concat([msgHeader,tagCount32Buf,tagIds32Buf,propCount16Buf,propIds16Buf,msgEnd]);
                    sendMsg.writeUInt32LE(sendMsg.length,2);
                    return sendMsg;
        
                }
                
                return Buffer.alloc(0);
            };
            unserilize(data){
				if(data == null){
					return {};
				}
                let arrJson = {};
                let apiStatus=data.slice(17,21);
                arrJson.retCode = apiStatus.readInt32LE(0);
        
                if(apiStatus.compare(Buffer.from([0xe3,0xb1,0xff,0xff]))!=0 && apiStatus.compare(Buffer.from([0x00,0x00,0x00,0x00]))!=0){
                    return arrJson;
                }
        
                let pos = 21;
                let valueRowCount32Buf = data.slice(pos,pos+4);
                pos += 4;
                let valueColCount32Buf = data.slice(pos,pos+4);
                pos += 4;
                let tagCount = valueRowCount32Buf.readInt32LE(0);
                let propIdCount = valueColCount32Buf.readInt32LE(0);
                arrJson.tagCount = tagCount;
                arrJson.tagPropList = [];
                let retVar;
                
                for(let i=0;i<tagCount;i++){
                    arrJson.tagPropList[i] = [];
                    for(let j=0;j<propIdCount;j++){
                        arrJson.tagPropList[i][j]={};
                        retVar = this.unserializeVar(data,pos);
                        pos = retVar.pos;
                        arrJson.tagPropList[i][j].dataType = retVar.variable.dataType
                        arrJson.tagPropList[i][j].data = retVar.variable.data;
                    }
        
                }
        
            
                arrJson.status = [];
                if(apiStatus.compare(Buffer.from([0xe3,0xb1,0xff,0xff]))==0){
                    let apiStatus32Buf = data.slice(pos,pos+4);
                    pos += 4;
                    let apiStatusCount = apiStatus32Buf.readInt32LE(0);
                    for(let i=0;i<apiStatusCount;i++){
                        let status32Buf = data.slice(pos,pos+4);
                        pos += 4;
                        arrJson.status[i] = status32Buf.readInt32LE(0);
                    }
                }
                return arrJson;
            };
        },
       "getTagQueryIds":class{
            constructor(){
				this.packetType = 47;
            };
            serilize(arrJson){
                let msgHeader = Buffer.alloc(17);
                msgHeader.writeInt16LE(0x5a5a,0);
                msgHeader.writeUInt32LE(0,2);
                msgHeader.writeInt16LE(47,6);
                msgHeader.writeUInt32LE(1,8);
                msgHeader.writeInt16LE(handle,12);
                msgHeader.writeUInt8(0,14);
                msgHeader.writeInt16LE(10,15);
                
                let rootTagId32Buf   = Buffer.alloc(4);
                let queryLevel16Buf  = Buffer.alloc(2);
                let querySelf8Buf    = Buffer.alloc(1);
                let resultStart32Buf = Buffer.alloc(4);
                let resultNum32Buf   = Buffer.alloc(4);
                let propCount16Buf   = Buffer.alloc(2);
                
                    
                rootTagId32Buf.writeUInt32LE(arrJson.tagId,0);
                if(arrJson.queryLevel==0 || arrJson.queryLevel==undefined){
                    queryLevel16Buf.writeUInt16LE(0xffff,0);
                }else{
                    queryLevel16Buf.writeUInt16LE(arrJson.queryLevel,0);
                }
        
                querySelf8Buf.writeUInt8(0,0);
                resultStart32Buf.writeUInt32LE(0,0);
                resultNum32Buf.writeUInt32LE(0,0);
                propCount16Buf.writeInt16LE(1,0);
                let proId16Buf = Buffer.alloc(2);
                proId16Buf.writeInt16LE(0,0);
                
                let filterProValueCount16Buf = Buffer.alloc(2);
                let msgEnd = Buffer.from(['0x6a','0x6a']);
                let sendMsg = Buffer.concat([msgHeader,rootTagId32Buf,queryLevel16Buf,querySelf8Buf,resultStart32Buf,resultNum32Buf,propCount16Buf,proId16Buf,filterProValueCount16Buf,msgEnd]);
                sendMsg.writeUInt32LE(sendMsg.length,2);
                return sendMsg;
            };
            unserilize(data){
				if(data == null){
					return {};
				}
				
                let arrJson = {};
                let apiStatus=data.slice(17,21);
                arrJson.retCode = apiStatus.readInt32LE(0);
                if(apiStatus.compare(Buffer.from([0x00,0x00,0x00,0x00]))!=0){
                    if(apiStatus.compare(Buffer.from([0xe3,0xb1,0xff,0xff]))!=0){
                        return arrJson;
                    }
                }
        
                let pos = 21;
                let tagCount32Buf = data.slice(pos,pos+4);
                pos += 4;
                let tagCount32 = tagCount32Buf.readInt32LE(0);
                let propCount16;
                arrJson.ids = [];
                if(tagCount32 > 0){
                    
                    for(let i=0;i<tagCount32;i++){
                        let propCount16Buf = data.slice(pos,pos+2);
                        pos += 2;
                        propCount16 = propCount16Buf.readInt16LE(0);
                     
                        for(let j=0;j<propCount16;j++){
                            pos += 2;
                            let dataType8Buf = data.slice(pos,pos+1);
                            pos += 1;
                            if(dataType8Buf.readUInt8(0) != 7){
                                 return arrJson;
                            }
                            let tagIdRet32Buf = data.slice(pos,pos+4);
                            pos += 4;
                            arrJson.ids[i] = tagIdRet32Buf.readInt32LE(0);
                        }
                        
                    }
                }

                return arrJson;    
                    
            };
        },   
        "getRealWriteList":class{
            constructor(){
				this.packetType = 57;
            };
            serilize(arrJson){
                let msgHeader = Buffer.alloc(17);
                msgHeader.writeInt16LE(0x5a5a,0);
                msgHeader.writeUInt32LE(0,2);
                msgHeader.writeInt16LE(57,6);
                msgHeader.writeUInt32LE(1,8);
                msgHeader.writeInt16LE(handle,12);
                msgHeader.writeUInt8(0,14);
                msgHeader.writeInt16LE(10,15);
            
                let count32Buf = Buffer.alloc(4);
                let count32 = arrJson.tagIds.length;
                count32Buf.writeUInt32LE(count32);
                if(count32 >0){
                    let tagIds32Buf = Buffer.alloc(4*count32);
                    let pos = 0;
                    for(let i=0;i<count32;i++){
                        tagIds32Buf.writeUInt32LE(arrJson.tagIds[i],pos);
                        pos += 4;
                    }
        
                    let field8Buf = Buffer.alloc(1);
                    let field8 = 0xff;
                    if(arrJson.timeStamps.length ==0){
                        field8 &= 0xfe;
                    }
                    if(arrJson.qualities.length ==0){
                        field8 &= 0xfb;
                    }
                    
                    field8Buf.writeUInt8(field8,0);
        
                    let dataCount32Buf = Buffer.alloc(4);
                    dataCount32Buf.writeUInt32LE(count32);
                    let dataBufs = [];
                    for(let i=0;i<count32;i++){
                        if(field8 & 0x01){
                            let time48Buf = Buffer.alloc(6);
                            time48Buf.writeUInt32LE(parseInt(arrJson.timeStamps[i]/1000),0);
                            time48Buf.writeInt16LE(arrJson.timeStamps[i]-(parseInt(arrJson.timeStamps[i]/1000))*1000,4);
                            dataBufs.push(time48Buf);
                        }
        
                        let dataType8Buf = Buffer.alloc(1);
                        dataType8Buf.writeUInt8(arrJson.dataValues[i].type);
                        dataBufs.push(dataType8Buf);
                        let dateValueBuf;
                        let strBuf;
                        let lenBuf32; 
                        switch(arrJson.dataValues[i].type){
                            case 0:	
                                break;
                            case 1:
                                dateValueBuf = Buffer.alloc(1);
                                dateValueBuf.writeUInt8(arrJson.dataValues[i].data,0);
                                break;
                            case 2:
                                dateValueBuf = Buffer.alloc(1);
                                dateValueBuf.writeInt8(arrJson.dataValues[i].data,0);
                                break;
                            case 3:
                                dateValueBuf = Buffer.alloc(1);
                                dateValueBuf.writeUInt8(arrJson.dataValues[i].data,0);
                                break;
                            case 4:
                                dateValueBuf = Buffer.alloc(2);
                                dateValueBuf.writeInt16LE(arrJson.dataValues[i].data,0);
                                break;
                            case 5:
                                dateValueBuf = Buffer.alloc(2);
                                dateValueBuf.writeUInt16LE(arrJson.dataValues[i].data,0);
                                break;
                            case 6:
                                dateValueBuf = Buffer.alloc(4);
                                dateValueBuf.writeUInt32LE(arrJson.dataValues[i].data,0);
                                break;
                            case 7:
                                dateValueBuf = Buffer.alloc(4);
                                dateValueBuf.writeUInt32LE(arrJson.dataValues[i].data,0);
                                break;
                            case 8:
                                dateValueBuf = Buffer.alloc(8);
                                dateValueBuf.writeIntLE(arrJson.dataValues[i].data,0,8);
                                break;
                            case 9:
                                dateValueBuf = Buffer.alloc(8);
                                dateValueBuf.writeUIntLE(arrJson.dataValues[i].data,0,8);
                                break;
                            case 10:
                                dateValueBuf = Buffer.alloc(4);
                                dateValueBuf.writeFloatLE(arrJson.dataValues[i].data,0);
                                break;
                            case 11:
                                dateValueBuf = Buffer.alloc(8);
                                dateValueBuf.writeDoubleLE(arrJson.dataValues[i].data,0);
                                break;
                            case 12: 
                                tmpsec32Buf = Buffer.alloc(4);
                                tmpmilldec16Buf = Buffer.alloc(2);
                                tmpsec32Buf.writeUInt32LE(parseInt(arrJson.dataValues[i].data/1000),0);
                                timemill16 = arrJson.dataValues[i].data - parseInt((arrJson.dataValues[i].data)/1000)*1000;
                                tmpmilldec16Buf.writeInt16LE(timemill16,0);
                                dateValueBuf = Buffer.concat([tmpsec32Buf,tmpmilldec16Buf]);
                                break;
                            case 13:
                                //strBuf = Buffer.from(arrJson.dataValues[i].data); 修改于3-26 用于支持中文
                                strBuf = iconv.encode(arrJson.dataValues[i].data,'gbk');//修改于3-26 用于支持中文
                                lenBuf32 = Buffer.alloc(4);
                                lenBuf32.writeUInt32LE(strBuf.length,0);
                                dateValueBuf = Buffer.concat([lenBuf32,strBuf]);
                                break;
                            case 14:
                                //strBuf = Buffer.from(arrJson.dataValues[i].data);//修改于3-26 用于支持中文
                                strBuf = iconv.encode(arrJson.dataValues[i].data,'UTF-16');//修改于3-26 用于支持中文
                                lenBuf32 = Buffer.alloc(4);
                                lenBuf32.writeUInt32LE(strBuf.length,0);
                                dateValueBuf = Buffer.concat([lenBuf32,strBuf]);
                                break;
                            case 15:
                                strBuf = Buffer.from(arrJson.dataValues[i].data);
                                lenBuf32 = Buffer.alloc(4);
                                lenBuf32.writeUInt32LE(strBuf.length,0);
                                dateValueBuf = Buffer.concat([lenBuf32,strBuf]);
                                break;
                            default:
                                break;
        
                        }
                        
                        dataBufs.push(dateValueBuf);
        
                        if(field8 &0x04){
                            let qualities16Buf = Buffer.alloc(2);
                            qualities16Buf.writeInt16LE(arrJson.qualities[i]);
                            dataBufs.push(qualities16Buf);
                        }
                    }
                    
                    let dataValues32Buf = Buffer.concat(dataBufs);
                    let msgEnd = Buffer.from(['0x6a','0x6a']);
                    let sendMsg = Buffer.concat([msgHeader,count32Buf,tagIds32Buf,field8Buf,dataCount32Buf,dataValues32Buf,msgEnd]);
                    sendMsg.writeUInt32LE(sendMsg.length,2);
                    return sendMsg;            
                }
            };
            unserilize(data){
				if(data == null){
					return {};
				}
				
                let arrJson = {};
                let apiStatus=data.slice(17,21);
                arrJson.retCode = apiStatus.readInt32LE(0);
                if(arrJson.retCode == 0){
                    return arrJson;
                }
        
                if(apiStatus.compare(Buffer.from(['0xe3','0xb1','0xff','0xff']))==0){
                    let count32Buf = data.slice(21,25);
                    let count = count32Buf.readInt32LE(0);
                    let pos = 25;
                    arrJson.status=[];
                    for(let i=0;i<count;i++){
                        let code32Buf = data.slice(pos,pos+4);
                        arrJson.status[i] = code32Buf.readInt32LE(0);
                        pos += 4;
                    }
                }
            
                return arrJson;   
            };
        },
        "getRealReadList":class{
            constructor(){
				this.packetType = 56;
            };
            serilize(arrJson){
                let msgHeader = Buffer.alloc(17);
                msgHeader.writeInt16LE(0x5a5a,0);
                msgHeader.writeUInt32LE(0,2);
                msgHeader.writeInt16LE(56,6);
                msgHeader.writeUInt32LE(1,8);
                msgHeader.writeInt16LE(handle,12);
                msgHeader.writeUInt8(0,14);
                msgHeader.writeInt16LE(10,15);
        
                let count32Buf = Buffer.alloc(4);
                let count32 = arrJson.length;
                count32Buf.writeUInt32LE(count32);
                let ids32Buf = Buffer.alloc(4*count32);
                let pos = 0;
                for(let i=0;i<count32;i++){
                    ids32Buf.writeUInt32LE(arrJson[i],pos);
                    pos += 4;
                }
        
                let field8Buf = Buffer.alloc(1);
                field8Buf.writeUInt8(0xff);
                let msgEnd = Buffer.from(['0x6a','0x6a']);
                let sendMsg = Buffer.concat([msgHeader,count32Buf,ids32Buf,field8Buf,msgEnd]);
                sendMsg.writeUInt32LE(sendMsg.length,2);
                return sendMsg;
            };
            unserilize(data){
                    if(data == null){
                        return {};
                    }
                    
                    let apiStatus = data.slice(17,21);
                    let arrJson = {};
                    arrJson.retCode = apiStatus.readInt32LE(0);
                    if(apiStatus.compare(Buffer.from([0,0,0,0]))!=0 && apiStatus.compare(Buffer.from(['0xe3','0xb1','0xff','0xff']))!=0){
                        return arrJson;
                    }
            
                    let pos = 21;
                    let dataCount32Buf = data.slice(pos,pos+4);
                    pos += 4;
                    let dataCount32 = dataCount32Buf.readInt32LE(0);
                    
                    arrJson.dataList = [];
                    for(let i=0;i<dataCount32;i++){
                        arrJson.dataList[i] = {};
                        let sec32Buf = data.slice(pos,pos+4);
                        pos += 4;
                        let millSec16Buf = data.slice(pos,pos+2);
                        pos += 2;
                        let sec32 = sec32Buf.readInt32LE(0);
                        let millsec16 = millSec16Buf.readInt16LE(0);
                        arrJson.dataList[i].time = sec32*1000 + millsec16;
                        let dataType8Buf = data.slice(pos,pos+1);
                        pos += 1;
                        arrJson.dataList[i].psvalue = {};
                        arrJson.dataList[i].psvalue.type = dataType8Buf.readUInt8(0);
                        let tmp;
                        let len;
                        switch(arrJson.dataList[i].psvalue.type){
                            case 0:	
                                arrJson.dataList[i].psvalue.value = 'null';
                                break;
                            case 1:
                                tmp = data.slice(pos,pos+1);
                                pos = pos+1;
                                arrJson.dataList[i].psvalue.value = tmp.readInt8(0);
                                break;
                            case 2:
                                tmp = data.slice(pos,pos+1);
                                pos = pos+1;
                                arrJson.dataList[i].psvalue.value = tmp.readInt8(0);
                                break;
                            case 3:
                                tmp = data.slice(pos,pos+1);
                                pos = pos+1;
                                arrJson.dataList[i].psvalue.value = tmp.readUInt8(0);
                                break;
                            case 4:
                                tmp = data.slice(pos,pos+2);
                                pos = pos+2;
                                arrJson.dataList[i].psvalue.value = tmp.readInt16LE(0);
                                break;
                            case 5:
                                tmp = data.slice(pos,pos+2);
                                pos = pos+2;
                                arrJson.dataList[i].psvalue.value = tmp.readUInt16LE(0);
                                break;
                            case 6:
                                tmp = data.slice(pos,pos+4);
                                pos = pos+4;
                                arrJson.dataList[i].psvalue.value = tmp.readInt32LE(0);
                                break;
                            case 7:
                                tmp = data.slice(pos,pos+4);
                                pos = pos+4;
                                arrJson.dataList[i].psvalue.value = tmp.readUInt32LE(0);
                                break;
                            case 8:
                                tmp = data.slice(pos,pos+8);
                                pos = pos+8;
                                arrJson.dataList[i].psvalue.value = tmp.readIntLE(0, 8);
                                break;
                            case 9:
                                tmp = data.slice(pos,pos+8);
                                pos = pos+8;
                                arrJson.dataList[i].psvalue.value = tmp.readUIntLE(0, 8);
                                break;
                            case 10:
                                tmp = data.slice(pos,pos+4);
                                pos = pos+4;
                                arrJson.dataList[i].psvalue.value = tmp.readFloatLE(0);
                                break;
                            case 11:
                                tmp = data.slice(pos,pos+8);
                                pos = pos+8;
                                arrJson.dataList[i].psvalue.value = tmp.readDoubleLE(0);
                                break;
                            case 12:
                                tmp = data.slice(pos,pos+4);
                                let tmpv1 = tmp.readInt32LE(0);
                                pos = pos+4;
                                tmp = data.slice(pos,pos+2);
                                pos = pos+2;
                                let tmpv2 = tmp.readInt16LE(0);
                                arrJson.dataList[i].psvalue.value = tmpv1*1000+tmpv2;
                                break;
                            case 13:
                                tmp = data.slice(pos,pos+4)
                                len = tmp.readInt32LE(0);
                                pos = pos+4;
                                tmp = data.slice(pos,pos+len);
                                pos = pos+len;
                                arrJson.dataList[i].psvalue.value = /*tmp.toString('utf8', 0, len);*/iconv.decode(tmp, 'gbk');
                                break;
                            case 14:
                                tmp = data.slice(pos,pos+4);
                                len = tmp.readInt32LE(0);
                                pos = pos+4;
                                tmp = data.slice(pos,pos+len*2);
                                pos = pos+len*2;
                                arrJson.dataList[i].psvalue.value = tmp.toString('utf8', 0, len);
                                break;
                            case 15:
                                tmp = data.slice(pos,pos+4);
                                len = tmp.readInt32LE(0);
                                pos = pos+4;
                                tmp = data.slice(pos,pos+len);
                                pos = pos+len;
                                arrJson.dataList[i].psvalue.value = tmp;
                                break;
                            default:
                                break;
                        }
                            
                        let psQualityBuf16 = data.slice(pos,pos+2);
                        pos += 2;
                        let psQuality16 = psQualityBuf16.readInt16LE(0);
                        arrJson.dataList[i].quality = psQuality16;
                    }
            
            
                    if(apiStatus.compare(Buffer.from(['0xe3','0xb1','0xff','0xff']))==0)
                    {
                        let apiStatusCount32Buf = data.slice(pos,pos+4);
                        let apiStatusCount32 = apiStatusCount32Buf.readUInt32LE(0);
                        pos += 4;
                        arrJson.status = [];
                        for(let i=0;i<apiStatusCount32;i++){
                            let status32buf = data.slice(pos,pos+4);
                            pos += 4;
                            let status32 = status32buf.readInt32LE(0);
                            arrJson.status[i] = status32;
                        }
                    }else{
                        arrJson.status = [];
                    }
                    return arrJson;
            };
        },
        "getTagTypeInfos":class{
            constructor(){
				this.packetType = 22;
            };
            serilize(){
                let msgHeader = Buffer.alloc(17);
                msgHeader.writeInt16LE(0x5a5a,0);
                msgHeader.writeUInt32LE(0,2);
                msgHeader.writeInt16LE(22,6);
                msgHeader.writeUInt32LE(1,8);
                msgHeader.writeInt16LE(handle,12);
                msgHeader.writeUInt8(0,14);
                msgHeader.writeInt16LE(10,15);
                let msgEnd = Buffer.from(['0x6a','0x6a']);
                let sendMsg = Buffer.concat([msgHeader,msgEnd]);
                sendMsg.writeUInt32LE(sendMsg.length,2);
                return sendMsg;
            };
            unserilize(data){
				if(data == null){
					return {};
				}
				
                let arrJson = {};
                let apiStatus=data.slice(17,21);
                arrJson.retCode = apiStatus.readInt32LE(0);
                if(apiStatus.compare(Buffer.from([0x00,0x00,0x00,0x00]))!=0){
                    if(apiStatus.compare(Buffer.from([0xe3,0xb1,0xff,0xff]))!=0){
                        return arrJson;
                    }
                }
        
                let pos = 21;
                let tagTypeCountBuf16 = data.slice(pos,pos+2);
                pos += 2;
                arrJson.tagTypeCount = tagTypeCountBuf16.readInt16LE(0);
                arrJson.tagTypeInfoList = [];
                let strLen = 0;
                let strBuf = undefined;
                for(let i=0; i<arrJson.tagTypeCount;i++){
                    arrJson.tagTypeInfoList[i] = {};
                    arrJson.tagTypeInfoList[i].id = (data.slice(pos,pos+2)).readInt16LE(0);
                    pos += 2;
                    strLen = (data.slice(pos,pos+4)).readInt32LE(0);
                    pos += 4;
                    strBuf = data.slice(pos,pos + strLen);
                    arrJson.tagTypeInfoList[i].name = iconv.decode(strBuf, 'gbk');
                    pos += strLen;
                    strLen = (data.slice(pos,pos+4)).readInt32LE(0);
                    pos += 4;
                    strBuf = data.slice(pos,pos + strLen);
                    arrJson.tagTypeInfoList[i].desc = iconv.decode(strBuf, 'gbk');
                    pos += strLen;
                }
                return arrJson;   
            };
        },
        "getTagPropCount":class{
            constructor(){
				this.packetType = 23;
            };
            serilize(tagType){
                let msgHeader = Buffer.alloc(17);
                msgHeader.writeInt16LE(0x5a5a,0);
                msgHeader.writeUInt32LE(0,2);
                msgHeader.writeInt16LE(23,6);
                msgHeader.writeUInt32LE(1,8);
                msgHeader.writeInt16LE(handle,12);
                msgHeader.writeUInt8(0,14);
                msgHeader.writeInt16LE(10,15);
                let tagTypeBuf16 = Buffer.alloc(2);
                tagTypeBuf16.writeInt16LE(tagType,0)
                let msgEnd = Buffer.from(['0x6a','0x6a']);
                let sendMsg = Buffer.concat([msgHeader,tagTypeBuf16,msgEnd]);
                sendMsg.writeUInt32LE(sendMsg.length,2);
                return sendMsg;
            };
            unserilize(data){
				if(data == null){
					return {};
                }
                
                let arrJson = {};
                let apiStatus=data.slice(17,21);
                arrJson.retCode = apiStatus.readInt32LE(0);
                if(apiStatus.compare(Buffer.from([0x00,0x00,0x00,0x00]))!=0){
                    if(apiStatus.compare(Buffer.from([0xe3,0xb1,0xff,0xff]))!=0){
                        return arrJson;
                    }
                }      

                let tagTypePropCountBuf16 = data.slice(21,23);
                arrJson.tagTypePropCount = tagTypePropCountBuf16.readInt16LE(0);
                return arrJson;   
            } 
        },
        "getTagGetPropList":class{
            constructor(){
				this.packetType = 24;
            };
            serilize(tagType){
                let msgHeader = Buffer.alloc(17);
                msgHeader.writeInt16LE(0x5a5a,0);
                msgHeader.writeUInt32LE(0,2);
                msgHeader.writeInt16LE(24,6);
                msgHeader.writeUInt32LE(1,8);
                msgHeader.writeInt16LE(handle,12);
                msgHeader.writeUInt8(0,14);
                msgHeader.writeInt16LE(10,15);
                let tagTypeBuf16 = Buffer.alloc(2);
                tagTypeBuf16.writeInt16LE(tagType,0);
                let msgEnd = Buffer.from(['0x6a','0x6a']);
                let sendMsg = Buffer.concat([msgHeader,tagTypeBuf16,msgEnd]);
                sendMsg.writeUInt32LE(sendMsg.length,2);
                return sendMsg;
            };
            unserilize(data){
				if(data == null){
					return {};
				}
				
                let arrJson = {};
                let apiStatus=data.slice(17,21);
                arrJson.retCode = apiStatus.readInt32LE(0);
                if(apiStatus.compare(Buffer.from([0x00,0x00,0x00,0x00]))!=0){
                    if(apiStatus.compare(Buffer.from([0xe3,0xb1,0xff,0xff]))!=0){
                        return arrJson;
                    }
                }

                let tagTypePropCountBuf16 = data.slice(21,23);
                let tagTypepropCount = tagTypePropCountBuf16.readInt16LE(0);
                let pos = 23;
                arrJson.tagTypeProps = [];
                let strLen = undefined;
                for(let i=0; i<tagTypepropCount; i++){
                    arrJson.tagTypeProps[i] = {};
                    arrJson.tagTypeProps[i].id = (data.slice(pos,pos+2)).readInt16LE(0);
                    pos += 2;
                    strLen = (data.slice(pos,pos+4)).readInt32LE(0);
                    pos += 4;
                    arrJson.tagTypeProps[i].name = iconv.decode(data.slice(pos,pos+strLen), 'gbk');
                    pos += strLen;
                    arrJson.tagTypeProps[i].dataType = (data.slice(pos,pos+4)).readInt32LE(0);
                    pos += 4;
                    arrJson.tagTypeProps[i].style = (data.slice(pos,pos+4)).readInt32LE(0);
                    pos += 4;
                    arrJson.tagTypeProps[i].readOnly = (data.slice(pos,pos+1)).readInt8(0);
                    pos += 1;
                    strLen = (data.slice(pos,pos+4)).readInt32LE(0);
                    pos += 4;
                    arrJson.tagTypeProps[i].desc = iconv.decode(data.slice(pos,pos+strLen), 'gbk');
                    pos += strLen;
                }
                return arrJson;   
            };
        },
        "getTagTypeAttrIdByTagAttrName":class{
            constructor(){
				this.packetType = 27;
            };
            serilize(tagAttrName){
                let msgHeader = Buffer.alloc(17);
                msgHeader.writeInt16LE(0x5a5a,0);
                msgHeader.writeUInt32LE(0,2);
                msgHeader.writeInt16LE(27,6);
                msgHeader.writeUInt32LE(1,8);
                msgHeader.writeInt16LE(handle,12);
                msgHeader.writeUInt8(0,14);
                msgHeader.writeInt16LE(10,15);
                let typeNameLong32Buf = Buffer.alloc(4);
                typeNameLong32Buf.writeUInt32LE(tagAttrName.length);
                let typeNameBuf = Buffer.from(tagAttrName);
                let msgEnd = Buffer.from(['0x6a','0x6a']);
                let sendMsg = Buffer.concat([msgHeader,typeNameLong32Buf,typeNameBuf,msgEnd]);
                sendMsg.writeUInt32LE(sendMsg.length,2);
                return sendMsg;
            };
            unserilize(data){
				if(data == null){
					return {};
				}
				
                let arrJson = {};
                let apiStatus=data.slice(17,21);
                arrJson.retCode = apiStatus.readInt32LE(0);
                if(apiStatus.compare(Buffer.from([0x00,0x00,0x00,0x00]))!=0){
                    if(apiStatus.compare(Buffer.from([0xe3,0xb1,0xff,0xff]))!=0){
                        return arrJson;
                    }
                }

                let tagTypeCountBuf16 = data.slice(21,23);
                arrJson.tagTypeAttrId = tagTypeCountBuf16.readInt16LE(0);
                return arrJson;   
            };
        },
        "getTypeCount":class{
            constructor(){
				this.packetType = 21;
            };
            serilize(){
                let msgHeader = Buffer.alloc(17);
                msgHeader.writeInt16LE(0x5a5a,0);
                msgHeader.writeUInt32LE(0,2);
                msgHeader.writeInt16LE(21,6);
                msgHeader.writeUInt32LE(1,8);
                msgHeader.writeInt16LE(handle,12);
                msgHeader.writeUInt8(0,14);
                msgHeader.writeInt16LE(10,15);
                let msgEnd = Buffer.from(['0x6a','0x6a']);
                let sendMsg = Buffer.concat([msgHeader,msgEnd]);
                sendMsg.writeUInt32LE(sendMsg.length,2);
                return sendMsg;
            };
            unserilize(data){
				if(data == null){
					return {};
				}
				
                let arrJson = {};
                let apiStatus=data.slice(17,21);
                arrJson.retCode = apiStatus.readInt32LE(0);
                if(apiStatus.compare(Buffer.from([0x00,0x00,0x00,0x00]))!=0){
                    if(apiStatus.compare(Buffer.from([0xe3,0xb1,0xff,0xff]))!=0){
                        return arrJson;
                    }
                }

                let tagTypeCountBuf16 = data.slice(21,23);
                arrJson.count = tagTypeCountBuf16.readInt16LE(0);
                return arrJson;
            };
        },
        "getTagDel":class{
            constructor(){
				this.packetType = 30;
            };
            serilize(tagId){
                let msgHeader = Buffer.alloc(17);
                msgHeader.writeInt16LE(0x5a5a,0);
                msgHeader.writeUInt32LE(0,2);
                msgHeader.writeInt16LE(30,6);
                msgHeader.writeUInt32LE(1,8);
                msgHeader.writeInt16LE(handle,12);
                msgHeader.writeUInt8(0,14);
                msgHeader.writeInt16LE(10,15);
                
                let tagId32Buf = Buffer.alloc(4);
                tagId32Buf.writeUInt32LE(tagId);
                let msgEnd = Buffer.from(['0x6a','0x6a']);
                let sendMsg = Buffer.concat([msgHeader,tagId32Buf,msgEnd]);
                sendMsg.writeUInt32LE(sendMsg.length,2);
                return sendMsg;
            };
            unserilize(data){
				if(data == null){
					return {};
				}
				
                let arrJson = {};
                let apiStatus=data.slice(17,21);
                arrJson.retCode = apiStatus.readInt32LE(0);
                if(apiStatus.compare(Buffer.from([0x00,0x00,0x00,0x00]))!=0){
                    if(apiStatus.compare(Buffer.from([0xe3,0xb1,0xff,0xff]))!=0){
                        return arrJson;
                    }
                }
                return arrJson;   
            };
        },
        //订阅测点实时值变化
        "subRealData":class{
            constructor(){
				this.packetType = 58;
            };
            serilize(arrJson){
                let msgHeader = Buffer.alloc(17);
                msgHeader.writeInt16LE(0x5a5a,0);
                msgHeader.writeUInt32LE(0,2);
                msgHeader.writeInt16LE(58,6);
                msgHeader.writeUInt32LE(1,8);
                msgHeader.writeInt16LE(handle,12);
                msgHeader.writeUInt8(0,14);
                msgHeader.writeInt16LE(10,15);
                
                
                let subscribeId32Buf = Buffer.alloc(4);
                let tagCount32Buf = Buffer.alloc(4);
                tagCount32Buf.writeUInt32LE(arrJson.length);
                let tagIds32Buf = Buffer.alloc(4*arrJson.length);
                for(let i=0; i<arrJson.length;i++){
                    tagIds32Buf.writeUInt32LE(arrJson[i],i*4);
                }
        
                let msgEnd = Buffer.from(['0x6a','0x6a']);
                let sendMsg = Buffer.concat([msgHeader,subscribeId32Buf,tagCount32Buf,tagIds32Buf,msgEnd]);
                sendMsg.writeUInt32LE(sendMsg.length,2);
                realSubCountTmp = arrJson.length;
                return sendMsg;
            };
            unserilize(data){
				if(data == null){
					return {};
				}
				
                let arrJson = {};
                let apiStatus=data.slice(17,21);
                arrJson.retCode = apiStatus.readInt32LE(0);
                if(apiStatus.compare(Buffer.from([0x00,0x00,0x00,0x00]))!=0){
                    if(apiStatus.compare(Buffer.from([0xe3,0xb1,0xff,0xff]))!=0){
                        return arrJson;
                    }
                }

                let subscribeId32Buf = Buffer.from(data.slice(21,25)); 
                this.subscribeId = subscribeId32Buf.readInt32LE(0);
                arrJson.subscribeId = this.subscribeId;
        
                if(apiStatus.compare(Buffer.from([0xe3,0xb1,0xff,0xff]))==0){
                    let tagCount = data.slice(25,29).readInt32LE(0);
                    arrJson.status = [];
                    let pos = 29;
                    for(let i=0; i<tagCount; i++)
                    {
                        arrJson.status[i] = data.slice(pos,pos+4).readUInt32LE(0);
                        pos = pos + 4;
                        if( arrJson.status[i] ==0)
                        {
                            realSubCount++;
                        }
                    }

                    arrJson.message = "batch occur";
                }else{
                    realSubCount += realSubCountTmp;
                } 
                
                realSubCountTmp = 0;
                return arrJson;   
            };
        },
        "setTagAddList":class{
            constructor(){
				this.packetType = 29;
            };
            serializeVar(type,data)
            {
                let retBuf;
                let dataBuf;
                let lenBuf32;
                let strBuf;
                
                let type8Buf = Buffer.alloc(1);
                type8Buf.writeUInt8(type);
                switch(type){
                    case 0:	
                        break;
                    case 1:
                        dataBuf = Buffer.alloc(1);
                        dataBuf.writeUInt8(data);
                        break;
                    case 2:
                        dataBuf = Buffer.alloc(1);
                        dataBuf.writeInt8(data);
                        break;
                    case 3:
                        dataBuf = Buffer.alloc(1);
                        dataBuf.writeUInt8(data);
                        break;
                    case 4:
                        dataBuf = Buffer.alloc(2);
                        dataBuf.writeInt16LE(data);
                        break;
                    case 5:
                        dataBuf = Buffer.alloc(2);
                        dataBuf.writeUInt16LE(data);
                        break;
                    case 6:
                        dataBuf = Buffer.alloc(4);
                        dataBuf.writeUInt32LE(data);
                        break;
                    case 7:
                        dataBuf = Buffer.alloc(4);
                        dataBuf.writeUInt32LE(data);
                        break;
                    case 8:
                        dataBuf = Buffer.alloc(8);
                        dataBuf.writeIntLE(data,0,8);
                        break;
                    case 9:
                        dataBuf = Buffer.alloc(8);
                        dataBuf.writeUIntLE(data,0,8);
                        break;
                    case 10:
                        dataBuf = Buffer.alloc(4);
                        dataBuf.writeFloatLE(data,0);
                        break;
                    case 11:
                        dataBuf = Buffer.alloc(8);
                        dataBuf.writeDoubleLE(data,0);
                        break;
                    case 12: 
                        let tmpsec32Buf = Buffer.alloc(4);
                        let tmpmilldec16Buf = Buffer.alloc(2);
                        tmpsec32Buf.writeUInt32LE(parseInt(data/1000),0);
                        let timemill16 = data - parseInt(data/1000)*1000;
                        tmpmilldec16Buf.writeInt16LE(timemill16,0);
                        dataBuf = Buffer.concat([tmpsec32Buf,tmpmilldec16Buf]);
                        break;
                    case 13:
                        //strBuf = Buffer.from(data); 修改于3-26 用于支持中文
                        strBuf = iconv.encode(data,'gbk'); //修改于3-26 用于支持中文
                        lenBuf32 = Buffer.alloc(4);
                        lenBuf32.writeUInt32LE(strBuf.length,0);
                        dataBuf = Buffer.concat([lenBuf32,strBuf]);
                        break;
                    case 14:
                        strBuf = Buffer.from(data);
                        lenBuf32 = Buffer.alloc(4);
                        lenBuf32.writeUInt32LE(strBuf.length,0);
                        dataBuf = Buffer.concat([lenBuf32,strBuf]);
                        break;
                    case 15:
                        strBuf = Buffer.from(data);
                        lenBuf32 = Buffer.alloc(4);
                        lenBuf32.writeUInt32LE(strBuf.length,0);
                        dataBuf = Buffer.concat([lenBuf32,strBuf]);
                        break;
                    default:
                        break;
                }
                
                retBuf = Buffer.concat([type8Buf,dataBuf]);
                return retBuf;
            };
            serilize(arrJson){
                let msgHeader = Buffer.alloc(17);
                msgHeader.writeInt16LE(0x5a5a,0);
                msgHeader.writeUInt32LE(0,2);
                msgHeader.writeInt16LE(29,6);
                msgHeader.writeUInt32LE(1,8);
                msgHeader.writeInt16LE(handle,12);
                msgHeader.writeUInt8(0,14);
                msgHeader.writeInt16LE(10,15);
        
                let tagId32Buf = Buffer.alloc(4);
                tagId32Buf.writeUInt32LE(arrJson.tagId);
                let tagCount32Buf = Buffer.alloc(4); 
                tagCount32Buf.writeUInt32LE(arrJson.tags.length);
                let tagPropsBufs = [];
                for(let i=0;i<arrJson.tags.length;i++){
                    let tagPropCount = arrJson.tags[i].length;
                    let tagpropCount16Buf = Buffer.alloc(2);
                   
                    if(tagPropCount>0){
                        tagpropCount16Buf.writeInt16LE(tagPropCount)
                    }
                    tagPropsBufs.push(tagpropCount16Buf);
                    for(let j=0; j<tagPropCount; j++){
                        let propId16Buf = Buffer.alloc(2);
                        propId16Buf.writeInt16LE(arrJson.tags[i][j].propId);
                        tagPropsBufs.push(propId16Buf);
                        let propValueBuf = this.serializeVar(arrJson.tags[i][j].propValue.type,arrJson.tags[i][j].propValue.value);
                        tagPropsBufs.push(propValueBuf);
    
                    }

                }
                
                let tagPropdBuf = Buffer.concat(tagPropsBufs);
                let msgEnd = Buffer.from(['0x6a','0x6a']);
                let sendMsg = Buffer.concat([msgHeader,tagId32Buf,tagCount32Buf,tagPropdBuf,msgEnd]);
                sendMsg.writeUInt32LE(sendMsg.length,2);
                return sendMsg;
            };
            unserilize(data){
				if(data == null){
					return {};
				}
                let apiStatus = data.slice(17,21);
                let arrJson = {};
                arrJson.retCode = apiStatus.readInt32LE(0);
                if(arrJson.retCode ==0){
                    let tagCount = data.slice(21,25).readInt32LE(0);
                    let pos = 25;
                    arrJson.tagIds=[];
                    for(let i=0;i<tagCount;i++){
                        arrJson.tagIds.push(data.slice(pos,pos+4).readInt32LE(0));
                        pos += 4;
                    }
                    
                }
                return arrJson;    
            };
        },
        "unSubRealData":class{
            constructor(){
				this.packetType = 60;
            };
            serilize(arrJson){
                let msgHeader = Buffer.alloc(17);
                msgHeader.writeInt16LE(0x5a5a,0);
                msgHeader.writeUInt32LE(0,2);
                msgHeader.writeInt16LE(60,6);
                msgHeader.writeUInt32LE(1,8);
                msgHeader.writeInt16LE(handle,12);
                msgHeader.writeUInt8(0,14);
                msgHeader.writeInt16LE(10,15);
        
                let subscribeId32Buf = Buffer.alloc(4);
                subscribeId32Buf.writeUInt32LE(arrJson.subscribeId);
                let tagCount = arrJson.tagIds.length;
                let tags32Buf = Buffer.alloc(4*tagCount +4);
                let pos = 0;
                tags32Buf.writeUInt32LE(tagCount,pos);
                pos += 4;
                for(let i=0; i<arrJson.tagIds.length; i++){
                    tags32Buf.writeUInt32LE(arrJson.tagIds[i],pos);
                    pos += 4;
                }
                
                let msgEnd = Buffer.from(['0x6a','0x6a']);
                let sendMsg = Buffer.concat([msgHeader,subscribeId32Buf,tags32Buf,msgEnd]);
                sendMsg.writeUInt32LE(sendMsg.length,2);
                realSubCountTmp = arrJson.tagIds.length;
                return sendMsg;
            };
            unserilize(data){
				if(data == null){
					return {};
				}
				
                let apiStatus = data.slice(17,21);
                let arrJson = {};
                arrJson.retCode = apiStatus.readInt32LE(0);

                if(apiStatus.compare(Buffer.from([0xe3,0xb1,0xff,0xff]))==0){
                    let tagCount = data.slice(25,29).readInt32LE(0);
                    arrJson.status = [];
                    let pos = 21;
                    for(let i=0; i<tagCount; i++)
                    {
                        arrJson.status[i] = data.slice(pos,pos+4).readUInt32LE(0);
                        pos = pos + 4;
                        if( arrJson.status[i] ==0)
                        {
                            realSubCount--;
                        }
                    }
    
                }else{
                    realSubCount -= realSubCountTmp;
                }     
                
                realSubCountTmp = 0;
                return arrJson;    
            };
        }
    }

};

module.exports.init = function(FRtdb,dataChange,almChange){
    DB = new ps6();
    DB.callbackDataChange = dataChange;
    DB.callbackAlmChange = almChange;
	setTimeout(()=>{
			setInterval(async ()=>{
			let ret = await FRtdb.getServerTime();
		},/*默认5分钟*//*module.exports.options.heartBeat*/);
	},300000);
}