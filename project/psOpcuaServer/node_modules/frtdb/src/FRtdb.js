const  Connection = require("./connection.js");
const events = require('events');
class FRtdb extends events{
    constructor(ip,port,options) {
        super();
        options = options || {};
        //基础属性
        this.baseConfig = {ip,port};
        //扩展属性
        this.options = Object.assign({
            dialect:'fc7',          //默认fc7
            username:'',
            password:'',
            logging: console.log,
            path:'',
            heartBeat:3000,          //心跳周期
            enableAlarm:false,        //默认不请求报警
            maxCallbackLength:10
        },options);    
        //异步核心，不支持并发，顺序执行
        this.callback = null;
        this.method = null;
        //消息码到对象函数的转换(网路函数)
        this.mapPacketType2Obj = new Map();
        this.mapPacketName2Obj = new Map();
        //加载合适插件
        let DBPlugin;
        switch (this.options.dialect) {
            case 'fc7':
            DBPlugin = require('./fc7');                
                break;
            case 'ps6':
			DBPlugin = require('./ps6'); 
                break;
            case 'ef5': 
            DBPlugin = require('./ef5');               
                break;
            default:
                throw new Error('The dialect ' + this.options.dialect + ' is not supported. Supported dialects: fc7, ps6, and ef5');
                break;
        }
        //插件方法深拷贝过来，并生成对应方法
        for(let method in DBPlugin.remoteMethod){
            //构造私有类对象,用于拼包、解包
            this["_" + method] = new DBPlugin.remoteMethod[method]();
            this["_" + method].parent = this;
            this["_" + method].arrCallback = [];

            //功能码解析
            let type = this["_" + method].packetType;
            if (type) {
                if (typeof type == "number") {//数字
                    this.mapPacketType2Obj.set(type,this["_" + method]);
                    
                }else{//数组，一一存放
                    for (let i = 0; i < type.length; i++) {
                        const element = type[i];
                        this.mapPacketType2Obj.set(element,this["_" + method]);                    
                    }
                }             
            }

            //保存方法名称
            this.mapPacketName2Obj.set(method,this["_" + method]);
            //构造真实调用方法
            this[method] = (async (jsonObj)=>{  
                //callback过长，主动调用
                if (this.mapPacketName2Obj.has(method)) {
                    const methodObj = this.mapPacketName2Obj.get(method);
                    if(methodObj.arrCallback.length > this.options.maxCallbackLength){
                        var callback =  methodObj.arrCallback.shift();
                        callback(null/*没有考虑异常或者错误情况*/,methodObj.unserilize(null));                      
                    }
                }        
                //对象中的拼包函数
                let sendData = this["_" + method].serilize(jsonObj);
                if(!sendData){//如果发送报文为空，直接返回
                    return;
                }
                return new Promise((resolve, reject) =>{
                    this.sendData(sendData,method,(err, data) =>{
                        if(err) return reject(err);
                        resolve(data);
                    })
                });                     
            });
        }
        //加载本地方法
        for(let method in DBPlugin.localMethod){
            this[method] = DBPlugin.localMethod[method];
        }
                
        //网络库加载及初始化
        this.conn = new Connection(this.baseConfig.ip,this.baseConfig.port);
        this.conn.connect();
        //连接成功后才加载具体插件
        this.conn.on('connect', () =>{
            
        });
        //接受到一个完整包
        this.conn.on("package",(pkage) => {
            this.onReceivePackage(pkage);
        });

        //最后初始化插件
        //初始化监听订阅实时和报警数据变化的事件
        DBPlugin.init(this,(data)=>{
            this.emit("dataChange",data);
        },(alarm)=>{
            this.emit("alrmChange",alarm);
        });
    }

    sendData(data,method,callback){
        if (this.mapPacketName2Obj.has(method)) {
            const methodObj = this.mapPacketName2Obj.get(method);
            methodObj.arrCallback.push(callback);
            this.conn.sendData(data);
        } 
    }

    onReceivePackage(pkage){                        
        const type = this.getPacketType(pkage);
        if (this.mapPacketType2Obj.has(type)) {
            const methodObj = this.mapPacketType2Obj.get(type);
            var callback =  methodObj.arrCallback.pop();
            if (callback) {
                callback(null/*没有考虑异常或者错误情况*/,methodObj.unserilize(pkage));            
            }else {
                //处理服务端发过来的包，不是我的方法
                this.unknownPacket(pkage);
            }
            
        }else{//处理其他数据包
            //处理未知网路包
            this.unknownPacket(pkage);
        }
    }
}
module.exports = FRtdb;
module.exports.FRtdb = FRtdb;
module.exports.default = FRtdb;