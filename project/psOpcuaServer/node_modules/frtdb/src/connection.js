const net = require('net');
const eventEmitter = require('events');
class Connection extends eventEmitter{
    constructor(host,port){
        super();
        this.host = host;
        this.port = port;
        //消息结构缓存
		this.chunk = undefined;
		this.chunkLength = 0;
        this.offset = 0;
        //包头
        this.headerLen = 0;//包头长
		this.posOfLen = -1;//长度位置
		this.lenBytes = 0;//长度字节长度
		this.test = 0;
    }
    
    connect(){
        this.socket = net.createConnection(this.port, this.host,() => {
            this.emit('connect')
        });
        
        this.socket.on('error',(err)=>{
            throw err;
        }); 

        this.socket.on('end',()=>{
            console.log('socket end');
        });
        
        this.socket.on('data',(data)=>{
            //添加缓存
            this.addChunk(data);
            //解析报文
			this.parsePacket();
        });
    }

	setHeader(len, pos, bytes){
		this.headerLen = len;
		this.posOfLen = pos;
		this.lenBytes = bytes;
    }
    sendData(data){
        this.socket.write(data);
    }
    //内存池
    addChunk(chunk){
		if (!this.chunk) {
			this.chunk = chunk;
			this.chunkLength = chunk.length;
			this.offset = 0;
			return
		}
		
		var newLength = this.chunkLength + chunk.length;
		
		if (newLength > this.chunk.length) {
		  var newBufferLength = this.chunk.length * 2
		  while (newLength >= newBufferLength) {
			newBufferLength *= 2;
		  }
		  var newBuffer = Buffer.alloc(newBufferLength);
		  this.chunk.copy(newBuffer,0,this.offset,this.offset + this.chunkLength);
		  this.chunk = newBuffer;
		  this.offset = 0;
		}

		let spaceLen = this.chunk.length - this.offset - this.chunkLength;
		if(spaceLen < chunk.length){
			for(let i=0; i<this.chunkLength; i++){
				this.chunk[i] = this.chunk[i+this.offset];
				this.offset = 0;
			}
		}

		chunk.copy(this.chunk,this.chunkLength+this.offset,0,chunk.length);
		this.chunkLength = newLength;
    }
    
	parsePacket(){
		//解析报头
		let nLen = 0;
		if (this.chunkLength >= this.headerLen) {
			if(this.posOfLen == -1){
				nLen = this.headerLen;
			}else{
				let nMsgLen = this.chunk.readIntLE(this.posOfLen + this.offset,this.lenBytes);
				if(this.chunkLength >= nMsgLen){
					nLen = nMsgLen;
				}
			}
		}			
		if (nLen > 0) {
			//完整包，开始截取数据			
			let bufMsg = this.chunk.slice(this.offset,nLen + this.offset);
			//偏移
			this.offset += nLen;
			this.chunkLength -= nLen;

			if(this.chunkLength == 0){
				this.offset = 0;
			}

			//emit 深拷贝使用
			this.emit('package', Buffer.from(bufMsg));					
			//粘报继续处理
			if(this.chunkLength >0){
                this.parsePacket();//不支持并发
			}		
		}
	}
}
module.exports = Connection;