var addon = require('pSpace');
var tag = require('tag');
var async = require('async');
var conStr = {
	"host":"localhost",
	"user":"admin",
	"password":"admin888"
};
var ps = new addon();
//想让下列函数串行执行，也就是一个执行完了才接着执行下一个，普通处理流程很简单
//但是这样做的话嵌套太多，代码不雅观，很容易出错
var time = new Date();
var data = {
	"value":55.56,
	"quality":"good",
	"time":time
};

ps.open(conStr,function(err,con){
	if(err){
		console.log(err);
	}else{
		con.read("/tag/tag1.pv",function(err,tagName,pv){
			if(err){
				console.log(err);
			}else{
				con.write("/tag/tag2.pv",data,function(err,tagName){
					if(err){
						console.log(err);
					}else{
						con.read("/tag/tag2.pv",function(err,tagname,val){
							if(err){
								console.log(err);
							}else{
								console.log(val);
							}
						});
					}
				});
			}
		});
	}
});


//用asyn解决
/**
 * 串行执行，一个函数数组中的每个函数，每一个函数执行完成之后才能执行下一个函数。
 * 如果任何一个函数向它的回调函数中传了一个error，则后面的函数都不会被执行，并且会立刻将该error以及已经执行了的函数的结果，传给series中最后那个callback。
 * 当所有的函数执行完后（没有出错），则会把每个函数传给其回调函数的结果合并为一个数组，传给series最后的那个callback。
 * 还可以json的形式来提供tasks。每一个属性都会被当作函数来执行，并且结果也会以json形式传给series最后的那个callback。这种方式可读性更高一些。
 */


ps.open(conStr,function(err,con){
	if(err){
		console.log(err);
	}else{
		async.series([
			function(cb){
				con.read("/tag/tag1.pv",function(err,tagName,pv){
				if(err){
					console.log(err);
				}else{
					cb(err,pv);
				}
			   });
			},
			function(cb){
				con.write("/tag/tag2.pv",23.67,function(err,tagName){
					if(err){
						console.log(err);
					}else{
						cb(err,tagName);
					}
				});
				
			},
			function(cb){
				con.read("/tag/tag2.pv",function(err,tagname,val){
						if(err){
							console.log(err);
						}else{
							cb(err,val);
						}
					});
			}
		],function(err,results){
			console.log(results);
		});
	}
});

/*
ps.on('isconnect',function(){
	if(!ps.isConnected()){
		console.log("重连");
	}
});
ps.emit('isconnect',null);
*/
var node = new tag.Node();
var analog = new tag.Analog();
	analog.Description = "node test";
var string = new tag.String();
var digital = new tag.Digital();

//同步加点
//添加5个点，但是5个点的添加顺序受到限制
//tag,tag2,tag4可以并行执行，但是tag1必须等到tag添加完毕
//tag3必须等tag2添加完毕
ps.open(conStr,function(err,con){
	if(err){
		console.log(err);
	}else{
		con.add('/tag',node);
		con.add('/tag/tag1',analog);
		con.add('/tag2',node);
		con.add('/tag2/tag3',digital);
		con.add('/tag4',string);
	}
});

//用异步如何处理，异步的执行顺序是不确定的，需要达到这样的效果，采用asyn流程控制模块
/*
	用来处理有依赖关系的多个任务的执行。
	比如某些任务之间彼此独立，可以并行执行；
	但某些任务依赖于其它某些任务，只能等那些任务完成后才能执行。
*/

//异步加点
ps.open(conStr,function(err,con){
	if(err){
		console.log(err);
	}else{
		async.auto({
			addtag:function(cb){
				con.add('/tag',node,function(err,tagName){
					cb(err,tagName);
				})
			},
			addtag1:['addtag',function(cb){
				con.add('/tag/tag1',analog,function(err,tagName){
					cb(err,tagName);
				});
			}],
			addtag2:function(cb){
				con.add('/tag2',node,function(err,tagName){
					cb(err,tagName);
				});
			},
			addtag3:['addtag2',function(cb){
				con.add('/tag2/tag3',digital,function(err,tagName){
					cb(err,tagName);
				});
			}],
			addtag4:function(cb){
				con.add('/tag4',string,function(err,tagName){
					cb(err,tagName);
				});
			}
		},function(err,result){
			if(err){
				console.log(err);
			}else{
				console.log(result);
			}
			
		});
	}
});

/*
//订阅
ps.open(conStr,function(err,con){
	if(err){
		console.log(err);
	}else{
		//实时值订阅
		con.sub('/系统变量/时间变量/time.real',function(err,tagName,value){
			if(err){
				console.log(err);
			}else{
				console.log(value);
			}
		});
		
		//属性订阅
		con.sub('/tag/tag1.props',function(err,tagName,value){
			if(err){
				console.log(err);
			}else{
				console.log(value);
			}
		});
		
	}
});
*/
var his = {
	"value":34.09,
	"time":new Date(),
	"quality":"good"
};
var date1 = new Date("2014-05-22T08:00:00+08:00");
var date2 = time;
var timeStamps=[date1,date2];
var hisPro = {
	"startTime":date1,
	"endTime":date2,
	"resampleInterval":10000000,
	"aggregates":"PS_HIS_START"
};
/*
//读写历史
ps.open(conStr,function(err,con){
	if(err){
		console.log(err);
	}else{
		console.log();
		con.write('/tag/tag1.his.insert',his,function(err,tagName,tagID){
			if(err){
				console.log(err);
			}else{
				console.log(tagName);
			}
		});
		con.write('/tag/tag2.his.insertReplace',his,function(err,tagName,tagID){
			if(err){
				console.log(err);
			}else{
				console.log(tagName);
			}
		});
		con.write('/tag/tag1.his.replace',his,function(err,tagName,tagID){
			if(err){
				console.log(err);
			}else{
				console.log(tagName);
			}
		});
		con.read("/tag/tag1.his.atTime",timeStamps,function(err,resVal){
			if(err){
				console.log(err);
			}else{
				for(i=0;i<resVal.length;i++){
					console.log("查询固定时间历史数据成功:");
					console.log(resVal);
				}	
			}
		});
		con.read("/tag/tag1.his.raw",date1,date2,1,function(err,resVal){
			if(err){
				console.log(err);
			}else{
				console.log(resVal);
			}
		});
		con.read("/tag/tag1.his.processed",hisPro,function(err,resVal){
			if(err){
				console.log(err);
			}else{
				console.log("异步查询历史统计数据：");
				console.log(resVal);
			}
		});

	}
});
*/
/*
//实时读写批量
var batRead = ["/tag/tag1.pv","/tag/tag2.pv","/tag/tag1.pv"];
var data1  = {
	"value":830.001,
	"quality":"bad",
	"time":new Date(new Date().getTime())
};
var data2 = {
	"value":29.890,
	"quality":"bad"
	//"time":new Date(new Date().getTime())
};

var batWrite = {"/tag/tag1.pv":23.09,"/tag/tag2.pv":234.43};
ps.open(conStr,function(err,con){
	if(err){
		console.log(err);
	}else{
		con.read(batRead,function(err,value){
			if(err){
				console.log(err);
			}else{
				console.log(value);
			}

		});
	
	}
});
*/
/*
ps.open(conStr,function(err,con){
	if(err){
		console.log(err);
	}else{
		con.read("/系统变量/时间变量/date.pv",function(err,tagName,value){
			if(err){
				console.log(err);
			}else{
				console.log("异步读数据:");
				console.log(value);
			}
		});
		var val = con.read("/系统变量/时间变量/date.pv");
		if(val instanceof ps.Err){
			console.log(val.code);
			console.log(val.errString);
		}else{
			console.log("同步读数据:");
			console.log(val);
		}
	}
});
*/

var con = ps.open(conStr);
if(con instanceof ps.Err){
	console.log(con.code);
	console.log(con.errString);
}else{
	console.log("连接成功!");
}
con.read("/系统变量/时间变量/date.pv",function(err,tagName,value){
			if(err){
				console.log(err);
			}else{
				console.log("异步读数据:");
				console.log(value);
			}
		});
var val = con.read("/系统变量/时间变量/date.pv");
if(val instanceof ps.Err){
	console.log(val.code);
	console.log(val.errString);
}else{
		console.log("同步读数据:");
		console.log(val);
}

/*
var addon = require('pSpace');
var tag = require('tag');
var async = require('async');

var ps = new addon();
ps.on();
ps.emit();
ps.onece();
ps.removeListener()
ps.open();
ps.isConnected();
*/
ps.on("isCon",function(){
	if(ps.isConnected()){
		console.log('pSpace is connected!');
	}else{
		console.log('pSpace is not connected!');
	}
});
ps.on("test",function(){
	console.log('Hello');
});
ps.emit("isCon",null);
ps.emit('test',null);

var listenArr = ps.listeners('isCon');
console.log(listenArr[0]);
var ana = new tag.Analog();
ana.DataType = "float";
var res = con.add("/tag13",ana);
if(res instanceof ps.Err){
	console.log(res.errString);
}
